\documentclass[10pt,twocolumn]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

\usepackage{lmodern}
\usepackage[sc]{mathpazo} % or option osf
\usepackage{newpxmath}
\usepackage[scaled = 0.75]{beramono}

\newcommand*\cpp{C\kern-0.3ex\raisebox{0.17ex}{\texttt{+\kern-0.3ex+}}}

\usepackage{xpatch}
\usepackage{xcolor}
\usepackage{realboxes}
\definecolor{mygray}{rgb}{0.9,0.9,0.9}
\usepackage{listings}
\lstdefinelanguage{commentonly}{ morecomment=[l]{\#} }
\lstset{literate=%
{Ö}{{\"O}}1
{Ä}{{\"A}}1
{Ü}{{\"U}}1
{ß}{{\ss}}1
{ü}{{\"u}}1
{ä}{{\"a}}1
{ö}{{\"o}}1
,basicstyle=\ttfamily
,backgroundcolor=\color{mygray}
,commentstyle=\emph
,language=commentonly
,upquote=true
}
%\makeatletter
%\xpretocmd\lstinline{\Colorbox{mygray}\bgroup\appto\lst@DeInit{\egroup}}{}{}
%\makeatother
\makeatletter
\xpretocmd\lstinline
  {%
   \bgroup\fboxsep=1.5pt
   \Colorbox{mygray}\bgroup\kern-\fboxsep\vphantom{\ttfamily\char`\\y}%
   \appto\lst@DeInit{\kern-\fboxsep\egroup\egroup}%
  }{}{}
\makeatother

\usepackage{enumitem}
\setlist{nosep}

\usepackage{adjustbox}
\usepackage[a4paper, margin=1mm, includefoot, footskip=15pt]{geometry}

\usepackage[pdftitle={Grundlagen der Programmiersprache C++}
, pdfauthor={Georg Kindermann}
, pdfsubject={C++}
, pdfkeywords={C++, Lang, Progammiersprache, Tutorial, Einführung, German,
               Deutsch}
, pdflang={de-AT-1996}
, colorlinks=true
, linkcolor=blue
, urlcolor=blue
, pdfpagemode=UseNone]{hyperref}

\nonfrenchspacing
\sloppy

\title{Grundlagen der Programmiersprache \cpp{}}
\author{Georg Kindermann}
%\date{19. Juni 2023}

\begin{document}

\maketitle

%\begin{abstract}
%  Eine kurze Einführung in die Sprache Julia.
%\end{abstract}

\tableofcontents


Die Sprache \cpp{} baut auf der Sprache C auf. Für beide gibt es eine ISO Norm
die laufend aktualisiert wird. Eine Sammlung der letzten Normentwürfe (final
working draft) ist auf
\href{https://en.cppreference.com/w/cpp/links}{Cppreference/Links} zu finden.
Inwieweit diese Norm von verschiedenen Compilern erfüllt wird, ist auf
\href{https://en.cppreference.com/w/cpp/compiler_support}{Cppreference/Compiler\_support}
zusammengestellt. Hier wird \cpp{}23 verwendet. Eine ausführliche Referenz zu
\cpp{} und C ist auf \href{https://en.cppreference.com/w/}{Cppreference} oder
auch auf \href{https://learn.microsoft.com/de-de/cpp/cpp}{MS Dokumentation zu
C++} zu finden.

Programme können mit einem beliebigen Texteditor geschrieben werden und
anschließend mit einem Compiler in ein ausführbares Programm übersetzt werden.
Integrierte Entwicklungsumgebungen (IDE) helfen beim Schreiben von Programmen
und Werkzeuge wie \lstinline|make| beim compilieren und erstellen von
Bibliotheken (libraries).

Mit \lstinline|g++| wird ein Programm mit dem Befehl \lstinline|g++ Programm.cc|
compiliert und als \lstinline|a.out| abgespeichert. Mit
\lstinline|g++ -o prg Programm.cc| wird eine Datei \lstinline|prg| erzeugt.

Mit \lstinline|clang| wird ein Programm mit dem Befehl
\lstinline|clang++ Programm.cc|
compiliert und als \lstinline|a.out| abgespeichert. Mit
\lstinline|clang++ -o prg Programm.cc| wird eine Datei \lstinline|prg| erzeugt.

Mit \lstinline|-std=c++23| wird angegeben das \cpp{}23 verwendet wird.
Mit z.\,B.\ \lstinline|-O3 -march=native -flto| wird das erzeugte Programm
optimiert, um schneller zu laufen. Mit \lstinline|-Weverything| (nur bei clang),
\lstinline|-Wall| oder \lstinline|-Wextra| gibt der Compiler zusätzliche
Warnungen aus.

Mit \lstinline|msvc| (Developer PowerShell for VS) wird ein Programm mit dem
Befehl \lstinline|cl Programm.cc| compiliert und als \lstinline|Programm.exe|
abgespeichert. Mit \lstinline|cl Programm.cc /O2| wird auf Geschwindigkeit
optimiert. Mit \lstinline|cl Programm.cc /Wall| werden alle Warnungen
ausgegeben. Mit \lstinline|cl Programm.cc /std:c++20| wird \cpp{}20\footnote{23
ist derzeit v17.8.2/19.38.33130 nicht verfügbar. Eventuell
\lstinline|/std:c++latest| oder \lstinline|/experimental| verwenden} verwendet. 

C Dateien enden mit \lstinline|.c|. \cpp{} Dateien haben üblicherweise die
Extension \lstinline|.cc| oder \lstinline|.cpp|. Header Dateien für C enden mit
\lstinline|.h|. Header Dateien für \cpp{} enden meist mit \lstinline|.h|,
\lstinline|.hh| oder \lstinline|.hpp|.

Die Quelldatei (Sourcecode) wird zunächst vom Präprozessor verarbeitet (z.\,B.\
\lstinline|#include|) und wird anschließend compiliert. Danach bindet der Linker
Bibliotheken (Libraries) zu einem ausführbaren Programm zusammen. Mit
\lstinline|g++ -c srcA.cc| wird nur compiliert und die Datei \lstinline|srcA.o|
erzeugt. Mit \lstinline|g++ srcB.cc srcA.o| wird srcB compiliert und die
Objektdatei von srcA dazugebunden.

\section{Basis}
\label{sec:einleitung}

\subsection{Grundstruktur}

Die erste Funktion die bei einem Programmstart aufgerufen wird ist
\lstinline|main|.
\begin{lstlisting}[language=C++]
int main() {}
\end{lstlisting}
\lstinline|main| gibt mit \lstinline|return| eine \lstinline|Integerzahl| an das
Betriebssystem zurück, die angibt, ob das Programm erfolgreich abgeschlossen (0)
oder durch einen Fehler (nicht 0) beendet wurde. In \lstinline|main| kann
\lstinline|return| weggelassen werden, was \lstinline|return 0;| entspricht. In
\lstinline|stdlib.h| bzw.\ \lstinline|cstdlib| sind \lstinline|EXIT_SUCCESS| und
\lstinline|EXIT_FAILURE| definiert.
\begin{lstlisting}[language=C++]
#include <cstdlib>

int main() {
  return EXIT_SUCCESS;
}
\end{lstlisting}
\lstinline|main()| (oder \lstinline|main(void)|) bedeutet, das beim
Programmaufruf keine Argumente an die Funktion übergeben werden. Mit:
\begin{lstlisting}[language=C++]
int main(int argc, char* argv[]) {}
\end{lstlisting}
können Argumente (command line arguments) von der Funktion übernommen werden.
\lstinline|argc| gibt die Anzahl an Argumenten an die in \lstinline|argv| zu
finden sind. Auf Position 0 steht der Programmname.

\subsection{Kommentare}

\begin{lstlisting}[language=C++]
/* Kommentar */

// Kommentar

#if 0
  std::cout << "Wird weder ausgeführt noch Compiliert\n";
#endif

if (false)
{
  std::cout << "Wird nicht ausgeführt\n";
}
\end{lstlisting}

\subsection{Bibliotheken -- Libraries}

Funktionen sind in Bibliotheken abgelegt. Diese müssen aktiv ausgewählt werden,
bevor sie verwendet werden können. Dies geschieht mit dem Präprozessorbefehl
\lstinline|#include|. \lstinline|#include <lib>| sucht die Headerdatei von
\lstinline|lib| im Standardsuchpfad für header Dateien.
\lstinline|#include "lib.h"| sucht im aktuellen Verzeichnis nach der Datei
\lstinline|lib.h|. Wenn diese nicht gefunden wird, wird im Standardsuchpfad für
Headerdateien weiter gesucht. Headerdateien von C enden mit \lstinline|.h|.

\subsection{Ein-- und Ausgabe}

Ein-- und Ausgabe ist in \lstinline|iostream| definiert. Es gibt die Befehle
\lstinline|cin| (Eingabe), \lstinline|cout| (Ausgabe), \lstinline|cerr|
(unmittelbare Fehlerausgabe) und \lstinline|clog| (gepufferte Fehlerausgabe).
Alle Befehle gibt es auch für wide Character mit vorangestelltem w, also z.B.
\lstinline|wcin|.

\begin{lstlisting}[language=C++]
#include <iostream>

int main() {
  int n;
  std::cout << "Anzahl n: ";
  std::cin >> n;
}
\end{lstlisting}

Eine neue Zeile kann mit \lstinline|std::cout << "\n";| oder mit
\lstinline|std::cout << std::endl;| erzeugt werden, wobei \lstinline|endl| den
buffer leert (flush) und damit in der Regel langsamer ist als \lstinline|\n|.

\subsection{Namespace}

Helfen Namenskonflikte zu vermeiden, indem Funktionen bestimmten Namensräumen
zugeordnet werden. Funktionen mit gleichem Nahmen stellen kein Problem dar,
solange sie in verschiedenen Namensräumen definiert sind. Funktionen des
Standardlibraries sind im Namensraum \lstinline|std| und können mit
\lstinline|std::FUNKTIONSNAME| aufgerufen werden. Mit
\lstinline|using namespace std;| kann die Funktion auch ohne \lstinline|std::|
aufgerufen werden. Namespaces können auch selbst erzeugt werden.

\subsection{Datentypen}

\lstinline|bool| ist der logische typ mit \lstinline|true| oder
\lstinline|false|.

Ganzzahlige Typen mit steigender Größe sind \lstinline|char|, \lstinline|short|,
\lstinline|int|, \lstinline|long| und \lstinline|long long|. Diese können mit
\lstinline|signed| und \lstinline|unsigned| also positive und negative oder nur
positive Zahl definiert werden.

Gleitkommazahlen mit steigender Größe sind \lstinline|float|,
\lstinline|double|, \lstinline|long double|.

\subsection{Deklaration, Definition, Initialisierung und Zuweisung}

\begin{lstlisting}[language=C++]
int i;     // Deklaration und Definition, i hat unbekannten Wert
i = 0;     // Zuweisung - Assignment
i = {0};   // Zuweisung - Assignment - EMPFOHLEN
//i = {0.};  // Fehler: narrowing conversion
int j = 1; // Dekl., Def. und Copy-Initialisierung
int jn = 1.5; // jn == 1
int k(2);  // Dekl., Def. und Constructor/Direct-Initialisierung
int kn(2.5);  // kn == 2
// int f();  // Würde die Funktion f deklarieren
// int f() {return 0};  // Dek. und Def. von Funktion f
// f(2);   // Würde die Funktion f mit Argument 2 aufrufen
int l{};   // Dekl., Def. und Value-Initialisierung, l == 0
int m{3};  // Dekl., Def. und Uniform/Direct-Init. - EMPFOHLEN
// int mn{3.5};  // Fehler: narrowing conversion
\end{lstlisting}

\subsection{Blöcke -- Compound / block}

Fassen mehrere Anweisungen zu einer zusammen. Sie beeinflussen die Gültigkeit
und Sichtbarkeit von Variablen.

\begin{lstlisting}[language=C++]
#include <fstream>
int i{0};  // i0, global
int main()
{ // Beginn des äußeren Blocks
  int i{1};  // i1 verdeckt globales i
  int j{3};
  {  // Beginn des inneren Blocks
    std::ofstream f("test.txt");  // Datei test.txt öffnen
    f << i << "\n";               // i1 schreiben
    int i {2};  // lokales i2, verdeckt i1, auf welches ab hier
                //   nicht mehr zugegriffen werden kann
    f << i << "\n";               // lokales i2 schreiben
    f << ::i << "\n";             // globales i0 schreiben
    f << j << "\n";               // j3 schreiben
  }  // Ende des inneren Blocks
     //   Destruktor Aufruf von f -> flush und schließen
     //   lokales i2 entfernt, i1 wider sichtbar
} // Ende des äußeren Blocks
\end{lstlisting}

\section{Kontrollstrukturen}

\subsection{Auswahlanweisungen -- Selection}

\subsubsection{if else}

Ausführen von Code, wenn Bedingung erfüllt ist.

\begin{lstlisting}[language=C++]
int i{1};

if (i > 2)
  if (i < 4)
    i = {0};
  else  // gehört zu if (i < 4)
    i = {1};
else  // gehört zu if (i > 4)
  i = {2};

if (i > 2)  // das Gleiche nur mit Klammern
{
  if (i < 4)
  {
    i = {0};
  }
  else
  {
    i = {1};
  }
}
else
{
  i = {2};
}

if (int ii = i*i; i > 0)  // mit Initialisierer
  i -= ii;
else {
  // int ii;  // error: redeclaration of ii
  i += ii;
}
// ++ii;  // ii hier nicht bekannt

// typedef declaration
if (typedef int Foo; true) { (void)Foo{}; }

// alias declaration
if (using Foo = int; true) { (void)Foo{}; }

constexpr bool TEST = true;
if constexpr (TEST) {  //Auswertung wenn Compiliert wird
  if (i == 0) i = {1};
}
i = {10 / i};
\end{lstlisting}

Mit \lstinline|if consteval| testen ob constexpr-Funktion zur Compilationszeit
ausgewertet wird. Hier müssen Blöcke (compound \lstinline|{ }|) verwendet
werden.

\begin{lstlisting}[language=C++]
#include <iostream>

constexpr int f(int x) noexcept {
  if consteval { return 0; } else { return x; }
}

int main() {
  const int i { f(2) };  // Auswertung zur Compilationszeit
  int j{2};             // nicht konstant
  const int k { f(j) };  // Auswertung zur Laufzeit
  std::cout << i << " " << k << "\n";
}
\end{lstlisting}

\subsubsection{?: -- dreiteilige Bedingung / Ternary conditional}

\lstinline|E1 ? E2 : E3| Wenn E1 true, dann E2 sonst E3.

\begin{lstlisting}[language=C++]
int n = {1 > 2 ? 7 : 8};  // 1 > 2 ist false, so n = 8
int m{0};
(n == m ? n : m) = {9};  // n == m ist false, so m = 9
\end{lstlisting}

\subsubsection{switch}

Springe, in Abhängigkeit eines Wertes, an eine Programmzeile. Der Wert muss
\lstinline|int| oder \lstinline|enum| oder implizit in int umwandelbar
sein.

\begin{lstlisting}[language=C++]
#include <iostream>

int main()
{
  const int k{9};
  switch (int i{k / 2}; i)  // i nur in switch bekannt
  // switch (k)  // Variante ohne Initialisierer
  {
    case 1:
      std::cout << '1';
      break;
    [[unlikely]] case 2:
      std::cout << '2';
      [[fallthrough]]; // nicht nötig, Hinweise das beabsichtigt
    [[likely]] case 3:
      std::cout << '3';
      break;
    case 4:
      //int j{0};  // Error weil man in den scope von
                    // initialisiertem i springen kann
      int j;
      j = {0};
      break;
    case 5:
    {
      int j{0};
      break;
    }
    case 6:
      // int i;  // error: redeclaration of i
    default:
      std::cout << "Default\n";
  }
}
\end{lstlisting}

\subsection{Schleifen, Wiederholungen -- Iteration}
\subsubsection{for}

Schleife mit Startwert, Bedingung (wird vor jeder Iteration geprüft) und
iteration-expression (wird nach jedem loop ausgeführt).

\begin{lstlisting}[language=C++]
#include <iostream>
#include <tuple>
#include <vector>

int main()
{
  double s{0.};
  int j{1};  // Wird in Schleife verdeckt
  for (int i{1}, j{9}; i < 10; ++i, --j)
  {
    double x{0.5};  // constructor and destructor wird bei
                    // jedem loop aufgerufen
    //double i{0.};  // Error: redeclaration von i
    s += i * j * x;
  }
  //--i;  // Error: Out of scope
  std::cout << s << "\n";

  char cstr[]{"Hallo"};
  for (int n = 0; char c = cstr[n]; ++n) std::cout << c;

  s = {0.};
  // Verschiedene Typen mittels structured binding declaration
  for (auto [i, f] = std::tuple{int{1}, float{0.1}}; i < 10 ;
       ++i, f += .1)
  {
    s += i * f;
    //int i;  // Error: redeclaration von i
  }
  std::cout << s << "\n";

  s = {0.};
  {
    int i{1};
    float f{0.1};
    for (; i < 10 ; ++i, f += .1) {
      s += i * f;
      int i;
    }
  }
  std::cout << s << "\n";
}
\end{lstlisting}

Float Zähler (counter) vermeiden.

\begin{lstlisting}[language=C++]
#include <iostream>
#include <cmath>

int main()
{
  int j{0};
  for (float x{0.}; x <= 1.; x += .01)
    std::cout << j++ << ":" << x << " ";
  std::cout << "\n";
  float start{0.}, end{1.}, inc{.01};
  long n{lround((end - start) / inc)};
  for (long i{0}; i <= n; ++i)
    std::cout << i << ":" << (start + (inc * i)) << " ";
  std::cout << "\n";
  for (long i{0}; i <= 100; ++i)  //Empfohlen
    std::cout << i << ":" << i/100.f << " ";
}
\end{lstlisting}

\subsubsection{range-for}

Schleife über einen Bereich (range).

\begin{lstlisting}[language=C++]
#include <iostream>
#include <vector>
#include <algorithm>
#include <ranges>

void o(const std::vector<int>& v, const char* s = {""}) {
  std::cout << s;
  for (const auto& i : v) std::cout << i << ' ';
  std::cout << "\n";
}

int main()
{
  std::vector<int> v = {2, 0, 1};

  // Index based. Geht nur bei sequential random access
  for (std::size_t i{0}; i < v.size(); ++i) ++v[i];
  o(v, "0: ");  // 3 1 2

  // Iterator based
  for (auto it{v.begin()}; it != v.end(); ++it) ++*it;
  o(v, "1: ");  // 4 2 3

  for (auto& e : v) ++e;  // Über Reference
  o(v, "2: ");  // 5 3 4

  for (auto e : v) ++e;  // Kopie
  o(v, "3: ");  // 5 3 4

  for (auto&& e : v) ++e; // forwarding reference
  o(v, "4: ");  // 6 4 5

  std::ranges::for_each(v, [](auto& e) { ++e; });
  o(v, "5: ");  // 7 5 6

  std::for_each(v.begin(), v.end(), [](auto& e) { ++e; });
  o(v, "6: ");  // 8 6 7

  for (int i{0}; const auto& e : v) // Mit init-statement
    std::cout << i++ << ':' << e << ' ';
  std::cout << '\n';

  for (const auto& [i, e] : std::views::enumerate(v))
    std::cout << i << ':' << e << ' ';
  std::cout << '\n';

  for (int i : {3, 1, 2}) std::cout << i; // braced-init-list
  std::cout << '\n';

  // Variable nicht verwendet
  for ([[maybe_unused]] int i : v) std::cout << 'X';
}
\end{lstlisting}

\subsubsection{while}

Führt eine Anweisung so lange aus, bis die Bedingung \lstinline|false| wird.
Geprüft wird \emph{vor} jeder Iteration.

\begin{lstlisting}[language=C++]
#include <iostream>

int main()
{
  int i{0};
  while (i < 3) ++i;
  std::cout << i << '\n';

  while (i < 9)
  {
    std::cout << i << '\n';
    i += 2;
  }

  char cstr[]{"Hallo"};
  i = {0};
  while (char c{cstr[i++]})
    std::cout << c;
}
\end{lstlisting}

\subsubsection{do-while}

Führt eine Anweisung so lange aus, bis die Bedingung \lstinline|false| wird.
Geprüft wird \emph{nach} jeder Iteration.

\begin{lstlisting}[language=C++]
#include <iostream>

int main()
{
  int i{0};
  do
  {
    i += 2;
    std::cout << i << '\n';
  }
  while (i < 9);
}
\end{lstlisting}

\subsection{Sprunganweisungen -- Jump}
\subsubsection{continue}

Überspringt den verbleibenden Teil des umschließenden \lstinline|for| oder
\lstinline|while| Schleifenkörpers.

\begin{lstlisting}[language=C++]
#include <iostream>

int main()
{
  for (int i{0}; i < 3; ++i)
  {
    for (int j{0}; j < 3; ++j)
    {
      if (j == 1) continue;  // wirkt bei j for loop
      std::cout << i << ' ' << j << '\n';
    }
  }
}
\end{lstlisting}

\subsubsection{break}

Beendet umschließendes \lstinline|for|, \lstinline|while| oder
\lstinline|switch|.

\begin{lstlisting}[language=C++]
  #include <iostream>

int main()
{
  for (int i{0}; i < 3; ++i)
  {
    for (int j{0}; j < 3; ++j)
    {
      if (j == 1) break;  // wirkt bei j for loop
      std::cout << i << ' ' << j << '\n';
    }
  }
}
\end{lstlisting}

\subsubsection{goto}

Setzt Programm an anderer Stelle fort.

\begin{lstlisting}[language=C++]
#include <iostream>

struct nt {  // non-trivial destructor
  ~nt() { std::cout << "X\n";}
};

int main()
{
  for (int i{0}; i < 3; ++i)
  {
    for (int j{0}; j < 3; ++j)
    {
      if (j == 1) goto endloop; // Ausstieg aus beiden for loops
      std::cout << i << ' ' << j << '\n';
    }
  }
endloop:  // Sprungmarke label
  goto label2; // Sprung in den scope von n
//int n{0};  //error: jump bypasses variable initialization
  [[maybe_unused]] int n; // no initializer
  n = {7};
//nt o;  // error: bypas variable with non-trivial destructor
label2:
  std::cout << n;  // n hat Zufallswert
}
\end{lstlisting}

\subsubsection{return}

Beendet Funktion und gibt Wert (falls vorhanden) an den Aufrufer zurück.

\begin{lstlisting}[language=C++]
#include <iostream>
#include <utility>

void fa(int i) {
  if (i == 1) return;
  std::cout << "fa("<< i << ")\n";
} // impliziertes return;

int fb(int i) {
  if (i > 4) return 4;
  std::cout << "fb(" << i << ")\n";
  return 2; }

std::pair<int, float> fc(int i, float x) {
  return {i, x}; }

int main()
{
  fa(0);  // Gibt fa(0) aus
  fa(1);  // Nichts
  int i{fb(5)};  // i == 4
  i = fb(i);     // gibt fb(4) aus, i == 2
  std::cout << fc(0, 1.).first << " " << fc(2, 3.).second; //0 3
}
\end{lstlisting}

\section{Ausdruck -- Expression}

Operatoren (z.\,B.\ +,-,*,/,\dots) führen etwas mit Operanden aus. Bei der
Auswertung (evaluation) kann ein Ergebnis (z.\,B.\ 4 bei \lstinline|2+2|) und
oder Nebenwirkungen (side-effects) (z.\,B.\ gibt
\lstinline|std::printf("\%d", 4)| 4 aus) entstehen.

\subsection{Wertkategorien -- Value categories}

\lstinline|lvalue = prvalue;|

\begin{description}
  \item[lvalue] Steht auf der linken Seite einer Zuweisung.
  \begin{itemize}
    \item Adresse eines Ausdrucks kann übernommen werden.
    \item Typ eines Ausdrucks ist eine L-Wert-Referenz (z.\,B.\ \lstinline|int&|
    oder \lstinline|const int&|)
  \end{itemize}
  \item[prvalue] Steht auf der rechten Seite einer Zuweisung. R-Werte
  entsprechen temporären Objekten, wie sie beispielsweise von Funktionen
  zurückgegeben oder durch implizite Typkonvertierungen erstellt werden. Die
  meisten Literale (z.\,B.\ \lstinline|7| oder \lstinline|7.8|) sind ebenfalls
  R-Werte.
  \item[xvalue] Verschwindende (expiring) lvalue.
  \item[glvalue] lvalue oder xvalue
  \item[rvalue] prvalue oder xvalue
\end{description}

\subsection{Operator}

Diese werden nach definierten Reihenfolgen und Richtungen evaluiert.

\begin{description}
  \item[assignment] \lstinline|a = b| :
    \lstinline"= += -= *= /= \%= \&= |= ^= <<= >>="
  \item[increment / decrement] \lstinline|++a --a a++ a--|
  \item[arithmetic]
    \lstinline|+a| \lstinline|-a| \lstinline|~a|;
    \lstinline|a + b| :
    \lstinline"+ - * / \% & | ^ << >>"
  \item[logical]
    \lstinline|!a|
    \lstinline|a && b|
    \lstinline"a || b"
  \item[comparison] \lstinline|a == b| :
    \lstinline|== != < > <= >= <=>|
  \item[member access] \lstinline|a[b] a[...] *a &a a->b a.b a->*b a.*b|
  \item[function call] \lstinline|a(a1, a2)|
  \item[comma] \lstinline|a, b|
  \item[conditional] \lstinline|a ? b : c|
  \item[Conversions] \lstinline|const_cast| \lstinline|static_cast|
    \lstinline|dynamic_cast| \lstinline|reinterpret_cast|
  \item[Memory allocation] \lstinline|new delete|
  \item[Other] \lstinline|sizeof alignof typeid throw-expression|
\end{description}

\subsection{Constant}
\label{sec:Ausdruck:constant}

\begin{description}
  \item[const] Kann nicht geändert werden.
  \item[constexpr] Wert \emph{kann} beim Kompilieren vorliegen.
  \item[consteval] Wert \emph{muss} beim Kompilieren vorliegen. Nur für Funktionen.
\end{description}

\begin{lstlisting}[language=C++]
#include <array>

int f0 ( int a, int b ) { return a + b; }
constexpr int f1 ( int a, int b ) { return a + b; }
consteval int f2 ( int a, int b ) { return a + b; }

int main() {
  int n{2};
//std::array<int, n> a0;  // Error: Argument not const expr
  const int cn{2};
  std::array<int, cn> a1;
  constexpr int cn2{2};
  std::array<int, cn2> a2;
//std::array<int, f0(1, 1)> a3; // Error: non-constexpr function
  std::array<int, f1(1, 1)> a4;
//std::array<int, f1(n, n)> a5; // Error: nicht const
  std::array<int, f1(cn, cn)> a6;
  f1(n, n);
//f2(n, n);  //Error: nicht constant
  f2(cn, cn);
  ++n;
//++cn;   // Error: declared const
//++cn2;  // Error: declared const
}
\end{lstlisting}

\subsection{Operator overloading}

Operatoren (z.\,B.\ +) für benutzerdefinierte Typen definieren. Overloaded operators sind Funktionen mit speziellen Funktionsnamen.

\begin{lstlisting}[language=C++]
#include <iostream>

struct Foo {
  int a;
  double b;
  Foo& operator++()  // prefix increment
  {
    ++a;
    ++b;
    return *this; // return new value by reference
  }
};

std::ostream& operator<<(std::ostream& out, Foo const& f) {
  return out << f.a << " " << f.b;
}

int main() {
  Foo x = {0, 1.5};
  std::cout << x << "\n";  // 0 1.5
  ++x;
  std::cout << x << "\n";  // 1 2.5
}
\end{lstlisting}

\subsection{Conversions}

\subsubsection{Implicit}

\begin{lstlisting}[language=C++]
  float f{ 0 };  // int nach float
  f = 1;         // int nach float
  if (2) {}      // int nach bool
//int i{0.};     // Error: float nach int narrowing conversion
  int i = 0.;    // float nach int
//i = { 1. };    // Error: float nach int narrowing conversion
  i = 1.;        // float nach int
\end{lstlisting}

\subsubsection{Explicit}

\begin{lstlisting}[language=C++]
int i;
i = 0.5;  // Implicit
i = (int) 1.5;
i = int(2.5);
//i = int{3.5};  // Error: narrowing conversion
i = auto(2.5);
i = auto{3.5};
\end{lstlisting}

\subsubsection{User-defined}

\begin{lstlisting}[language=C++]
#include <iostream>

struct foo {
  int i{2};
  // implicit conversion
  operator int() const { return 1; }
  // explicit conversion
  explicit operator int*() const { return const_cast<int*>(&i);}
};

int main() {
  foo x;
  int i = x;
  std::cout << i << ' ' << (int)x << ' ' << int(x) << ' ' <<
    int{x} << ' ' << static_cast<int>(x) << '\n';  // immer 1
//int* j = x;  // Error: no implicit conversion
  int* j = (int*)x;
  std::cout << *j << ' ' << *((int*)x) << ' ' <<
    *static_cast<int*>(x) << '\n';  // immer 2
}
\end{lstlisting}

\subsubsection{Usual arithmetic conversions}

\begin{lstlisting}[language=C++]
#include <iostream>
#include <typeinfo>

int main() {
  int i = 2;
  long l = 5l;
  auto n = i + l;
  std::cout << typeid(n).name() << '\n';  // l
  float x = 1.f;
  double y = 2.;
  auto z = x + y;
  std::cout << typeid(z).name() << '\n';  // d
}
\end{lstlisting}

\subsubsection{static\_cast}

\lstinline|static_cast<int>(2.)| macht das gleiche wie \lstinline|int(2.)| oder
\lstinline|(int)2.|, ist aber bei einer Suche leichter zu finden.

\begin{lstlisting}[language=C++]
long l = 5l;
//int i{l};  // narrowing conversion
int i{static_cast<int>(l)};
int j{int(l)};
int k{(int)l};
\end{lstlisting}

\subsubsection{dynamic\_cast}

Bei virtual Vererbung für Zeiger oder Referenz auf eine Klasse.

\begin{lstlisting}[language=C++]
#include <iostream>
struct Animal   { virtual ~Animal() = default; int i{0}; };
struct Creature { virtual ~Creature() = default;
                  int i{1}; int j{2}; };
struct Bird : public Animal, Creature { };

int main() {
  Bird *bird = new Bird();
  Creature *creature = dynamic_cast<Creature*>(bird);
  Animal *animal = dynamic_cast<Animal*>(creature);
  Creature *creature1 = new Creature();
//Bird *bird1 = dynamic_cast<Animal*>(creature1);  // invalid conversion
  Animal *animal1 = dynamic_cast<Animal*>(creature1);
//std::cout << bird->i << '\n';  // Error: ambiguous
  std::cout << bird->Animal::i << '\n';
  std::cout << bird->Creature::i << ' ' << bird->j << '\n';
  std::cout << creature->i << ' ' << creature->j << '\n';
  std::cout << animal->i /*<< ' ' << animal->j*/ << '\n';
  std::cout << creature1->i << ' ' << creature1->j << '\n';
//std::cout << animal1->i << '\n'; //Seg fault
  delete bird;
  delete creature1;
}
\end{lstlisting}

\subsubsection{const\_cast}
\label{sec:Conversion:constCast}

Erzeugt eine nicht konstante Referenz oder Zeiger auf ein konstantes Objekt, das
damit verändert werden kann und damit undefiniertes Verhalten verursachen kann.

\begin{lstlisting}[language=C++]
#include <iostream>

int main() {
  int i = 0;
  const int& rci = i;
//rci = 1;  /Error: read-only reference
  const_cast<int&>(rci) = 2;  // OK
  std::cout << i << ' ' << rci << '\n';  // 2 2

  const int j = 3;
  int* pj = const_cast<int*>(&j);
  *pj = 4;      // undefined behavior
  std::cout << j << ' ' << *pj << '\n';  // ? ?
}
\end{lstlisting}

\subsubsection{reinterpret\_cast}

Konvertiert zwischen Typen durch Neuinterpretation des zugrunde liegenden
Bitmusters.

\begin{lstlisting}[language=C++]
#include <iostream>

int main() {
  signed char i = -1;
  std::cout << +i << ' ' <<                       // -1
   +reinterpret_cast<unsigned char&>(i) << '\n';  // 255
}
\end{lstlisting}

\subsection{Literals}

Im Quellcode eingebettete konstante Werte.
\begin{description}
  \item[boolean] \lstinline|true|, \lstinline|false|
  \item[integer] ~
  \begin{description}
    \item[integer-suffix] ~
    \begin{description}
      \item[u U] Unsigned \lstinline|0u|
      \item[l L] Long \lstinline|0l|
      \item[ll LL] Long long \lstinline|0ll|
      \item[z Z] size \lstinline|std::size_t i{0uz};|
    \end{description}
    \item[decimal-literal] \lstinline|42|
    \item[octal-literal] \lstinline|052|
    \item[hex-literal] \lstinline|0x2a| \lstinline|0X2A|
    \item[binary-literal] \lstinline|0b101010| \lstinline|0B101010|
  \end{description}
  \item[floating] ~
  \begin{description}
    \item[3.1f] float
    \item[3.1] double
    \item[3.1l] long double
    \item[3.1f16] float16; f32, f64, f128, bf16
    \item[4e2] double
    \item[3.14'15'92] double, single quotes ignored
  \end{description}
  \item[character] ~
  \begin{description}
    \item['c'] Gewöhnliches Zeichenliteral
    \item[u8'c'] UTF8
    \item[u'c'] UTF16
    \item[U'c'] UTF32
    \item[L'c'] Wide character
    \item['char'] Literal mit mehreren Zeichen
  \end{description}
  \item[string] ~
  \begin{description}
    \item[\dq\dq] Gewöhnliches Stringliteral
    \item[\dq{}abc\dq] Gewöhnliches Stringliteral
    \item[R\dq{}(abc)\dq] Raw string literals
    \item[R\dq{}any(abc)any\dq] Raw string literals
    \item[u8\dq{}abc\dq] UTF8
    \item[u\dq{}abc\dq] UTF16
    \item[U\dq{}abc\dq] UFT32
    \item[L\dq{}abc\dq] Wide
  \end{description}
  \item[Escape sequences] Für spezielle Zeichen
  \begin{description}
    \item[\textbackslash{}'] single quote
    \item[\textbackslash{}"] double quote
    \item[\textbackslash{}?] question mark
    \item[\textbackslash{}\textbackslash{}] backslash
    \item[\textbackslash{}a] audible bell
    \item[\textbackslash{}b] backspace
    \item[\textbackslash{}f] form feed - new page
    \item[\textbackslash{}n] line feed - new line
    \item[\textbackslash{}r] carriage return
    \item[\textbackslash{}t] horizontal tab
    \item[\textbackslash{}v] vertical tab
    \item[\textbackslash{}nnn] Octal code 1-3 stellig
    \item[\textbackslash{}o\{n\dots\}] Octal code
    \item[\textbackslash{}xn\dots] Hex Code
    \item[\textbackslash{}x\{n\dots\}] Hex Code
    \item[\textbackslash{}unnnn] Unicode Wert 4 stellig
    \item[\textbackslash{}Unnnnnnnn] Unicode Wert 8 stellig
    \item[\textbackslash{}u\{n\dots\}] Unicode Wert
    \item[\textbackslash{}N\{Name\}] Unicode Name
    \item[\textbackslash{}c] Conditional escape sequence
  \end{description}
  \item[nullptr] Nullpointer literal
  \item[user-defined] Literals können auch selber definiert werden
\end{description}

\section{Deklaration}

\begin{description}
  \item[Deklaration] Bekanntgabe von Namen
  \item[Definition] Deklaration die ausreicht um sie verwenden zu können
\end{description}

\begin{lstlisting}[language=C++]
int f(int); // deklariert Funktion f, aber definiert sie nicht
int g(int x) {  // definert Funktion g
  return x + 1;
}
\end{lstlisting}

Eine Deklaration kann keine bereits bestehende Deklaration im selben Namensraum
(Namepace) überschreiben (Conflicting declarations).

\begin{lstlisting}[language=C++]
int i;
//int i; // Error:  redeclaration
{
  int i;  // OK: Im Block
}
int f(float x);
int f(int x);   // OK Function Overloading
\end{lstlisting}

\subsection{Storage class specifiers}

\begin{description}
  \item[~] Nichts: automatische Speicherdauer. Dauer: Vom Beginn bis zum Ende des Blocks.
  \item[static] Nur bei Deklaration von Objekten, Funktionen oder anonymen
  unions. Greift bei jeder Instanz auf die gleiche Variable zurück. Dauer: Vom Beginn bis zum Ende des Programms.

\begin{lstlisting}[language=C++]
#include <iostream>

class A {
  static int N;
  public:
  A() { ++N; }
  int n() {return N;}
};
int A::N{0};  // Initialisierung von static N

int main() {
  A x;
  std::cout << x.n() << '\n';  // 1
  A y;
  std::cout << x.n() << ' ' << y.n() << '\n';  // 2 2
}
\end{lstlisting}

  \item[extern] Für Zugriff auf variablen oder Funktionen, die in anderen souce-Dateien definiert sind.

\begin{lstlisting}[language=C++]
//Datei1
int a{1};
const int b{2};  // Gilt nur in Datei1
extern const int c{3};
\end{lstlisting}
\begin{lstlisting}[language=C++]
//Datei2
#include <iostream>
extern int a;
extern const int b;  // Kommt nicht von Datei1
extern const int c;

int main() {
  std::cout << a << '\n';  // 1
//std::cout << b << '\n';  // undefined reference to `b'
  std::cout << c << '\n';  // 3
}
\end{lstlisting}

  \item[thread\_local] Jeder thread hat eine eigen Kopie der Variable. Dauer: Vom Beginn bis zum Ende des threads.
  \item[mutable] Erlaubt die Veränderung eines Klassenmitglieds, wenn das Objekt als const deklariert ist.
\end{description}

\subsection{Translation-unit-local}

Verhindert, dass lokale Instanzen in anderen Dateien verwendet werden

\begin{lstlisting}[language=C++]
//Datei1
int a{1};  // Kann mit extern in anderem Source verwendet werden
static int b{2};  // Lokal verfügbar
namespace {
  int c{3};      // Lokal verfügbar
}
\end{lstlisting}
\begin{lstlisting}[language=C++]
//Datei2
#include <iostream>
extern int a;
extern int b;  // Kommt nicht von Datei1
extern int c;  // Kommt nicht von Datei1

int main() {
  std::cout << a << '\n';  // 1
//std::cout << b << '\n';  // undefined reference to `b'
//std::cout << c << '\n';  // undefined reference to `c'
}
\end{lstlisting}

\subsection{Language linkage}

\lstinline|extern| zur Verknüpfung von Funktionen, die in einer anderen
Programmiersprache geschrieben wurden.

\begin{lstlisting}[language=fortran]
! Fortran compiliert z.B.: gfortran -c fortran.f90
integer FUNCTION fun1(i,j)
    fun1 = i + j
END FUNCTION fun1

MODULE fort
contains
integer FUNCTION fun2(i,j)
    fun2 = i - j
END FUNCTION fun2
END MODULE fort
\end{lstlisting}

\begin{lstlisting}[language=C++]
// C++ compiliert z.B.: g++ c.cc fortran.o
#include <iostream>

extern"C" {
  int fun1_(int*, int*);
  int __fort_MOD_fun2(int*, int*);
}

int main() {
  int i{1};
  std::cout << fun1_(&i, &i) << ' ' <<  // 2
    __fort_MOD_fun2(&i, &i) << '\n';    // 0
}
\end{lstlisting}

\subsection{Namespace declaration}

Zur Vermeidung von Namenskonflikten.
Bezeichner im Unnamed namespace sind nur in der Übersetzungseinheit sichtbar.

\begin{lstlisting}[language=C++]
#include <iostream>

int i{0};  // global namespace
int j{1};

namespace {  // Unnamed namespace
  int i{2};  // Nicht erreichbar wegen globalem i
  int k{3};
}

namespace A {
  int i{4};
  int n{12};
  namespace B {
    int i{5};
    extern int j;
    extern int k;
  }
//int B::i{6};  // Error: Redefinition von i
  int B::j{7};
//int B::l{8};  // Error: B::l nicht deklariert
  inline namespace C {  // In C und A
    int m{9};
    int n{13};  // Verdeck A::n
  }
  namespace {  // In A
    int o{14};
  }
}
namespace D {
//int A::B::k{10};  // Error: Does not enclose B
}
int A::B::k{11};

namespace A::B {  // nested namespace definition
  int p{15};
}

namespace A::inline D {
  int q{16};
}

namespace X = A::B;  // Namespace alias

int main() {
//std::cout << i << '\n';  // ambiguous
  std::cout << ::i << '\n';  // 0
  std::cout << j << ' ' << ::j << '\n';  // 1 1
  std::cout << k << ' ' << ::k << '\n';  // 3 3
  std::cout << A::i << ' ' << ::A::i << '\n';  // 4 4
  std::cout << A::B::i << '\n';  // 5
  std::cout << A::B::j << '\n';  // 7
  std::cout << A::B::k << '\n';  // 11
  std::cout << A::m << ' ' << A::C::m << '\n';  // 9 9
//std::cout << A::n << '\n';  // ambiguous
  std::cout << A::C::n << '\n';  // 13
  std::cout << A::o << '\n';  // 14
  std::cout << A::B::p << '\n';  // 15
  std::cout << A::q << ' ' << A::D::q << '\n';  // 16 16
  std::cout <<X::i <<' ' <<X::j <<' ' <<X::k <<'\n'; // 5 7 11
}
\end{lstlisting}

Mit \lstinline|using| können Inhalte von Namensräume sichtbar gemacht werden. In
Header Dateien \lstinline|using namespace| vermeiden, da jeder der den Heder
verwendet auch diesen namespace mitverwendet.

\begin{lstlisting}[language=C++]
#include <iostream>

int i{0};

namespace A {
  int i{1};
  int j{2};
}

namespace B {
  int i{3};
  int k{4};
}

namespace C {
//using ::i, A::i;  // Error: Name conflict
  using ::i, A::j; // Werden in C sichtbar
}

int main() {
  using namespace A;
  using namespace B;
//std::cout << i << '\n';  // ambiguous
  std::cout << A::i << ' ' << B::i << '\n';  // 1 3
  std::cout << j << ' ' << k << '\n';  // 2 4
  std::cout << C::i << ' ' << C::j << '\n';  // 0 2
}
\end{lstlisting}

\subsection{References}

Mit \lstinline|&| (lvalue) bzw.\ \lstinline|&&| (rvalue) wird ein zusätzlicher
Namen für ein bereits vorhandenes Objekt vergeben.

\begin{lstlisting}[language=C++]
#include <iostream>

void add(int& x) { ++x; }  // Direkt Zugriff auf übergebenes x
int& set(int& x) { return x; }  // lvalue expression
int& bad() {  // Dangling reference
  int i{0};
  return i;  // return reference to local variable
}  // Aufruf Destruktor von i

int main() {
  int i{0};
  int& r = i;
  const int& cr = i;
  ++r;
  std::cout << i << '\n';  // 1
//++cr;  // Error: cr ist const
  add(i);
  std::cout << i << '\n';  // 2
  add(r);
  std::cout << i << ' ' << r << ' ' << cr << '\n';  // 3 3 3
  set(i) = 5;
  std::cout << i << '\n';  // 5

//int&& r1 = i;  // Error: can't bind to lvalue
  int&& r2 = i + 0;
  std::cout << i << ' ' << r2 << '\n';  // 5 5
  r2 += 5;
  std::cout << i << ' ' << r2 << '\n';  // 5 10
  i += 5;
  std::cout << i << ' ' << r2 << '\n';  // 10 10

  int& j = bad();
//std::cout << j << '\n';  // Undef. bis Seg. fault
}
\end{lstlisting}

\subsection{Pointer -- Zeiger}

Zeiger enthalten üblicherweise die Anfangsadresse eines Objekts. Bei der
Deklaration wird \lstinline|*| verwendet. Die Adresse eines Objekts erhält man
durch voranstellen von \lstinline|&| vor dem Namen. Zeiger werden mit
\lstinline|*| vor dem Zeigernamen dereferenziert um auf deren Inhalt und nicht
auf ihre Adresse zuzugreifen. Bei Zeiger auf Klassen kan mit \lstinline|->| auf
Klassenelemente zugegriffen werden.

\begin{lstlisting}[language=C++]
#include <iostream>
#include <iterator>
#include <ranges>

float f0(const int& i) {return i + .5;}
float f1(const int& i) {return i - .5;}

int main() {
  int i{0};
  int* p{&i};  // Pointer auf i
  int& r{i};   // Referenz auf i
//int&* pr;  // Error: Pointer auf Referenz
  int& rd{*p};  // Referenz auf dereferenzierten Pointer
  int*& rp{p};  // Referenz auf Pointer
  std::cout << i << ' ' << *p << ' ' << r << ' ' << rd
            << ' ' << *rp << '\n';  // 0 0 0 0 0

  int j{0};
  const int* q{&i};  // Kann i nicht verändern
//++*q;
  q = &j;
  int const* q2{&i};  // Kann i nicht verändern
//++*q2;
  q2 = &j;
  int* const s{&i};  // Kann die Pointeradresse nicht verändern
  ++*s;
//s = &j;
  const int* const t{&i};
//++*t;
//t = &j;
  int const* const t2{&i};
//++*t2;
//t2 = &j;
  int** pp{&p};  // Pointer auf Pointer
  int* const* cp{&p}; // Const P. auf P.
  std::cout << **pp << ' ' << **cp << '\n'; // 1 1

  p = nullptr;  // Empfohlen Null Pointer
  p = NULL;
  p = 0;

  int a[]{0,1};  // Array
  std::cout << a[0] << ' ' << a[1] << '\n';  // 0 1
  int (*ap)[2]{&a};  // Pointer auf Array
  std::cout << (*ap)[0] << ' ' << (*ap)[1] << '\n';  // 0 1
  int (*ap2)[std::size(a)]{&a};
  std::cout << (*ap2)[0] << ' ' << (*ap2)[1] << '\n';  // 0 1
  int (*ap3)[std::ranges::size(a)]{&a};
  std::cout << (*ap3)[0] << ' ' << (*ap3)[1] << '\n';  // 0 1
  int* a0{a};  // int Pointer auf erstes Element
  std::cout << a0[0] << ' ' << a0[1] << '\n';  // 0 1
  std::cout << *a0 << ' ' << *(a0+1) << '\n';  // 0 1

  void* pv{&i};  // Void kann auf alles Zeigen
  std::cout << i << ' ' << *static_cast<int*>(pv) << '\n';  // 1 1

  float (*pf0)(const int&){&f0};
  float (*pf1)(const int&){f1};  // Implizite Umwandlung in &f1
  float (*af[2])(const int&);  // Pointer zu Funktion Array
  af[0] = &f0;
  af[1] = &f1;
  using F = float(const int&);  // named type alias
  F* af2[]{f0, f1};              // vereinfacht Deklaration
  std::cout << f0(1) << ' ' << f1(1) << '\n';  // 1.5 0.5
  std::cout << pf0(1) << ' ' << (*pf1)(1) << '\n';  // 1.5 0.5
  std::cout << af[0](1) << ' ' << af[1](1) << '\n';  // 1.5 0.5
  std::cout << af2[0](1) << ' ' << af2[1](1) << '\n';  // 1.5 0.5

  struct K { int m; };
  int K::* pK{&K::m};          // Pointer auf m der Klasse K
  K k{7};
  std::cout << k.m << ' ' << k.*pK << '\n';   // 7 7
  K* kp{&k};
  kp->m = 10;
  std::cout << k.m << ' ' << kp->m << ' ' << (*kp).m <<
     ' ' << kp->*pK << '\n'; // 10 10 10 10

  struct Base { int m; };
  struct Derived : Base { int n; };
  Derived d;
  d.m = 1;
  int Base::* bpm = &Base::m;
  int Derived::* dpm = bpm;
  std::cout << d.*dpm << ' ' << d.*bpm << '\n';  // 1 1
  Base* bp{&d};  // implicit conversion
  std::cout << bp->m << ' ' << (*bp).m << '\n';  // 1 1
  std::cout << (*bp).*bpm << ' ' << bp->*bpm << '\n';  // 1 1
  d.n = 7;
  int Derived::* dpn = &Derived::n;
  int Base::* bpn = static_cast<int Base::*>(dpn);
  std::cout << d.*bpn << '\n';  // 7
  std::cout << bp->*bpn << '\n';  // 7
  Base B;
//std::cout << B.*bpn << '\n';  // Undefined

  struct E { void f(int n) { std::cout << n << '\n'; } };
  void (E::* pf)(int) = &E::f; // Pointer auf Funktion f in E
  E e;
  e.f(4);  // 4
  (e.*pf)(5);  // 5
  E* ep{&e};
  (ep->*pf)(6);  // 6
}
\end{lstlisting}

\subsection{Arrays}

Arrays (Felder) beinhalten mehrere Elemente des gleichen Typs. Bei bekannter
Größe wird \lstinline|std::array| empfohlen. \lstinline|std::vector| wenn Größe
verändert werden soll. \lstinline|std::valarray| bietet einfache
Rechenoperatoren für alle Elemente.

\begin{lstlisting}[language=C++]
#include <iostream>
#include <span>
#include <array>
#include <vector>
#include <valarray>

int main() {
  int a[2];  // Array mit 2 Elementen uninitialisiert
  std::cout << a[0] << ' ' << a[1] << '\n';  // ? ?
  std::fill_n(a, std::size(a), 7);  // Alle auf 7 setzen
  std::cout << a[0] << ' ' << a[1] << '\n';  // 7 7
  int b[2]{};  // Array mit 2 Elementen default initialisiert
  std::cout << b[0] << ' ' << b[1] << '\n';  // 0 0
  int c[]{3,4}; // 2 Elemente mit 3 4 initialisiert
  std::cout << c[0] << ' ' << c[1] << '\n';  // 3 4
  for (const int& i : c) std::cout << i << '\n';  // 3 4
  int d[2]{3};  // 2 Elemente mit 3 0 initialisiert
  std::cout << d[0] << ' ' << d[1] << '\n';  // 3 0

  int* p{c};  // Pointer auf erstes Element
  std::cout << p[0] << ' ' << p[1] << '\n';  // 3 4
// Error: no viable 'begin'
//for (const int& i : p) std::cout << i << '\n';
  int (*ap)[2]{&c};  // Pointer auf Array
  std::cout << (*ap)[0] << ' ' << (*ap)[1] << '\n';  // 3 4
  for (const int& i : *ap) std::cout << i << '\n';  // 3 4
  int (&r)[] = c;  // Referenz
  std::cout << r[0] << ' ' << r[1] << '\n';  // 3 4
// Error: incomplete type 'int[]'
//for (const int& i : r) std::cout << i << '\n';
  int (&s)[2] = c;  // Referenz
  for (const int& i : s) std::cout << i << '\n';  // 3 4

  int e[2][3]{{1,2,3},{4,5,6}};  // 2*3 Array
  std::cout << e[0][0] << e[0][1] << e[0][2] <<
               e[1][0] << e[1][1] << e[1][2] << '\n';  // 123456
  int* q{*e};  // Pointer Auf erstes Element
  std::cout << q[0] << q[1] << q[2] << q[3] <<
               q[4] << q[5] << '\n';  // 123456

  int* g{new int[2]};//Dynamisch erzeugtes Array uninitialisiert
  delete[] g;  // Speicher freigeben wenn nicht mehr benötigt
  int* h{new int[2]{}};  // Default 0 initialisiert
  std::cout << h[0] << ' ' << h[1] << '\n';  // 0 0
  delete[] h;
  int* j{new int[]{7,8}};  // 7, 8 initialisiert
  std::cout << j[0] << ' ' << j[1] << '\n';  // 7 8
// Error: no viable 'begin'
//for (const int& i : j) std::cout << i << '\n';
  delete[] j;
  int (*k)[2]{reinterpret_cast<int (*)[2]>(new int[2]{})};
  for (const int& i : *k) {std::cout << i << '\n';}  // 0 0
  delete[] k;
  std::span<int> l = std::span<int>(new int[2]{}, 2);
  std::cout << l[0] << ' ' << l[1] << '\n';  // 0 0
  for (const int& i : l) {std::cout << i << '\n';}  // 0 0
  delete[] l.data();

  std::array<int, 2> m{};  // Default 0 initialisiert
  std::cout << m[0] << ' ' << m[1] << '\n';  // 0 0
  for (const int& i : m) {std::cout << i << '\n';}  // 0 0
  std::array<int, 2> m1;  // Uninitialisiert
  m1.fill(8);  // Alle auf 8 setzen
  std::array<int, 2> m2{4,7};  // 4 7 initialisiert

  std::vector<int> v(2);  // default 0 initialisiert
  std::cout << v[0] << ' ' << v[1] << '\n';  // 0 0
  for (const int& i : v) std::cout << i << '\n';  // 0 0
  std::vector<int> v1(2, 5);  // 5 initialisiert

  std::valarray<int> w(2);  // default 0 initialisiert
  std::cout << w[0] << ' ' << w[1] << '\n';  // 0 0
  for (const int& i : w) std::cout << i << '\n';  // 0 0
  std::valarray<int> w1(7, 2);  // 7 initialisiert
}
\end{lstlisting}

Wenn die Größe das Arrays zur Kompilierungszeit nicht bekannt ist, bieten sich
folgende Möglichkeiten an, das Array zu erzeugen. Für uninitialisierte Arrays
zeigt die Variante \lstinline|new| mit \lstinline|span| Vorteile.

\begin{lstlisting}[language=C++]
#include <iostream>
#include <array>
#include <vector>
#include <span>
#include <valarray>
#include <memory>

int main() {
  std::size_t n;
  std::cin >> n;
//int a[n];  // C99 feature: variable length arrays

  int* p{new int[n]};  // uninitialisiert
  std::cout << p[0] << '\n';
// Error: no viable 'begin' function
//for (int i : p) std::cout << i << '\n';
  delete[] p;

  int* p1{new int[n]{}};  // default 0 initialisiert

// C99 feature: variable length arrays
//int (*q)[n]{reinterpret_cast<int (*)[n]>(new int[n])};
//std::cout << (*q)[0] << '\n';
//for (const int& i : *q) {std::cout << i << '\n';}
//delete[] q;

  std::span<int> e = std::span<int>(new int[n], n);
  std::cout << e[0] << '\n';
  for (const int& i : e) {std::cout << i << '\n';}
  delete[] e.data();

  std::unique_ptr<int[]> f = std::make_unique_for_overwrite<int[]>(n);
  std::span<int> g = std::span<int>(f.get(), n);
  for (const int& i : g) {std::cout << i << '\n';}

// Error: argument is not a constant expression
//std::array<int, n> b;

  std::vector<int> v(n);  // default 0 initialisiert
  std::cout << v[0] << '\n';
  for (const int& i : v) std::cout << i << '\n';
  std::vector<int> v1(n, 5);  // 5 initialisiert

  std::valarray<int> w(n);  // default 0 initialisiert
  std::cout << w[0] << '\n';
  for (const int& i : w) std::cout << i << '\n';
  std::valarray<int> w1(7, n);  // 7 initialisiert
}
\end{lstlisting}

\subsection{Structured bindings}

Zugriff auf Strukturelemente mittels selbst vergebener Namen.

\begin{lstlisting}[language=C++]
#include <iostream>

int main() {
  int a[2]{1, 2};

  auto [x, y] = a;  // Kopie
  ++x; ++y;
  std::cout << a[0] << a[1] << ' ' << x << y << '\n';  // 12 23

  auto& [xr, yr] = a;  // Referenz
  ++a[0]; ++yr;
  std::cout << a[0] << a[1] << ' ' << xr << yr << '\n'; //23 23

  const auto& [cxr, cyr] = a;  // Const Referenz
  ++a[0];
//++cyr;  // Error: const
  std::cout << a[0] << a[1] << ' ' << cxr << cyr << '\n';//33 33
}
\end{lstlisting}

\subsection{Aufzählung -- Enumerations und enumerators}

\begin{lstlisting}[language=C++]
#include <iostream>

enum Color1 { red, blue };
//enum Color2 { red };  // Error: Redefiniotion von red

// Typsicher, keine implizite Umwandlung möglich
enum class Color3 { red, blue };

enum Foo { a, b, c = 10, d, e = 1, f, g = f + c };
//a = 0, b = 1, c = 10, d = 11, e = 1, f = 2, g = 12

// Mit Typangabe
enum class byte : unsigned char { a, b, c };

int main() {
  Color1 x = red;
  std::cout << x << '\n';  // 0
//Color3 y = red;  // Error: red ist type Color1
  Color3 z = Color3::red;
//std::cout << z << '\n';  // Error: Keine Methode
  std::cout << static_cast<int>(z) << '\n';  // 0
}
\end{lstlisting}

\subsection{inline}

Hat die Bedeutung: Mehrfachdefinitionen sind zulässig. Wenn Funktionen im header
definiert sind. Für Variable mit externer Verknüpfung.

\begin{lstlisting}[language=C++]
// example.h
#ifndef EXAMPLE_H
#define EXAMPLE_H

inline int sum(int a, int b) {
  return a + b;
}

inline std::atomic<int> counter(0);

#endif
\end{lstlisting}

\begin{lstlisting}[language=C++]
// Source 1
#include "example.h"

int a() {
  ++counter;
  return sum(1, 2);
}
\end{lstlisting}

\begin{lstlisting}[language=C++]
// Source 2
#include "example.h"

int b() {
  ++counter;
  return sum(3, 4);
}
\end{lstlisting}

\subsection{Inline assembly}

Mit \lstinline|asm| kann Assembler--Quellcode in einem \cpp{}--Programm
geschrieben werden.

\subsection{const, mutable und volatile}

Siehe \nameref{sec:Conversion:constCast} und \nameref{sec:Ausdruck:constant}.

\begin{description}
  \item[const] Wert kann nicht geändert werden.
  \item[mutable] Erlaubt die Veränderung eines Klassenmitglieds in einem const Objekt.
  \item[volatile] Kann von aussen abgefragt und verändert werden. Schränkt Optimierung ein.
\end{description}

\begin{lstlisting}[language=C++]
int main() {
  int n1 = 0;          // non-const object
  const int n2 = 0;    // const object
  int const n3 = 0;    // const object wie n2
  volatile int n4 = 0; // volatile object

  const struct {
    int n1;
    mutable int n2;
  } x = {0, 0};        // const object mit mutable

  n1 = 1;   // OK
//n2 = 2;   // error: const
  n4 = 3; n4 = 4;  // Wird nicht optimiert als nur n4=4;
//x.n1 = 4; // error: member of a const object is const
  x.n2 = 4; // OK: mutable member of a const object isn't const
}
\end{lstlisting}

\subsection{constexpr}

Siehe \nameref{sec:Ausdruck:constant}. Wert liegt bei Kompilierzeit vor bzw.\
Funktionsaufruf \emph{kann}, muss aber nicht, eine Konstante zur
Kompilierungszeit erzeugen.

\subsection{consteval}

Siehe \nameref{sec:Ausdruck:constant}. Funktionsaufruf \emph{muss} eine Konstante zur Kompilierungszeit erzeugen.

\subsection{constinit}

Variable wird beim compilieren initialisiert, und nicht erst bei Ausführen wenn
es über die Deklaration läuft.

\begin{lstlisting}[language=C++]
constinit int i{0};
constinit const int j{0};

int main() {
  ++i;
//++j;  // Error: Const
}
\end{lstlisting}

\subsection{decltype}

Ermittelt den Typ einer Deklaration.

\begin{lstlisting}[language=C++]
#include <iostream>

int main() {
  int i{7};
  decltype(i) j{i + 0};   // int : Kopie von i + 0
//decltype((i)) k{i + 0}; // Error: braucht lvalue
  decltype((i)) k{i};     // int& : Referenz auf i;
  ++i;
  std::cout << i << ' ' << j << ' ' << k <<'\n';  // 8 7 8
  ++j;
  std::cout << i << ' ' << j << ' ' << k <<'\n';  // 8 8 8
  ++k;
  std::cout << i << ' ' << j << ' ' << k <<'\n';  // 9 8 9
}
\end{lstlisting}

\subsection{auto}

Typ (int, double, \dots) wird automatisch abgeleitet.

\begin{lstlisting}[language=C++]
#include <iostream>
#include <typeinfo>

int main() {
  auto i{7};  // int
  std::cout << typeid(i).name() << '\n';  // int

  auto c0{i};  // int, Kopie von i
  auto& c1{i};  // int&, Referenz auf i

  decltype(auto) c2{i};   // int, Kopie von i
  decltype(auto) c3{(i)};  // int&, Referenz auf i

//auto a[]{1, 2};  // Error: Geht nur mit einem Element
  int a[]{1, 2};
  auto [x, y]{a};  // Kopie: x=a[0]; y=a[1];
  auto& [xr, yr]{a};  // Referenz
}
\end{lstlisting}

\subsection{typedef}

Alias für einen (komplexen) Typnamen.

\begin{lstlisting}[language=C++]
typedef unsigned long ul;
unsigned long l1; // unsigned long
ul l2;            // unsigned long
\end{lstlisting}

\subsection{Type alias}

Alias für einen bereits definierten Typ.

\begin{lstlisting}[language=C++]
template<class T>  // alias template
using ptr = T*;  // 'ptr<T>' als alias für T*
ptr<int> x;  // int* x

int main() {
  float (*af[2])(const int&);  // Pointer zu Funktion Array
  using F = float(const int&);  // named type alias
  F* af2[2];  // Das gleiche wie af
}
\end{lstlisting}

\subsection{Elaborated type specifiers}

Werden verwendet, um auf einen zuvor deklarierten Klassennamen zu verweisen,
selbst wenn diser verdeckt wurde, oder um einen neunen Klassennamen zu
deklarieren.

\begin{lstlisting}[language=C++]
struct X { int y; };

int main() {
  int X;  // verdeckt Klasse X
//X z;    // Error: Verwendet Variable X
  class X z;
}
\end{lstlisting}

\subsection{Attributes}

Geben Hinweise.

\begin{lstlisting}[language=C++]
#include <iostream>

// Kehrt nicht zu aufrufender Funktion zurück
[[noreturn]] void f0() { throw "error"; }

[[deprecated]] int f1() {return 1;}
[[deprecated("Use f0 instead")]] int f2() {return 2;}

[[nodiscard]] int f3() {return 1;}

int f4(int n) {
  int i;
  switch (n) {
    case 1: [[fallthrough]];  // Keine Warnung
    case 2: i=1; break;
    default: i=0;
  }
  return i;
}

int f5(int i) {
  if (i < 1) [[likely]]  // Hilft beim Optimieren
    return 0;
  else [[unlikely]]
    return 1;
}

int f6(int x, int y) {
    [[assume(y == 1)]];  // Wenn y!=1 Ergebnis undefiniert
    return x / y;
}

int main() {
  f1();  // Warnung depreciated beim compilieren
  f2();  // Warnung depreciated beim compilieren

  f3();  // Warnung das Rückgabewert nicht verwendet
  int i;
  i = f3();

  // Verhindert Warnung wenn nicht verwendet
  [[maybe_unused]] int j{0};

  std::cout << f6(4, 2) << '\n';
}
\end{lstlisting}

\subsection{alignas}

Gibt die Bytegrenzen eines Types an.

\begin{lstlisting}[language=C++]
#include <iostream>

struct alignas(32) Bar {  // Angereiht alle 32 byte
  int i;       // 4 bytes
  alignas(16) char arr[5];  // Angereiht alle 16 byte
  short s;     // 2 bytes
};

int main() {
  Bar x;
  std::cout << alignof(Bar) << std::endl;    // 32
  std::cout << sizeof(Bar) << std::endl;     // 32
  std::cout << x.arr - (char*)&x.i << '\n';  // 16
  std::cout << (char*)&x.s - x.arr << '\n';  // 6
}
\end{lstlisting}

\subsection{static\_assert}

Überprüfung von Annahmen wärend der Compilierung.

\begin{lstlisting}[language=C++]
int main() {
  const int x{3};
//static_assert(x / 2 > 1); // error: static assertion failed
  static_assert(x / 2 > 0, "x/2 > 0?");
  static_assert(sizeof(int) == 4, "Int ist nicht 4 Byte");
}
\end{lstlisting}


\section{Initialisation}

Setzt Anfangswert beim Erstellen.

\begin{lstlisting}[language=C++]
#include <string>

struct T1 { int i; };  // implicit default constructor
struct T2 {
    int i;
    T2() {}; // default Constructor
};
struct T3 {
  int x;
  struct T4 {
    int i;
    int j;
    int a[3];
  } b;
};

int main() {
// Default-initialization - Objekt erzeugt ohne Initializer
  int i;  // hier Wert unbestimmt
  int* a{new int[3]};  // Array, Werte unbestimmt
  delete[] a;
//const int j;  // Error: uninitialized const
//const T1 t1;  // Error: kein default constructor
  const T2 t2;  // t2.i unbestimmt
//int& r;  // Error: uninitialized Referenz

// Value-initialization - Objekt erzeugt mit leerem Initializer
  int j{};  // j == 0
  int k = int();    // k == 0
//int f();  // Würde die Funktion f deklarieren
  int* a2{new int[3]()};  // Array, Werte 0
  delete[] a2;
  const T1 t3{};  // t3.i == 0
  T2 t4{};  // t4.i ist undefiniert

// Copy-initialization
  int i1 = 3;  // Copy elision - wird direkt initialisiert
  int i2 = 3.14;  // Double nach Int
//int i2n = {3.14};  // Error: narrowing conversion

// Direct-initialization
  int i3(3);
  int i4(3.14);  // Double nach Int
  int i5{3};
//int i6{3.14};  // Error: narrowing conversion

// Aggregate initialization - für Aggregate (ohne Constructor)
  T3 s1 = {1, {2, 3, {4, 5, 6}}};
  T3 s2 = {1, 2, 3, 4, 5, 6};  // Das Gleiche nur ohne Klammern
  T3 s3{1, {2, 3, {4, 5, 6}}}; // direct-list-initialization
  T3 s4{1, 2, 3, 4, 5, 6};
  // Designated initializers, Nur in dieser Reihenfolge
  T3 s5{.x{1}, .b{.i{2}, .j{3}, .a{4, 5, 6}}};
  T3 s6{1};  // alle Restlichen sind 0
  int ar[] = {1, 2, 3};

// List-initialization - für Objekte
  int n1{1}; // direct-list-initialization
  // initializer-list constructor call
  std::string s7{'a', 'b', 'c', 'd'};

// Reference initialization
  double d{2.};
  double& rd{d};  // Referenz auf d, Direct binding
//double& rd2{2.};  // Error: Ref. auf rvalue
  const double& rd2{2.}; // Indirect binding auf temporären Wert
  double&& rd3{2.};  // rvalue Referenz
}
\end{lstlisting}

\section{Funktionen}

Fasst Anweisungen (mit Funktionsparametern) zusammen.

\begin{lstlisting}[language=C++]
#include <iostream>

// Function name:  "f"
// Parameter list: nothing
// Returns:        nothing
// Description:    Writes "Hi" to the terminal
void f()  // void..Rückgabewert, f..Funktionsname, ()..Argumente
{  // Beginn des Funktionskörpers
  std::cout << "Hi" << '\n';
}  // Ende  des Funktionskörpers

int main() {
  f();  // Aufruf von Funktion f
}
\end{lstlisting}

Wie Variblen müssen auch Funktionen \emph{vor} ihrere Verwendung deklariert
werden.

\begin{lstlisting}[language=C++]
#include <iostream>

int main() {
//f();  //Error: f ist nicht deklariert
}

void f() { std::cout << "Hi" << '\n'; }
\end{lstlisting}

\begin{lstlisting}[language=C++]
#include <iostream>

// Deklaration und Definition
void f() { std::cout << "Hi" << '\n'; }

int main() {
  f();
}
\end{lstlisting}

\begin{lstlisting}[language=C++]
#include <iostream>

// Deklaration
void f();

int main() {
  f();
}

// Definition
void f() { std::cout << "Hi" << '\n'; }
\end{lstlisting}

\subsection{Overloading}

Verschiedene Funktionen mit gleichem Namen sind erlaubt, solange deren Parameter
verschieden sind (function overloading).

\begin{lstlisting}[language=C++]
#include <iostream>

void f() { std::cout << "A" << '\n'; }
void f(int i) { std::cout << "B" << '\n'; }
void f(double i) { std::cout << "C" << '\n'; }
// Error: Unterscheidet sich nur im Rückgabewert
//int f() { std::cout << "D" << '\n'; return 0;}

int main() {
  f();    // A
  f(0);   // B
  f(0.);  // C
}
\end{lstlisting}

\subsection{Übergabe von Funktionen}

Wenn Funktionen an Funktionen übergeben oder von ihnen zürückgegeben werden
sollen, müssen dafür Pointern oder Referenzen auf Funktionen verwendet werden.

\begin{lstlisting}[language=C++]
#include <iostream>

void f() { std::cout << "A" << '\n'; }
// Gibt Pointer auf Funktion f() zurück
void (*pf())() { std::cout << "PF: "; return &f; }
// Das Gleiche mit impliziter Umwandlung
void (*pf2())() { std::cout << "PF2: "; return f; }
// Das Gleiche mit Trailing return type
auto pf3() -> void(*)() { std::cout << "PF3: "; return &f; }
// Gibt Referenz auf Funktion zurück
void (&rf())() { std::cout << "RF: "; return f; }
// Übergabe von Pointer auf Funktion
void fp( void (*p)() ) { std::cout << "FP: "; (*p)();}
// Übergabe von Referenz auf Funktion
void fr( void (&r)() ) { std::cout << "FR: "; r();}

int main() {
  f();        // A
  (*pf())();  // PF: A
  pf()();     // PF: A
  pf2()();    // PF2: A
  pf3()();    // PF3: A
  rf()();     // RF: A
  fp(&f);     // FP: A
  fr(f);      // FR: A
}
\end{lstlisting}

\subsection{Rückgabetypherleitung --  Return type deduction}

\begin{lstlisting}[basicstyle=\ttfamily\footnotesize,language=C++]
#include <type_traits>

int x = 1;
auto           f0() { return x; }   // return type: int
auto           f1() { return(x); }  // return type: int
auto&          f2() { return x; }   // return type: int&
const auto&    f3() { return x; }   // return type: const int&
decltype(auto) f4() { return x; }   // return type: int, decltype(x)
decltype(auto) f5() { return(x); }  // return type: int&, decltype((x))

int main() {
  static_assert(std::is_same_v<std::invoke_result_t<decltype(f0)>, int>);
  static_assert(std::is_same_v<std::invoke_result_t<decltype(f1)>, int>);
  static_assert(std::is_same_v<std::invoke_result_t<decltype(f2)>, int&>);
  static_assert(std::is_same_v<std::invoke_result_t<decltype(f3)>, const int&>);
  static_assert(std::is_same_v<std::invoke_result_t<decltype(f4)>, int>);
  static_assert(std::is_same_v<std::invoke_result_t<decltype(f5)>, int&>);
}
\end{lstlisting}

\subsection{Parameter Liste}

\begin{lstlisting}[language=C++]
int f0(int);  // Parameter ohne Namen
int f1(int i);  // Benannter Parameter
int f2(int i = 7);  // Mit Name und default Wert
int f3(int = 7);  // Ohne Name, mit default Wert
int f4();  // Ohne Parameter
int f5(void);  // Wie f4
int f6(int i ...);  // Variadic, Beliebige Anzahl von Argumenten
int f7(int i, ...);  // wie f6
int f8(auto);  // Wie: template<class T> int f8(T)
\end{lstlisting}

\subsubsection{Default Arguments}

Erlaubt den Funktionsaufruf, auch wenn abschießende Argumente fehlen.

\begin{lstlisting}[language=C++]
#include <iostream>

void f0(int i = 3, int j = 4) {}

void f1(int, int = 7) {}

// Error: Nachfolgender Parameter hat keinen Defaultwert
//void f2(int = 1, int);

void f3(int, int) {}
//void f3(int = 3, int);  // Error, wie bei f2
void f3(int, int = 4);  // Fügt Defaultargument zu
void f3(int = 3, int);  // Jetzt gleich wie f0
//void f3(int = 3, int = 4);  // Error: redefinition

void f4(int = 3 ...);  // OK, ellipsis ist kein Parameter

int i{1};  // Scope auf dieses i
void f5(int j = i) { std::cout << j << '\n';}
//void f6(int i, int j = i);  // Error: i Schon verwendet
//void f6(int a, int j = a);  //Error:  a ist nicht definiert

void f7() {
  int i{0};
//void f(int = i);  // Lokale Variablen sind nicht erlaubt
};

int b;
class X {
  int a;
  static int b;
  static X y;
//void f(X* p = this);  // Error: this nicht erlaubt
//void m0(int i = a);  // Error: non-static data member
  void m1(int X::* i = &X::a);  // Geht mit Pointer
  void m2(int i = y.a);
  void m3(int i = b);
};

int main() {
  f0(1, 2);  // f0(1, 2)
  f0(1);     // f0(1, 4)
  f0();      // f0(3, 4)

  f1(1, 2);  // f1(1, 2)
  f1(1);     // f1(1, 7)
//f1();      // Error: Zu wenig Argumente

  int i{0};
  f5();  // 1
  ++::i;
  f5();  // 2
}
\end{lstlisting}

\subsubsection{Variadic arguments}

Es gibt keine Möglichkeit die Anzahl der Variadic Argumente zu bestimmen. Man
kann nur auf sie zuzugreifen wenn es vor ihnen ein benanntes Argument gibt.
Alternativen sind Variadic templates oder initializer\_list.

\begin{lstlisting}[language=C++]
#include <cstdarg>
#include <iostream>

int iSum(int n...) {
  int s = 0;
  std::va_list vArgs;  // Enthält Info von ...
  va_start(vArgs, n);  // Ermöglicht Zugriff auf ...
  for (int i = 0; i < n; ++i)
    s += va_arg(vArgs, int);  // Holt nächstes Argument
  va_end(vArgs);  // Beendet Zugriff auf ...
  return s;
}

int main() {
  std::cout << iSum(4, 1, 2, 3, 4) << '\n';  // 10
}
\end{lstlisting}

\subsection{Gelöschte Funktionen}

Können mit \lstinline|delete| definiert werden.

\begin{lstlisting}[language=C++]
int f0(int) = delete;

int main() {
//int i = f0(0);  // Error: use of deleted function
//int i = f1(0);  // Error: not declared
}
\end{lstlisting}

\subsection{Zugriff auf Funktionsnamen}

Mit \lstinline|__func__|.

\begin{lstlisting}[language=C++]
#include <iostream>

void funktionA() { std::cout << __func__ << '\n';}

int main() {
  funktionA();  // Ausgabe: funktionA
}
\end{lstlisting}

\subsection{Lambda Funktionen}

Namenlose Funtkionen, die dort wo sie verwendet auch definert werden. Ihnen kann
der Zugriff auf Variablen im selben Scope (Sichtbarkeitsbereich) ermöglicht
werden.

\begin{lstlisting}[language=C++]
#include <iostream>

int main() {
  int a[]{1,2,3,4};
  int s{0};
  for(int i : a) s += i;  // Mit For loop
  std::cout << s << '\n';  // 10
  // Lambda Funktion wird gleich aufgerufen
  [&]{for(int i : a) s += i;}();
  std::cout << s << '\n';  // 20
  // Lambda Funktion definieren
  auto f = [&]{for(int i : a) s += i;};
  f();  // und aufrufen
  std::cout << s << '\n';  // 30
}
\end{lstlisting}

Allgemeiner Aufbau:\\
\lstinline|[captures]<tparams>(params)->ret{body}|\\


%\section{Classes}

%\section{Templates}

%\section{Exceptions}

%\section{Prepocessor}


%Autor: Georg Kindermann

\end{document}
