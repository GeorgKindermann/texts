\documentclass[10pt,twocolumn]{scrartcl}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\usepackage{microtype}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

\usepackage{textcomp}
\usepackage{newpxtext}
\usepackage{newpxmath}
\usepackage[scaled=0.75]{beramono}

\usepackage{xpatch}
\usepackage{xcolor}
\usepackage{realboxes}
\definecolor{mygray}{rgb}{0.9,0.9,0.9}

\usepackage{listings}
%\lstdefinelanguage{commentonly}{
%  morecomment=[l]{\#},
%  sensitive=true,
%}
\lstset{literate=%
{Ö}{{\"O}}1
{Ä}{{\"A}}1
{Ü}{{\"U}}1
{ß}{{\ss}}1
{ü}{{\"u}}1
{ä}{{\"a}}1
{ö}{{\"o}}1
{²}{{$^2$}}1
{€}{{\texteuro}}1
{├}{{|}}1
{─}{{-}}1
{└}{{L}}1
{│}{{|}}1
,basicstyle=\ttfamily%\small
,backgroundcolor=\color{mygray}
,commentstyle=\emph
%,language=commentonly
,language=R
,stringstyle=\emph %\color{red!50!black}
,upquote=true
,aboveskip=0pt
,belowskip=0pt
}
\makeatletter
\xpretocmd\lstinline
  {%
   \bgroup\fboxsep=1.5pt
   \Colorbox{mygray}\bgroup\kern-\fboxsep\vphantom{\ttfamily\char`\\y}%
   \appto\lst@DeInit{\kern-\fboxsep\egroup\egroup}%
  }{}{}
\makeatother

\usepackage{enumitem}
\setlist{nosep}

\usepackage{adjustbox}
\usepackage[a4paper, margin=1mm, includefoot, footskip=15pt]{geometry}

\usepackage[pdftitle={Grundlagen der Statistiksprache R}
, pdfauthor={Georg Kindermann}
, pdfsubject={R}
, pdfkeywords={R, Lang, Progammiersprache, Tutorial, Einführung, German,
               Deutsch}
, pdflang={de-AT-1996}
, colorlinks=true
, linkcolor=blue
, urlcolor=blue
, pdfpagemode=UseNone]{hyperref}

\nonfrenchspacing
\sloppy

\title{Grundlagen der Statistiksprache R}
\author{Georg Kindermann}
%\date{19. Juni 2023}

\begin{document}

\maketitle

%\begin{abstract}
%  Eine kurze Beispielorientierte Einführung in die Statistiksprache R.
%\end{abstract}

\tableofcontents
\smallskip
%\hrule
\noindent
\href{https://www.r-project.org/}{R} kann vorkompiliert vom
\href{https://cran.r-project.org/}{CRAN} (The Comprehensive R Archive
Network) als \href{https://cran.r-project.org/bin/}{Binärdatei} für
das entsprechende Betriebssystem heruntergeladen werden.

Alternativ kann der
\href{https://cran.r-project.org/src/base/R-4/}{Quellcode}
heruntergeladen und lokal kompiliert werden. Unter Linux kann dies
z.B. so erfolgen, wobei die \lstinline|export|-Zeilen und
\lstinline|./configure|-Flags optional sind. Sie dienen der
Geschwindigkeit und besseren Debug-Möglichkeiten:

\begin{lstlisting}[language=sh]
wget https://cran.r-project.org/src/base/R-latest.tar.xz
mkdir R-latest
tar -xf R-latest.tar.xz -C R-latest --strip-components=1
cd R-latest
export CFLAGS="-O3 -march=native -mtune=native -pipe \
 -flto=auto -fwrapv"
export CXXFLAGS="$CFLAGS"
export FFLAGS="-O3 -march=native -mtune=native -pipe \
 -flto=auto -fallow-argument-mismatch"
export FCFLAGS="$FFLAGS"
export LDFLAGS="-flto=auto -Wl,-O2,--as-needed"
./configure --enable-R-shlib --with-blas --with-lapack \
 --enable-memory-profiling
# --disable-memory-profiling --disable-R-profiling # Schneller
make -j$(nproc)
sudo make install
cd ..
#rm R-latest.tar.xz
#rm -r R-latest/
\end{lstlisting}

Nach dem Start kann R interaktiv verwendet werden. Alternativ lässt
sich R auch über verschiedene IDEs (integrierte Entwicklungsumgebung)
oder Texteditoren nutzen. Die gezeigten Codeabschnitte wurden mit R
Version 4.5.2 (2025-10-31) getestet.

Wenn man R startet, kommt man in den interaktiven Modus.
Deren wichtigste Tastenkombinationen sind:
\begin{description}[style=multiline,leftmargin=2cm,nolistsep]
  \item[CTRL+d] Beendet R (EOF) (Linux/Mac)
  \item[CTRL+z] Beendet R (EOF) (Windows)
  \item[CTRL+c] Bricht laufende Berechnungen oder Eingaben ab
  \item[CTRL+l] Löscht die Konsole (nur in manchen Umgebungen)
  \item[Pfeil ↑ / ↓] Navigiert im Befehlverlauf (History)
  \item[CTRL+r] Rückwärtssuche im Befehlverlauf
  \item[Tab] Auto-Vervollständigung
\end{description}

Beim Beenden von R besteht die Möglichkeit, den Arbeitsbereich (Workspace-Image) zu speichern. Dabei werden ausschließlich die Objekte im globalen Environment, also die im Arbeitsspeicher befindlichen R-Objekte, gesichert, nicht jedoch geladene Pakete. Die vorhandenen Objekte kann man mit \lstinline|ls()| oder \lstinline|objects()| auflisten. Wird R in einem Verzeichnis gestartet, in dem eine gespeicherte Arbeitsumgebung (Datei \lstinline|.RData|) vorhanden ist, wird diese beim Start automatisch geladen. So kann man die Arbeit, nach erneutem Laden der benötigten Pakete, an dem Punkt fortsetzen, an dem man aufgehört hat.

Den Arbeitsbereich kann man jederzeit mit \lstinline|save.image()| speichern. Dabei wird standardmäßig die Datei \lstinline|.RData| erstellt, die beim nächsten Start von R im selben Verzeichnis wieder geladen wird. Alternativ kann man auch einen Dateinamen angeben, z.\,B.\ \lstinline|save.image("WSI.RData")| bzw.\ \lstinline|save.image(file = "WSI.RData")|. Diese Datei kann später mit \lstinline|load("WSI.RData")| bzw.\ \lstinline|load(file = "WSI.RData")| geladen werden. Dabei werden existierende Objekte mit gleichem Namen im aktuellen Environment überschrieben.

Für reproduzierbare Analysen empfiehlt sich der Start von R mit der Option \lstinline|--vanilla| (\lstinline|R --vanilla|). In diesem Fall werden weder Konfigurationsdateien (\lstinline|.Rprofile|, \lstinline|.Renviron| etc.) noch ein gespeichertes Workspace-Image geladen, und beim Beenden wird kein neues gespeichert.

Befehle, die in einer Datei gespeichert sind, lassen sich mit \lstinline|R -f FILE| ausführen. Ein einzelner Ausdruck kann mit \lstinline|R -e EXPR| ausgeführt werden, wobei R danach sofort beendet wird, z.,B.\ \lstinline|R -e "summary(iris)"|. In beiden Fällen wird der Arbeitsbereich beim Beenden standardmäßig nicht gespeichert. Möchte man ihn speichern, muss dies mit der Option \lstinline|--save| explizit angegeben werden, z.,B.\ \lstinline|R --save -f FILE| oder \lstinline|R --save -e "x=5"|.

Bei Verwendung von \lstinline|R -f FILE| oder \lstinline|R -e EXPR| werden standardmäßig ebenfalls Konfigurationsdateien sowie ein eventuell vorhandenes Workspace-Image geladen. Wie bereits beschrieben, kann dies durch \lstinline|--vanilla| unterdrückt werden (\lstinline|R --vanilla -f FILE|, \lstinline|R --vanilla -e EXPR|).

Einige Funktionen die teilweise beim Starten von R kurz vorgestellt werden:

\begin{lstlisting}
q()                   # Beendet R (mit Rückfrage)
help()                # Hilfe starten
help.start()          # Öffnet HTML-Hilfesystem
help(q)               # Hilfe zu Befehl q
?q                    # Hilfe zu Befehl q
demo()                # Zeigt verfügbare Demos
demo(lm)              # Demo zur linearen Regression
version               # R-Version anzeigen
sessionInfo()         # Infos zu Umgebung und geladenen Paketen
citation()            # Wie man R zitiert
\end{lstlisting}


\section{Grundlagen}

\subsection{Objekte und Namen}

In R gibt es:
\begin{description}
\item[Objekte] die eigentlichen Daten, die Platz im Arbeitsspeicher belegen.
\item[Namen] (auch \emph{Bindings}, \emph{Symbole} oder umgangssprachlich \emph{Variablen} genannt), die auf Objekte verweisen.
\end{description}
In R wird ein Name verwendet, um auf ein Objekt im Speicher zu verweisen. Diese Bindungen (Name–Objekt-Zuordnungen) werden in Umgebungen (\emph{Environments}) gespeichert. Ein Name ist nicht das Objekt selbst, sondern stellt lediglich die Verbindung zu ihm her und ermöglicht so dessen Verwendung. Mehrere Namen können gleichzeitig auf \emph{dasselbe} Objekt verweisen.

Wird ein durch mehrere Namen referenziertes Objekt über einen dieser Namen modifiziert, legt R in der Regel \emph{vor} der Modifikation eine Kopie an und lässt den modifizierenden Namen anschließend auf diese Kopie zeigen (\emph{Copy-on-Modify}-Semantik).
Bei sehr kleinen Objekte wie \lstinline|1| wird einfach ein neues Objekt erzeugt, statt zuerst eine Kopie zu erstellen.

Besitzt ein Objekt hingegen nur eine einzige Referenz, erfolgt \emph{In-place modification}. In diesem Fall wird der Wert direkt an der bestehenden Speicheradresse überschrieben, ohne eine Kopie anzufertigen.

Ein Name kann jederzeit durch eine neue Zuweisung auf ein anderes Objekt umgebunden werden (\emph{Rebinding}).

Mit \lstinline|rm()| wird ein Name aus der aktuellen Umgebung entfernt. Objekte ohne verbleibende Referenzen werden automatisch vom \emph{Garbage Collector} gelöscht. Der Garbage Collector kann manuell mit \lstinline|gc()| aktiviert werden.

\begin{lstlisting}
1                     # Ein Objekt mit dem Wert 1
x <- 1                # Name x zeigt auf Objekt mit Inhalt 1
x                     # Zeigt den Inhalt des Objekts
get("x")              # 1; Standardweg für dynamische Namen
s <- "x"
get(s)                # 1
tracemem(x)           # Zeigt Speicher auf den x zeigt
y <- x                # y zeigt auf das gleiche Objekt wie x
tracemem(x) == tracemem(y) # TRUE
y <- 2                # y erhält ein neues Objekt mit Wert 2
tracemem(x) == tracemem(y) # FALSE

a <- 1:3                    # Zahlen 1, 2, 3
b <- a
tracemem(a) == tracemem(b)   # TRUE
b[1] <- 0L                   # jetzt wird eine Kopie angelegt
                             # Erstem Element 0 zuweisen
tracemem(a) == tracemem(b)   # FALSE
identical(a, b)              # FALSE; Inhalt unterschiedlich
a[1] <- 0L
identical(a, b)              # TRUE; Inhalte jetzt wieder gleich
tracemem(a) == tracemem(b)   # FALSE; aber verschiedene Objekte
b <- a                       # Zeigen wieder auf gleiches Objekt
tracemem(a) == tracemem(b)   # TRUE
 # Objekt auf das b zeigte wird automatisch gelöscht

x <- c(3, 1, 2)
tracemem(x)          # "<0x55caaabbaea8>
x[2] <- 7            # In-place modification
tracemem(x)          # "<0x55caaabbaea8>
\end{lstlisting}

\lstinline|tracemem()| zeigt die Speicheradresse an und meldet jedes Mal, wenn ein Objekt kopiert wird. Dies funktioniert nur, wenn R mit aktiviertem Memory-Profiling kompiliert wurde (überprüfbar mit \lstinline|capabilities("profmem")|). \lstinline|untracemem()| deaktiviert die Meldung bei Objektkopien.

Die interne Funktion \lstinline|.Internal(inspect(x))| zeigt ebenfalls die Speicheradresse sowie weitere interne Informationen, darunter die Anzahl der Namen (REF-Wert), die auf das Objekt zeigen. Sie benötigt kein Memory-Profiling.

\begin{lstlisting}
x <- 1
.Internal(inspect(x))
# @5577ec525cf8 14 REALSXP g0c1 [REF(2)] (len=1, tl=0) 1
y <- x
.Internal(inspect(x))
# @5577ec525cf8 14 REALSXP g0c1 [REF(3)] (len=1, tl=0) 1
rm(x)          # Löscht nur den Namen x, nicht das Objekt
.Internal(inspect(y))
# @5577ec525cf8 14 REALSXP g0c1 [REF(2)] (len=1, tl=0) 1
rm(y)          # Keine Referenz mehr auf Objekt
gc()           # Löst Garbage Collector per Hand aus
\end{lstlisting}

Reguläre Sequenzen (z.\,B.\ \lstinline|1:10000|) werden als \emph{Alternate Representation} (ALTREP) platzsparend gespeichert. Sie belegen erst dann den vollen Speicher, wenn sie verändert werden (Materialisierung).

\lstinline|object.size()| zeigt stets die Größe eines vollständig materialisierten Vektors, während \lstinline|lobstr::obj_size()| die tatsächliche, oft deutlich geringere Speicherbelegung ermittelt. Dazu muss jedoch erst das Paket \lstinline|lobstr| in R mit \lstinline|install.packages("lobstr")| installiert werden, wobei hier meist noch nach einem zu verwendenden Server gefragt wird.

\begin{lstlisting}
x <- 1:10000
object.size(x)       # 40048 bytes
lobstr::obj_size(x)  # 680 B
x[1] <- 0L           # Vector wird wirklich erzeugt
object.size(x)       # 40048 bytes
lobstr::obj_size(x)  # 40.05 kB
\end{lstlisting}

\lstinline|str()| zeigt einen kompakten Überblick über die Struktur eines Objekts.
\lstinline|dput()| erzeugt Code, mit dem man das Objekt rekonstruieren kann.

\begin{lstlisting}
x <- 1:3
str(x)     # int [1:3] 1 2 3
dput(x)    # 1:3
x[1] <- 0L
str(x)     # int [1:3] 0 2 3
dput(x)    # c(0L, 2L, 3L)
\end{lstlisting}

Namen werden aus Buchstaben, Ziffern, \lstinline|.| (Punkt) und \lstinline|_| (Unterstrich) gebildet. Sie sollten weder mit \_ noch mit einer Zahl anfangen und nicht zu den reservierten Wörtern gehören, die man mit \lstinline|?Reserved| ansehen kann. Namen, die nicht diesen Regeln folgen oder syntaktisch zweideutig sind, müssen mit Backticks geschrieben werden (z.\,B.\ \lstinline|`_`| oder \lstinline|`in`|).

\begin{lstlisting}
x <- 1
#_x <- 1   ## Error, unerwartetes Symbol
#1x <- 1   ## Error, unerwartetes Symbol
#in <- 1   ## Error, Unerwartete(s) 'in'
.x <- 1
#.1 <- 1   ## Error, ungültige linke Seite
`_` <- 1
`_`        # 1
"_" <- 2
`_`        # 2
'_' <- 3
`_`        # 3
`2` <- 1
`2`        # 1
`in` <- 1
`in`       # 1
`.1` <- 1
`.1`       # 1
\end{lstlisting}


\subsection{Zuweisungen}

Eine Zuweisung bindet einen Namen an ein Objekt oder ändert eine bestehende Bindung.

R kennt mehrere Syntaxvarianten:

\begin{lstlisting}
x <- 1          # Häufig verwendete Form
2 -> x          # Äquivalent zu <-
x = 3           # Ebenfalls möglich
`<-`(x, 4)      # Funktionale Form

assign("x", 5)  # Standardweg für dynamische Namen
s <- "x"
assign(s,   6)  # Bindet an Name der in s steht

eval(parse(text = paste(s, "<- 7"))) # Alternative
\end{lstlisting}

Der Operator \lstinline|=| wird außerdem verwendet, um Argumente oder Elemente zu benennen:

\begin{lstlisting}
c(x = 0)        # Erstes Element hat den Namen x
c(x <- 9)       # Zuweisung! Element hat KEINEN Namen
x               # 9
\end{lstlisting}

In R wird die Zuweisung eines Objekts zu einem Namen üblicherweise mit \lstinline|<-| vorgenommen, während für die Übergabe benannter Argumente an Funktionen immer \lstinline|=| verwendet werden muss. Der Name verweist dabei auf das Objekt, ist aber nicht das Objekt selbst. Durch die Verwendung von \lstinline|<-| wird  diese Bindung deutlich dargestellt.

Bei jedem Funktionsaufruf entsteht ein eigenes, temporäres Ausführungs-Environment, dessen Elternumgebung das Environment ist, in dem die Funktion definiert wurde.

Normale Zuweisungen mit \lstinline|<-| oder \lstinline|=| erzeugen Bindings ausschließlich im lokalen Ausführungs-Environment und verändern äußere Umgebungen nicht.

Der Super-Assignment-Operator \lstinline|<<-| (bzw.\ \lstinline|->>|) durchsucht die Elternumgebungen nach einem bestehenden Binding. 
Existiert der Name in einer dieser Umgebungen, wird das Binding dort geändert. 
Wird der Name nicht gefunden, wird er im \lstinline|.GlobalEnv| angelegt oder eine dort bereits bestehende Bindung aktualisiert, unabhängig davon, ob das \lstinline|.GlobalEnv| auf dem Suchpfad der aktuellen Umgebung liegt.
Im lokalen Ausführungs-Environment wird dabei nie eine vorhandene Bindung verändert und auch keine neue angelegt, ausser man befindet sich im GlobalEnv.

\begin{lstlisting}
i <- 1
j <- 2
f <- function() {    # Erzeugt eine Funktion
  i <-  30    # Neues lokales i (verdeckt in f globales)
  j <-  0
  j <<- 40    # Findet und überschreibt das globale
  cat(j)
  k <-  50    # Nur lokal
  l <<- 60 }  # Wird global angelegt
f()           # 0; Ruft Funktion auf
i   # 1
j   # 40
#k  ## Error, nicht gefunden
l   # 60
\end{lstlisting}

Bindungen können mit \lstinline|lockBinding()| gesperrt und mit \lstinline|unlockBinding()| wieder entsperrt werden.

\begin{lstlisting}
x <- 0
lockBinding("x", globalenv())  # Sperren
#x <- 1                        ## Error, gesperrt
unlockBinding("x", globalenv())
x <- 2
lockBinding("x", globalenv())
rm(x)                          # Geht
\end{lstlisting}

Mit \lstinline|delayedAssign| können Zuweisungen auf den Zeitpunkt
ihrer esten Verwendung verschoben werden.

\begin{lstlisting}
#y <- x               # Error, x nicht gefunden
delayedAssign("y", x + 1)
# y                   # Error, x nicht gefunden
x <- 0
y                     # 1
x <- 42
y                     # 1
\end{lstlisting}


\subsection{Environment (Umgebung)}

Ein Environment kann man sich wie ein Blatt Papier vorstellen, auf dem Name--Adresse--Paare stehen.
Das Environment selbst ist ebenfalls ein Objekt und kann über einen Namen referenziert werden. Jedes Environment enthält (als Speicheradresse) einen Verweis auf das nächste Blatt (\emph{Parent Environment}), in dem weitergesucht wird, falls ein Name auf diesem Blatt nicht gefunden wird (\emph{Lexical Scoping}).
Jedes Environment hat genau ein Parent. R erzwingt strikt, dass diese Parent-Kette hierarchisch und nicht zyklisch ist. Es kann jedoch mehrere voneinander unabhängige Parent-Ketten geben.
Das Parent eines Environments kann, mit Ausnahme des leeren Environments, auf ein anderes Environment gesetzt werden, solange dadurch keine zyklische Struktur entsteht.
Jede Parent-Kette endet im leeren Environment (\lstinline|emptyenv()|).
\lstinline|environment()| gibt das aktuelle Environment zurück (in interaktiven Sitzungen meist das GlobalEnv, in Funktionen das Funktionsenvironment).
\lstinline|new.env()| erzeugt ein neues Environment,
\lstinline|parent.env()| zeigt das Elternenvironment.

\begin{lstlisting}
environment()     # <environment: R_GlobalEnv>
e <- new.env()    # Erzeugt neues Environment und bindet es an e
e                 # <environment: 0x55b8959188f8>; Adresse
parent.env(e)     # <environment: R_GlobalEnv>;Elternenvironment
#get("x", e)      ## Error, x nicht gefunden
exists("x", e)    # FALSE
x <- 0
get("x", e)       # 0; findet x im globalEnv
#get("x", e, inherits = FALSE) ## Error, x nicht gefunden
get0("x", e, inherits = FALSE) # NULL; NULL weil nicht gefunden
exists("x", e, inherits = FALSE) # FALSE
e[["x"]]          # NULL; Sucht x nur in e
e$x               # NULL; Sucht x nur in e
e$x <- 1          # e enthält nun x
#assign("x", 1, e) # Alternative
get("x", e)       # 1; findet x in e
e[["x"]]          # 1
e$x               # 1
y <- 0
get("y", e)       # 0; findet y im globalEnv
parent.env(e) <- emptyenv() # Neues Parent Environment
#get("y", e)      ## Error, y nicht gefunden
#parent.env(e) <- e  ## Error, zyklisch Kette
ls(e)             # "x"; Zeigt Namen in e

e <- new.env(parent = emptyenv()) # Parent angegeben
e$x               # NULL

e <- emptyenv()
e                 # <environment: R_EmptyEnv>
#parent.env(e)    ## Error, hat keinen Parent
#parent.env(e) <- emptyenv() ## Error, emptyEnv hat kein Parent
e$x               # NULL
e$x <- 2          # Error, leere Umgebung
\end{lstlisting}

Ein Environment kann Namen enthalten, die auf andere Environments zeigen.
Namen innerhalb eines Environments können auch wieder auf dasselbe Environment verweisen und dadurch zyklische Referenzen bilden.

\begin{lstlisting}
e <- new.env()
e$x <- 1          # e enthält nun x  
e$e <- e          # e zeigt auf sich selbst
e$e$x             # 1
e$e$e$x           # 1
e$e$e$e$x         # 1
e$eb <- e         # e zeigt mit weiteren Namen auf sich selbst
e$eb$x            # 1
e$eb$e$eb$x       # 1
e$x <- 2
e$eb$e$eb$x       # 2
\end{lstlisting}

Innerhalb eines Environments kann die Namenssuche mittels Hash-Lookup erfolgen, also über einen schnellen Schlüsselindex.

\begin{lstlisting}
e1 <- new.env()
e2 <- new.env(hash = FALSE) # Nicht mit Hash suchen
env.profile(e1)             # Info zur Hash Suche
env.profile(e2)             # NULL; keine Hash Suche
lobstr::obj_size(e1)        # 336 B
lobstr::obj_size(e2)        #  56 B
\end{lstlisting}

Im Gegensatz zu einer Liste ist ein Environment referenzbasiert (Environments werden gewöhnlich nicht kopiert), besitzt keine feste Reihenfolge seiner Elemente und verfügt stets über ein Parent-Environment. Mit \lstinline|rlang::env_clone()| kann man ein Environment kopieren.

\begin{lstlisting}[language=R]
e1 <- new.env()
e1$a <- 1
e2 <- e1      # e2 zeigt auf e1
e2$a <- 2     # ohne copy on modify
e1$a          # 2
e1[["a"]]     # 2

e3 <- rlang::env_clone(e1, parent.env(e1))
e3$a          # 2
e3$a <- 3
e3$a          # 3
e1$a          # 2

# Geht nicht für unevaluated promises
e4 <- list2env(as.list(e1, all.names=TRUE), parent=parent.env(e1))
e4$a          # 2
e4$a <- 3
e4$a          # 3
e1$a          # 2

e5 <- attach(e1)
parent.env(e5) <- parent.env(e1)
detach()
e5$a          # 2
e5$a <- 3
e5$a          # 3
e1$a          # 2

x <- list(a = 1)
y <- x        # y zeigt auf x
y$a <- 2      #  mit copy on modify
x$a           # 1
\end{lstlisting}

Man kann Environments mit \lstinline|lockEnvironment()| gegen Änderungen sperren. Die Sperre eines Environments kann nicht deaktiviert werden. Es können auch die Bindungen gesperrt werden, welche wieder entsperrt werden können.

\begin{lstlisting}
e <- new.env()
e$x <- 0
lockEnvironment(e)
#e$y <- 1    ## Error, nicht hinzufügbar
e$x <- 2     # Jedoch Bindung veränderbar
lockEnvironment(e, TRUE)  # Sperrt auch Bindungen
#e$x <- 3    ## Error, nicht änderbar
unlockBinding("x", e)
e$x <- 4
\end{lstlisting}


\subsection{Funktionen}

Funktionen sind wiederverwendbare Codebausteine, mit denen sich Programme in übersichtliche Module mit klar definierten Schnittstellen und Aufgaben gliedern lassen.

Funktionen werden mit \lstinline|function()| oder mit \lstinline|\()| erzeugt. \lstinline|function()| und \lstinline|\()| sind vollständig äquivalent.


\subsubsection{Body -- Funktionskörper}

Der \emph{Funktionskörper} (Body), also der beim Funktionsaufruf auszuführende Code, kann mit \lstinline|body()| angezeigt und auch verändert werden.

\begin{lstlisting}
f <- function() 0  # Erzeugt Funktion f
#f <- \() 0        # Alternative
f                  # function() 0; Gibt Funktion zurück
f()                # 0; Ruft Funktion auf

body(f)            # 0; Funktionskörper
body(f) <- 1       # Ändert Funktionskörper
f()                # 1

g <- \(x) x * 2
g(1)               # 2
body(g) <- quote(x * 3)
g(1)               # 3
\end{lstlisting}

\lstinline|quote()| gibt seine Argumente unausgewertet (not evaluated) zurück

Besteht der \emph{Funktionskörper} aus mehr als einem Element werden diese in geschweiften Klammern \lstinline|{}| geschrieben.

\begin{lstlisting}
f <- \() {x <- sum(1:3); x / 2} # kompakte Schreibweise
g <- \() {                      # explizit bzw. formatiert
  x <- sum(1:3)
  x / 2
}
\end{lstlisting}

Funktionen geben ihren letzten evaluierten Ausdruck zurück.
Zusätzlich gibt es noch den Befehl \lstinline|return()| welcher die Funktion beendet und ebenfalls einen evaluierten Ausdruck oder \lstinline|NULL| zurück gibt.
\lstinline|return()| ist optional und dient vor allem der frühen Rückgabe oder zur besseren Lesbarkeit.

\begin{lstlisting}
f <- \() {
  4
  2
}
f()       # 2
g <- \() {
  return(4)
  2
}
g()       # 4
\end{lstlisting}

Funktionen liefern immer einen Rückgabewert, solange sie nicht durch einen Fehler abgebrochen werden. Mit \lstinline|invisible()| lässt sich jedoch verhindern, dass dieser Wert auf der Konsole ausgegeben wird.

\begin{lstlisting}
f <- \() invisible()
f()                  # Auf der Konsole erscheint nichts
x <- f()
x                    # NULL

g <- \() invisible(1)
g()                  # Auf der Konsole erscheint nichts
x <- g()
x                    # 1

h <- \() stop()      # stop löst einen Fehler aus
#y <- h()            ## Error; Funktion wird abgebrochen
#y                   ## Fehler, y nicht gefunden
\end{lstlisting}

Funktionen können sich selber aufrufen (\emph{rekursiv}). Dabei muss darauf geachtet werden, dass die Rekursion irgendwann terminiert. Die maximale Anzahl gleichzeitig ausgewerteter verschachtelter Ausdrücke kann mit \lstinline|options("expressions")| eingestellt werden.

\begin{lstlisting}
f <- \(n) if (n > 0) n + f(n-1) else n
f(3)          # 6; Rekursiv

options("expressions")        # 5000
g <- \(n) {n <<- n; g(n+1L)}
g(1L)                         ## Löst Fehler aus
n                             # 4997
options(expressions = 1000)
g(1L)                         ## Löst Fehler aus
n                             # 998

options(expressions = 25)
h <- \(x) x + 1
h(h(h(h(h(h(h(h(0))))))))     # 8
#h(h(h(h(h(h(h(h(h(0))))))))) ## Error, zu tief verschachtelt
\end{lstlisting}

\subsubsection{Formals -- Funktionsparameter}

An Funktionen können \emph{Argumente} übergeben werden. Dazu werden bei der Funktionserstellung \emph{Parameter} (\emph{Formals} bzw. \emph{Formal Arguments}) in der runden Klammer angegeben, welche die Funktion bei ihrem Aufruf erwartet. Mit dem Befehl \lstinline|formals()| können diese angezeigt und auch verändert werden.

\begin{lstlisting}
f <- \(x) x   # x .. Parameter
f(4)          # 4; 4 .. übergebenes Argument
f(2)          # 2
#f()          ## Error, Argument x fehlt

g <- \(x) 0
g()           # 0; Geht da x nie verwendet wird
g(1)          # 0
#g(1, 2)      ## Error, unbenutztes Argument

formals(f)    # $x;  Zeigt Funktionsparameter
\end{lstlisting}

Mit \lstinline|missing()| kann getestet werden ob Argument übergeben wurde.

\begin{lstlisting}
f <- \(x) missing(x)
f()                  # TRUE
f(1)                 # FALSE
x <- 0
f()                  # TRUE; x wird auch hier nicht übergeben
\end{lstlisting}

Die Parameterliste legt Namen, Reihenfolge und Default-Werte der zu übergebenden Argumente fest.

\begin{lstlisting}
f <- \(x, y = 0) x - y # y hat Defaultwert
f(3, 1)                # 2; 3 wird x, 1 wird y .. 3 - 1
f(3)                   # 3; y erhält Defaultwert 0 .. 3 - 0

formals(f)             # $x $y 0
formals(f)$y <- 1      # Setzt Defaultwert von y auf 1
f(3)                   # 2
formals(f) <- alist(y = , x = 3) # Setzt neue formals
f(1)                   # 2

g <- f
formals(f)$x <- 2      # Ändert formals mit Copy on Modify
f(1)                   # 1; f wurde geändert und dabei kopiert
g(1)                   # 2; g bleibt wie es ist

h <- \(x=0) missing(x)
h()   # TRUE; x hat zwar Defaultwert, wurde aber nicht übergeben
\end{lstlisting}

Explizit \emph{übergebene Argumente} werden im \emph{Calling
Environment} ausgewertet. \emph{Default-Argumente} werden im
\emph{Enclosing Environment} ausgewertet.

\begin{lstlisting}
e <- new.env()
e$x <- 1
f <- with(e, \(y = x) y)
f()             # 1; aus Enclosing Environment e
x <- 2
f(x)            # 2; aus Calling Environment
\end{lstlisting}

Ein Defaultwert kann nicht denselben Namen wie der Parameter haben, weil in diesem Fall der Defaultwert auf das Promise des Parameters verweist und sich somit beim Auswerten selbst referenziert, obwohl er noch keinen Wert hat.

\begin{lstlisting}
f <- \(x = x) x
#f()                 ## Error, rekursive Referenz
\end{lstlisting}

Es können auch Funktionen übergeben werden.

\begin{lstlisting}
f7 <- \(a, b) a(b) # Argument a ist eine Funktion
f7(mean, 1:3)  # 2
f7(sum , 1:3)  # 6
\end{lstlisting}


\paragraph{Argument Matching}

Beim Funktionsaufruf kann der Name der Argumente angegeben werden.

\begin{lstlisting}
f <- \(x, y = 0) x - y
f(y = 1, x = 3)        # 2
\end{lstlisting}

Bei einem Funktionsaufruf werden die übergebenen \emph{Argumente} den formalen \emph{Parametern} gemäß folgender Priorität zugeordnet:

\begin{enumerate}
  \item Exakter Name  
  \item Partieller Name (eindeutiger Präfix eines formalen Arguments)
  \item Position  
\end{enumerate}

Dadurch können Argumente frei kombiniert (positional und per Name) übergeben werden.

\begin{lstlisting}
f <- function(x, xa, ya, yb, za) cat(x, xa, ya, yb, za)
f(1, 2, 3, 4, 5)         # 1 2 3 4 5; Position
f(1, 2, 3, 4, x=5)       # 5 1 2 3 4; exakter Name + Position
f(1, 2, 3, 4, xa=5)      # 1 5 2 3 4; exakter Name + Position
#f(1, 2, 3, x=4, x=5)    ## Error, x passt zu mehreren
#f(1, 2, 3, 4, y=5)      ## Error, y mehrdeutig ya oder yb
f(z=1, 2, 3, 4, 5)     # 2 3 4 5 1; Partieller Name und Position
#f(zak=1, 2, 3, 4, 5)    ## Error, unbenutztes Argument zak
\end{lstlisting}

Auch wenn Funktionsaufrufe mittels Position oder partiellem Matching kompakter sind, ist der Aufruf mittels Exakter Namen meist nachvollziehbarer. Mit \lstinline|options(warnPartialMatchArgs = TRUE)| wird bei jedem partiellem Matching eine Warnmeldung angezeigt.

\paragraph{Ellipsis (...)}

Die Ellipsis \lstinline|...| fängt alle nicht explizit definierten Argumente auf und ermöglicht deren unveränderte Weitergabe an andere Funktionen.

Die einfachste Nutzung besteht darin, \lstinline|...| an eine andere Funktion
durchzureichen. Dadurch kann eine Funktion zusätzliche Argumente akzeptieren,
ohne sie selbst zu kennen oder auszuwerten.

\begin{lstlisting}
fx <- \(x) x
fx(1)           # 1
fx(x=1)         # 1
#fx(y=1)        ## Error, unbenutztes Argument
#fx(1, 2)       ## Error, unbenutztes Argument
#fx()           ## Error, Argument x fehlt
#
f <- \(...) fx(...) # Weitergabe von ... an fx
f(1)            # 1
f(x=1)          # 1
#f(y=1)         ## Error, unbenutztes Argument
#f(1, 2)        ## Error, unbenutztes Argument
\end{lstlisting}

Beim Matching von Argumenten können Konflikte entstehen, wenn benannte
Argumente in \lstinline|...| auf Funktionsparameter einer Ziel-Funktion passen.
Dies betrifft sowohl fehlende als auch mehrdeutige Zuordnungen.

\begin{lstlisting}
fx <- \(x, y=0) x + y  # Defaultwert für y
fx(1)           # 1
#fx(y=1)        ## Error, kein x
fx(1, 2)        # 3
fx(1, 2, 3)     ## Error, unbenutztes Argument

fx <- \(x, ...) x
#fx(y=1)        ## Error, Argument x fehlt
fx(1, 2)        # 1
fx(1, a=1, a=2) # 1; 2 mal a! ... wird nicht ausgewertet
#
f <- \(x, ...) fx(...) # Vermeiden da x nur unbenannt an fx geht
#f(1)           ## Error, Argument x fehlt für fx
f(1, 2)         # 2
f(x=1, 2)       # 2; 
#f(x=1, x=2)    ## Error, x passt zu mehreren Argumenten
f(x=1, y=2)     ## Error, Argument x fehlt für fx
#
f <- \(y, ...) fx(...)
f(1, 2)         # 2
f(x=1, 2)       # 1
f(x=1, y=2)     # 1
\end{lstlisting}

R stellt Funktionen bereit, um direkt auf einzelne Elemente der
Ellipsis zuzugreifen ohne diese auszuwerten. Der Zugriff kann über \lstinline|..1| für das erste, \lstinline|..2| zweite \dots Element erfolgen.

\begin{lstlisting}
f <- \(x, ...) ..2  # zweites Element von ...
f(1, 2, 3, 4)   # 3
f(1, 2, 3, x=4) # 2
f(1, 2, 3, y=4) # 3
#f()            ## Error, ..2 nicht vorhanden
\end{lstlisting}

Alternativ kann auch \lstinline|...elt(1)|, \lstinline|...elt(2)|, \dots verwendet werden.

\begin{lstlisting}
f <- \(x, ...) ...elt(2)  # zweites Element von ...
f(1, 2, 3, 4)   # 3
\end{lstlisting}

\lstinline|...length()| zeigt die Länge der Ellipsis und wertet die Argumente nicht aus.

\begin{lstlisting}
f <- \(x, ...) ...length()  # Länge von ...
f()             # 0
f(1, 2, 3)      # 2, weil x=1 nicht in ... ist
f(1, cat("a"))  # 1; Wertet Argumente nicht aus
\end{lstlisting}

\lstinline|...names()| zeigt die Namen der Ellipsis und wertet die Argumente nicht aus.

\begin{lstlisting}
f <- \(...) ...names()  # Namen von ...
f(1, 2)         # NULL
f(1, a=1, a=2)  # "" "a" "a"
f(1, cat("a"))  # NULL; Wertet Argumente nicht aus
\end{lstlisting}

Alternativ kann \lstinline|...| auch in eine Liste umgewandelt werden, wobei die Argumente ausgewertet werden.

\begin{lstlisting}
f1 <- \(x, ...) list(...)[[2]]     # Zweites Element
f1(1, cat("Z"), 3, 4)   # Z 3; list wertet Argumente aus

f2 <- \(x, ...) length(list(...))  # Länge von ...
f2(1, cat("a"), 3)    # a 2

f3 <- \(...) names(list(...))      # Namen von ...
f3(1, a=1, a=2)       # "" "a" "a"
f3(a=1, b=cat("Z"))   # Z "a" "b"
\end{lstlisting}

\paragraph{Lazy Evaluation}

Funktionsargumente werden erst bei ihrer ersten Verwendung ausgewertet (\emph{Lazy Evaluation}). Bis dahin liegen sie als sogenannte \emph{Promises} vor, unevaluierte Ausdrücke mit zugehörigem Environment. Dies gilt auch für Defaultargumente, die ebenfalls erst beim ersten Zugriff berechnet werden und daher von der Umgebung zum Zeitpunkt ihrer Auswertung abhängen können.
Explizit \emph{übergebene Argumente} werden im \emph{Calling Environment}, \emph{Default-Argumente} im \emph{Enclosing Environment} der Funktion ausgewertet. Wird ein Promise zum ersten Mal benötigt, wird es einmalig ausgewertet. Der resultierende Wert wird im Promise selbst gespeichert, das im Execution Environment der Funktion liegt. Weitere Zugriffe verwenden dann diesen zwischengespeicherten Wert. Der Parameternamen kann jedoch später im Execution Environment neu gebunden werden (z.,B.\ mittels \lstinline|<-|).

Wird ein Promise zum ersten Mal benötigt, wird es einmalig ausgewertet und der resultierende Wert für alle weiteren Zugriffe im selben Funktionsaufruf zwischengespeichert.

Eine Auswertung kann mittels \lstinline|force()| oder einfach anführen des Namens erfolgen.

\begin{lstlisting}
f1 <- \(x, y=x) c(x <- x+1, y)
f1(0)                 # 1 1

f2 <- \(x, y=x) c(y, x <- x+1)
f2(0)                 # 0 1

f3 <- \(x, y=x) {force(y); c(x <- x+1, y)}
f3(0)                 # 0 1

f4 <- \(x, y=x) {y; c(x <- x+1, y)}
f4(0)                 # 0 1
\end{lstlisting}

Da Argumente vor ihrer ersten Verwendung reine Ausdrücke sind, kann dies mit
\lstinline{substitute()} sichtbar gemacht werden.

\begin{lstlisting}
f <- \(x, y=x) print(substitute(y))  # Zeigt unausgewerteten Ausdruck
f(0)                  # zeigt den Ausdruck: x
f(0, 1)               #     zeigt den Wert: 1
f(0, xyz)             # zeigt den Ausdruck: xyz
\end{lstlisting}

Die Funktion \lstinline|substitute()| gibt den übergebenen Ausdruck in
\emph{nicht ausgewerteter Form} zurück. Das heißt, sie liefert den
syntaktischen Ausdruck (eine sogenannte Language- oder Symbol-Struktur),
den R an dieser Stelle erhalten hat, ohne ihn zu evaluieren.


\subsubsection{Environment -- Funktionsumgebungen}

Bei einem Funktionsaufruf erzeugt R ein temporäres \emph{Execution Environment} (auch \emph{Evaluation Environment genannt},  Ausführungsumgebung), dessen Parent das \emph{Enclosing Environment} der Funktion ist. In diesem Execution Environment befinden sich während der Ausführung die Parameter sowie alle lokal erzeugten Namen.

Das Execution Environment ist temporär und wird nach dem Funktionsaufruf verworfen. Es sei denn,
\begin{itemize}
\item es wird an einen Namen in einem dauerhaften Environment gebunden, oder
\item es wird direkt von der Funktion zurückgegeben, oder
\item es bleibt als Enclosing Environment einer neu erzeugten Funktion erhalten, die entweder zurückgegeben oder in einem dauerhaften Environment gebunden wird.
\end{itemize}

Funktionen, die andere Funktionen zurückgeben, heißen \emph{function factories}.
Die zurückgegebene Funktion ist eine Closure und behält ihr enclosing environment.
Dadurch bleiben alle in diesem Environment gebundenen Objekte erhalten.
Dies ermöglicht z.\,B.\ die Speicherung von Zustand zwischen Aufrufen (Zähler, Zwischenergebnisse, Parameter).
Um unnötige Speicherbelegung zu vermeiden, sollten nicht benötigte Objekte vor der Rückgabe des Closure mit \lstinline|rm()| entfernt werden.

\begin{lstlisting}
f1 <- \() {x <- 1; ef1 <<- environment()}
f1()           # bindet sein Execution Environment an ef1
ef1$x          # 1; Execution Environment von f1

f2 <- \() {x <- 2; environment()}
ef2 <- f2()    # gibt Execution Environment zurück
ef2$x          # 2

f3 <- \() {x <- 3; f4 <<- \() x}
f3()           # Bindet erzeugte Funktion an f4
f4()           # 3
environment(f4)$x # 3
environment(f4)$x <- 4
f4()           # 4

f5 <- \() {x <- 5; \() x}
f6 <- f5()     # Gibt Funktion zurück
f6()           # 5
environment(f6)$x <- 6
f6()           # 6
\end{lstlisting}

Bei Funktionen kann man folgende Environments unterscheiden:

\begin{description}
  \item[Binding Environment:] Das Environment, in dem der Funktionsname gebunden ist (wo der Name gefunden wird). Ein Funktionsobjekt kann unter mehreren Namen in verschiedenen Environments gebunden sein. Das Binding Environment spielt für die spätere Namenssuche innerhalb der Funktion keine Rolle.
  \item[Enclosing Environment:] Das Environment, in dem das Funktionsobjekt ursprünglich erzeugt wurde, welches jedoch nachträglich geändert werden kann. Dieses Environment bestimmt die Environment-Kette, entlang der die Funktion nach Namen sucht. 
  \item[Execution Environment:] Das bei jedem Funktionsaufruf neu erzeugte Environment, in dem lokale Variablen entstehen.
  \item[Calling Environment:] Das Environment, aus dem die Funktion aufgerufen wurde. In den meisten Fällen ist es das Environment des \emph{Parent-Frames} (vgl.\ \lstinline|parent.frame()|). Bevor die Ausführung der Funktion beginnt, werden die Ausdrücke der Argumente im Calling Environment lokalisert und als \emph{Promises} im Execution Environment den formalen Parametern zugewiesen. Die Auswertung (force) der Promises erfolgt erst beim ersten Zugriff innerhalb der Funktion (lazy evaluation).
\end{description}

Funktionen suchen Namen weder entlang der Environment-Kette ihres Aufrufortes (Calling Environment) noch entlang der Environment-Kette, in der der Funktionsname gefunden wurde (Binding Environment), sondern entlang der Environment-Kette ihres \emph{Enclosing Environments}.
Die Namenssuche beginnt im Execution Environment. Wenn ein Name dort nicht gefunden wird, sucht R im Enclosing Environment der Funktion und dann in der übergeordneten Environment-Kette.

Mehrere Funktionen können dasselbe Environment nutzen. Das Enclosing Environment ist ein dauerhaftes Environment, in dem Variablen gespeichert werden können.

\begin{lstlisting}
f1 <- \() x
#f()           ## Fehler, x nicht gefunden
x <- 1
f1()           # 1; greift jetzt auf globales x zu

f2 <- \() {x <- 2; x} # Erzeugt lokales x
f2()           # 2; greift auf lokales x zu

f3 <- \() {x <<- 3; x} # Verändert x in Parent
f3()           # 3
f1()           # 3

f4 <- local(\() x)
f4()           # 3; greift auf globales x zu
environment(f4)$x <- 4
f4()           # 4; greift auf lokales x zu
x              # 3

f5 <- local({n=0L; \() {n <<- n+1L; n}})
f5()           # 1
f5()           # 2
environment(f5)$n <- 8
f5()           # 9
\end{lstlisting}

\lstinline|local()| erzeugt ein Environment, in dem Objekte (z. B. Zähler oder Parameter) dauerhaft für die zurückgegebene Funktion gebunden bleiben.

\begin{lstlisting}
e1 <- new.env()
e1$x <- 1
e2 <- new.env(parent = e1)
e2$f1 <- \() x            # enclosing environment: GlobalEnv
environment(e2$f1)        # R_GlobalEnv
#e2$f1()                  ## Fehler, 'x' nicht gefunden
environment(e2$f1) <- e1  # setzt e1 als enclosing environment
e2$f1()                   # 1

e2$f2 <- with(e2, \() x)  # enclosing environment: e2
e2$f2()                   # 1
e2$x <- 2
e2$f1()                   # 1; Beginnt Suche in e1
e2$f2()                   # 2; Beginnt Suche in e2

e2$f3 <- with(e2, \() x <- 3)
e2$f3()                   # Lokales x
e2$x                      # 2

e2$f4 <- with(e2, \() x <<- 4)
e2$f4()                   # Parent x
e2$x                      # 4
e1$x                      # 1; Nicht geändert

e1$y <- 0
e2$f5 <- with(e2, \() y <<- 5)
e2$f5()                   # Parent y
e2$y                      # NULL
e1$y                      # 5

e2$f6 <- with(baseenv(), \() z <<- 6)
e2$f6()                   # z Nicht gefunden => globalEnv
z                         # 6

f7 <- \() x <- 0
environment(f7) <- emptyenv()
#f7()                     ## Fehler Funkion "<-" nicht gefunden
\end{lstlisting}

Mit \lstinline|with()| kann ein Ausdruck (Expression) in einem bestimmten Environment ausgeführt werden, womit es zum Enclosing Environment einer erzeugten Funktion wird.

\lstinline|environment(f) <- env| ändert das Enclosing Environment einer Funktion. Das Enclosing Environment einer Funktion aus einem Package ist in der Regel ein \emph{Namespace-Environment}. Dieses Environment und seine Bindungen sind unveränderlich (locked bindings). Wenn man versucht, das Enclosing Environment einer Paketfunktion zu ändern, wird nicht das Original verändert, sondern es wird eine Kopie der Funktion im aufrufenden Environment angelegt, solange dieses modifizierbar ist.

\begin{lstlisting}
environment(sd)    # <environment: namespace:stats>
e1 <- new.env()
e2 <- new.env()
with(e1, environment(sd) <- e2)
environment(sd)    # <environment: namespace:stats>
environment(e1$sd) # <environment: 0x55a8d83c7308>
e2                 # <environment: 0x55a8d83c7308>
#with(baseenv(), environment(sd) <- baseenv()) ## Error
e1$sd(1:3)         # 1
environment(e1$sd) <- emptyenv()
#e1$sd(1:3)        ## Error, findet sqrt nicht
\end{lstlisting}


\subsubsection{Closure}

Eine Funktion in R setzt sich aus drei Komponenten zusammen:

\begin{description}
\item[Formals (Parameterliste):] Liste der formalen Argumente (formal arguments), die die Funktion erwartet. Sie legen Namen, Reihenfolge, Default-Werte und ggf.\ \lstinline|...| fest. Die Liste kann leer sein (Funktion ohne Parameter).
\item[Body (Funktionskörper):] Der eigentliche auszuführende R-Code.
\item[Enclosing Environment:] Es bestimmt, wo nach nicht-lokalen Variablen gesucht wird, falls sie nicht im \emph{execution environment} gefunden werden. Die Suche läuft dann die Elternkette des Enclosing Environments hinauf.
\end{description}

Die Kombination aus \lstinline|formals()|, \lstinline|body()| und \lstinline|environment()| bildet das, was man in R als \emph{Closure} (oder genauer: Funktions-Closure, first-class function) bezeichnet.
Alle nicht-primitiven Funktionen in R sind Closures. Primitive Funktionen (z.~B. \lstinline|+|) existieren nicht als R-Closures und haben daher kein R-Environment. \lstinline|environment(+)| gibt aus diesem Grund \lstinline|NULL| zurück.

\lstinline|formals()| und \lstinline|body()| unterliegen der \emph{Copy-on-Modify}-Semantik. Zeigen zwei verschiedene Funktionsnamen auf dasselbe Closure, wird bei einer Änderung des Formals ausschließlich eine Kopie des Formals gemacht. Eine Änderung des Bodys führt hingegen derzeit zu einer Kopie des Bodys als auch des Formals.

Environments sind \emph{referenzielle} Objekte und werden nicht kopiert.
Daher können zwei verschiedene Funktionsnamen auf dasselbe Closure verweisen und ihr Enclosing Environment unabhängig voneinander verändern, ohne dass Formals oder Body dupliziert werden.

\begin{itemize}
\item \lstinline|environment(f) <-| nur Environment wird geändert, \emph{keine Kopien}
\item \lstinline|formals(f) <-| oder \lstinline|formals(f)$x <-| \emph{nur Formals} werden kopiert
\item \lstinline|body(f) <-| \emph{sowohl Formals als auch Body} werden kopiert
\end{itemize}

\begin{lstlisting}
x <- 1
g <- \(y=0) x + y  # Enclosing environment ist globalEnv
f <- g
f()          # 1; zeigt x vom globalEnv
g()          # 1; zeigt x vom globalEnv

e <- new.env()
e$x <- 2
environment(f) <- e  # Ändert Enclosing Environment
f()          # 2; zeigt x von e
g()          # 1; zeigt x vom globalEnv
tracemem(formals(f)) == tracemem(formals(g)) # TRUE
tracemem(body(f)) == tracemem(body(g))       # TRUE
identical(environment(f), environment(g))    # FALSE

f <- g
formals(f) <- alist(y = 1)  # Ändert Formals
f()          # 2
g()          # 1
tracemem(formals(f)) == tracemem(formals(g)) # FALSE
tracemem(body(f)) == tracemem(body(g))       # TRUE
identical(environment(f), environment(g))    # TRUE

f <- g
body(f) <- quote(x + 1) # Ändert Body
f()          # 2
g()          # 1
tracemem(formals(f)) == tracemem(formals(g)) # FALSE
tracemem(body(f)) == tracemem(body(g))       # FALSE
identical(environment(f), environment(g))    # TRUE
\end{lstlisting}


\subsubsection{Frames}

Neben den Environments gibt es \emph{Frames} (Rahmen, auch \emph{Evaluation Frame} oder \emph{Call Frame} genannt).

Beim Aufruf einer Funktion wird ein neuer Frame erzeugt und mit einem neuen Execution Environment verknüpft.

Das Parent Environment des Execution Environment ist das mit der aufgerufenen Funktion gebundene Enclosing Environment. Und entlang dieser Kette, startend mit dem Execution Environment über das Enclosing Environment und dessen Parent Environments, werden Namen gesucht.

Der Parent Frame (auch calling frame) des neu erzeugten Frames ist das Frame, in dem der aktuelle Funktionsaufruf stattgefunden hat, also das Frame des Aufrufers.  Damit entsteht eine Kette von Frames die der Kette von Funktionen die Funktionen aufrufen entspricht (\emph{Call-Stack} bzw.\ Aufrufkette).

\lstinline|parent.frame()| liefert das \emph{Execution Environment} des aufrufenden Frames.

\begin{lstlisting}
f <- \(n) {
  if (n > 0) {
    f(n-1)
    e <- environment()  # Execution Environment
    cat("n:", n, " Exec -Env: ", format(e), "\n")
    cat("n:", n, " Par  -Env: ", format(parent.env(e)), "\n")
    cat("n:", n, " Par-Frame: ", format(parent.frame()), "\n")
  }
}
f(2)
# n: 1  Exec -Env:  <environment: 0x55d87016d880> 
# n: 1  Par  -Env:  <environment: R_GlobalEnv> 
# n: 1  Par-Frame:  <environment: 0x55d87016da08> 
# n: 2  Exec -Env:  <environment: 0x55d87016da08> 
# n: 2  Par  -Env:  <environment: R_GlobalEnv> 
# n: 2  Par-Frame:  <environment: R_GlobalEnv> 
\end{lstlisting}

Damit ist es möglich abweichend von der üblichen \emph{lexikalischen}
Namenssuche \emph{dynamisch} entlang der Aufrufkette (Call-Stack)
also den Frames und ihren zugehörigen Execution Environments nach Namen
zu suchen.

Die Funktion \lstinline|dynGet()| sucht dynamisch entlang der Aufruferkette

\begin{lstlisting}
f <- \() {x <- 1; g()}
g <- \() {y <- 2; h()}
h <- \() {
# cat(x)      ## Error, x nicht gefunden
# cat(y)      ## Error, y nicht gefunden
  cat("x:", dynGet("x"))
  cat("  y:", dynGet("y"))
}
f()           # x: 1  y: 2
\end{lstlisting}

Dynamische Suche entlang des Call-Stacks (\lstinline|dynGet()|, \lstinline|parent.frame()|) sollte nach Möglichkeit vermieden werden.
In der Dokumentation (\lstinline|?dynGet|) gibt es die Warung: \emph{Mit Vorsicht verwenden} (Use with caution).

Alternativ empfiehlt es sich, benötigte Variablen aus höheren Scopes
explizit als Funktionsargumente zu übergeben, da dies robust,
nachvollziehbar und klar ist.

\begin{lstlisting}
f <- \() {x <- 1; g(x)}
g <- \(x) {y <- 2; h(x, y)}
h <- \(x, y) {
  cat("x:", x)
  cat("  y:", y)
}
f()           # x: 1  y: 2
\end{lstlisting}


\subsubsection{Infix Operator}

Man kann auch eigene Infix Operatoren definieren. Jeder Operator, dessen Name mit \lstinline|%| beginnt und endet (z.~B. \lstinline|%myop%|), wird als Infix-Operator behandelt und hat in der Regel zwei Argumente.
Benutzerdefinierte Infix-Operatoren der Form \lstinline|%myop%| haben dieselbe Priorität und Assoziativität (links nach rechts) wie die speziellen built-in Operatoren \lstinline|%%|, \lstinline|%/%| oder \lstinline|%in%|. Sie liegen in der Operator-Hierarchie über \lstinline|*| und \lstinline|/|, aber unter dem Sequence-Operator \lstinline|:| (siehe ?Syntax).

\begin{lstlisting}
1 + 1      # 2; + ist Infix Operatoren
`+`(1,1)   # 2; Aufruf als Funktion
`%A%` <- \(l,r) l + r
1 %A% 1    # 2
`%A%`(1,1) # 2

`%M%` <- \(l,r) l * r
1 + 2 * 3      # 7
1 %A% 2 %M% 3  # 9; Wird von links nach recht ausgewertet

4 / 1 %A% 1    # 2; Priorität über /
1 %A% 2^2      # 5; Priorität unter ^
\end{lstlisting}

Durch maskieren von bereits vorhandenen Operatoren kann deren Operatorpriorität verwendet werden.

\begin{lstlisting}
`%E%` <- \(l,r) l^r  # Ausnutzung der Operatorpriorität
`:=` <- \(l,r) l * r  # Priorität: ? < := < %myop%
`?` <- \(l,r) l + r  # Überdeckt ? (help) !
2 + 3 * 4^2          # 50
2 ? 3 := 4%E%2       # 50
rm("?")              # ? (help) nicht mehr überdeckt
\end{lstlisting}


\subsubsection{Active Binding}

Man kann mit der Funktion \lstinline|makeActiveBinding()| sogenannte \emph{active bindings} erzeugen. Dabei wird ein Name in einem Environment mit einer Funktion verknüpft, die bei jedem \emph{Lesezugriff} auf das Symbol aufgerufen wird.

\begin{lstlisting}
makeActiveBinding("rnd", \() runif(1), globalenv())
set.seed(0)
rnd              # 0.8966972
rnd              # 0.2655087
#rnd <- 0        ## Error, unbenutztes Argument
\end{lstlisting}

Hat die zugrunde liegende Funktion \emph{keinen} Parameter, schlägt eine Zuweisung mit \lstinline|<-| oder \lstinline|<<-| fehl.
Der Schreibzugriff versucht nämlich, die Funktion mit dem zugewiesenen Wert als Argument aufzurufen, was zu einem Fehler führt.

Besitzt die Funktion hingegen mindestens einen Parameter, wird dieser beim Schreibzugriff mit dem zugewiesenen Ausdruck belegt. Eine Zuweisung ruft die Binding-Funktion also mit dem zugewiesenen Ausdruck als Argument auf.

\begin{lstlisting}
makeActiveBinding("rnd", \(n=1) cat(runif(n)), globalenv())
set.seed(0)
rnd           # 0.8966972
rnd <- 3      # 0.2655087 0.3721239 0.5728534

e <- new.env()
e$N <- 1
with(e, f <- \(n=1) {
    if (missing(n)) runif(N)
    else N <<- n
})
makeActiveBinding("rnd2", e$f, globalenv())
set.seed(0)
rnd2          # 0.8966972
rnd2 <- 3
rnd2          # 0.2655087 0.3721239 0.5728534
\end{lstlisting}


\subsubsection{on.exit: Aufruf bei Funktionende}

Mit \lstinline|on.exit| können in einer Funktion Aktionen registriert
werden, die beim Verlassen der Funktion garantiert ausgeführt werden,
unabhängig davon, ob sie regulär endet oder durch einen Fehler
abgebrochen wird. Der Code in \lstinline|on.exit()| wird ausgeführt,
bevor die Funktion verlassen wird. Also vor der Rückgabe des
Ergebnisses an den Aufrufer und vor der Anzeige des Rückgabewerts in
der interaktiven Konsole.

\begin{lstlisting}
f <- \(x) {
  on.exit(cat("EXIT: "))
  if (x < 0) stop("Error")
  x + 1
}
f(0)       # EXIT: [1] 1
f(-1)      # Fehler in f(-1) : Error, EXIT:

g <- \() {
  on.exit(cat(" E0"))
  on.exit(cat(" E1"))  # Ersetzt vorheriges
}
g()        # E1

h <- \() {
  on.exit(cat(" E0"))
  on.exit(cat(" E1"), add = TRUE)
  on.exit(cat(" E2"), add = TRUE, after = FALSE)
}
h()        # E2 E0 E1

F <- \() {on.exit({stop("Error in Exit"); cat("Ende")}); 0}
F()        # Fehler in F() : Error in Exit
\end{lstlisting}


\subsection{Organisation von Environments zur Namensauflösung}

Namen werden zunächst im aktuellen Auswertungs-Environment (Execution Environment) gesucht. Werden sie dort nicht gefunden, wird die Suche im Parent Environment fortgesetzt, anschließend im Parent des Parent Environments usw. Die Namenssuche endet entweder mit dem Auffinden des Namens oder beim Erreichen des leeren Environments (\lstinline|emptyenv()|).

Man kann die Suche auch explizit in einem bestimmten Environment starten (z.\,B. mit \lstinline|get()| oder \lstinline|assign()|), allerdings muss das Environment-Objekt selbst zuvor über die normale Namenssuche verfügbar sein.

Ähnlich ist es beim Aufruf einer Funktion. Dabei muss zunächst deren Name gefunden werden. Beim Start der Funktion wird ein temporäres Auswertungs-Environment (Execution Environment) erzeugt in dem die, in der Funktion verwendeten, Namen gesucht werden. Die Suche wird anschließend im Parent dieses Environments fortgesetzt, dem sogenannten Enclosing Environment der Funktion, und danach in dessen Parent-Environments.

Bei interaktiver Arbeit in der Konsole sowie beim Start eines Skripts beginnt die Namensauflösung im globalen Environment (\lstinline|.GlobalEnv|). Ist der Name dort nicht vorhanden, wird die Suche in der dem \lstinline|.GlobalEnv| folgende Environmentkette fortgesetzt, welche mit \lstinline|search()| (Suchpfad) angezeigt werden kann.

Zusätzlich besitzen Packages eigene Namespaces. Exportierte Namen können über \lstinline|::| (z.\,B. \lstinline|stats::sd|) direkt aus dem Namespace referenziert werden, ohne den Suchpfad zu durchlaufen.

Namespaces existieren unabhängig vom Suchpfad. Der Suchpfad baut auf Namespaces auf und macht deren Objekte über seine Namenssuche zugänglich.


\subsubsection{Namespace (Namensraum)}

Ein Namespace dient in R dazu, die Umgebung eines Pakets klar von anderen Paketen und vom globalen Arbeitsbereich zu trennen. Er definiert, welche Objekte eines Pakets nach außen sichtbar exportiert werden und welche intern bleiben, schützt vor Namenskonflikten zwischen gleichlautenden Funktionen verschiedener Pakete und legt fest, welche Funktionen aus anderen Paketen importiert werden. Darüber hinaus ist der Namespace üblicherweise das Enclosing Environment für die Paketfunktionen, wodurch diese auf interne Objekte des Pakets zugreifen können.

Üblicherweise ist hier die Environment-Kette so aufgebaut:
\lstinline|namespace:env| =>
\lstinline|imports:env| =>
\lstinline|namespace:base| =>
\lstinline|R_GlobalEnv|, \dots

Wichtige Funktionen sind:

\begin{itemize}
\item \lstinline|loadedNamespaces()|: zeigt alle geladenen Namespaces.
\item \lstinline|loadNamespace("pkg")| bzw.\ \lstinline|requireNamespace("pkg")|: lädt den Namespace.
\item \lstinline|getNamespace("pkg")| und \lstinline|asNamespace("pkg")|: liefert das Namespace-Environment (lädt es bei Bedarf).
\item \lstinline|unloadNamespace("pkg")|: Entfernt den Namespace solange er nicht noch von anderen geladenen Namespaces importiert wurde.
\item \lstinline|getNamespaceUsers("pkg")| Zeigt Pakete die pkg importiert haben
\item \lstinline|getNamespaceImports("pkg")| Zeigt welche Pakete pkg importiert
\item \lstinline|ls(getNamespace("pkg"), all.names = TRUE)| zeigt alle und \lstinline|getNamespaceExports("pkg")| die exportierten Namen eines Namespaces.
\end{itemize}

\lstinline|requireNamespace()| gibt TRUE/FALSE zurück und bricht nicht ab, wenn das Paket fehlt, während \lstinline|loadNamespace()| das Namespace-Objekt zurückgibt und mit einem Fehler abbricht, wenn das Paket nicht gefunden wird.

Nach dem Laden eines Namespace steht das \emph{Namespace-Environment (namespace:pkg)} zur Verfügung. Es enthält \emph{alle} Funktionen und Variablen des Pakets, auch interne, nicht-exportierte. Es ist das Enclosing Environment fast aller exportierten Funktionen.

Auf Namen dieser Environments kann man mit \lstinline|::| bzw.\ \lstinline|:::| zugreifen.

\begin{itemize}
\item \lstinline|pkg::name|: Greift auf \emph{exportierte} Objekte im Namespace zu.
\item \lstinline|pkg:::name|: Greift auf \emph{alle} Objekte im Namespace zu, auch interne.
\end{itemize}

Beide Operatoren laden den Namespace automatisch, falls dieser noch nicht geladen wurde und suchen nur im Namespace des angegebenen Pakets. Sie folgen \emph{keiner} Environment-Kette.

\begin{lstlisting}
loadedNamespaces()  # Bei Start von R automatisch geladene Pakete
# compiler graphics utils grDevices stats datasets methods base

loadNamespace("splines")     # Lädt splines
requireNamespace("splines")  # Alternative
"splines" %in% loadedNamespaces()  # TRUE
unloadNamespace("splines")   # Entfernt splines
"splines" %in% loadedNamespaces()  # FALSE

splines::bs     # Lädt Namespace automatisch
"splines" %in% loadedNamespaces()  # TRUE
#bs             ## Error, nicht gefunden

getNamespaceExports("splines")  # Zeigt exportierte Namen
ls(getNamespace("splines"), all.names = TRUE) # Zeigt alle

stats:::sd(1:3)                    # 1
getNamespace("stats")$sd(1:3)      # 1; Ähnlich wie :::
asNamespace("stats")$sd(1:3)       # 1; Ähnlich wie :::

#unloadNamespace("stats")  ## Error, auch von splines importiert
getNamespaceUsers("stats") # splines
unloadNamespace("splines")
unloadNamespace("stats")
#unloadNamespace("base")   ## Error, bei base nicht erlaubt
\end{lstlisting}

Funktionen beginnen ihre Namenssuche \emph{immer} im Execution Environment, gefolgt von deren Enclosing Environment und dessen Parent Kette. Das Enclosing Environment einer Paket Funktion ist in der Regel der Namespace des Pakets.

\begin{lstlisting}
environment(stats::sd)  # <environment: namespace:stats>
getNamespace("stats")   # <environment: namespace:stats>
\end{lstlisting}

Um Funktionen anderer Pakete im eigenen Paket verwenden zu können, wird der Namespace dieser Pakete im eigenen Paket importiert.

\begin{lstlisting}
names(getNamespaceImports("stats"))
# base graphics grDevices utils
\end{lstlisting}

Das Environment in dem die NamespaceImports eingetragen sind ist das Parent Environment des Paket Namespace.

\begin{lstlisting}
(e <- getNamespace("stats"))  # namespace:stats
(e <- parent.env(e))          # imports:stats
\end{lstlisting}

In diesem \lstinline|imports| Environment sind alle Funktionen fremder Pakete eingetragen.

\begin{lstlisting}
getNamespaceImports("stats")  # Zeigt alle importierten Funktionen
nn <- unlist(getNamespaceImports("stats")[-1])
e <- parent.env(getNamespace("stats")) # imports:stats
ne <- ls(e, all.names = TRUE) # Alle Namen in e
setdiff(ne, nn)               # character(0)
setdiff(nn, ne)               # character(0)
\end{lstlisting}

Darauf folgt \lstinline|namespace:base|, anschließend \lstinline|R_GlobalEnv|, und die Parent-Kette setzt sich bis \lstinline|base| fort, bevor sie im \lstinline|R_EmptyEnv| endet.

\begin{lstlisting}
(e <- getNamespace("stats")) # namespace:stats
(e <- parent.env(e))         # imports:stats
(e <- parent.env(e))         # namespace:base
(e <- parent.env(e))         # R_GlobalEnv
(e <- parent.env(e))         # package:stats
# ...
(e <- parent.env(e))         # base
(e <- parent.env(e))         # R_EmptyEnv
\end{lstlisting}


\subsubsection{Suchpfad}

Während Namespaces die interne Organisation und Kapselung von Paketobjekten regeln, beschreibt der Suchpfad die externe Reihenfolge der Environments, die R bei der Namensauflösung berücksichtigt. Er bestimmt somit, welche Objekte für den Benutzer direkt sichtbar und referenzierbar sind.

Die dem \lstinline|.GlobalEnv| folgende Parent-Environmentkette wird als Suchpfad (search path) bezeichnet. Er umfasst typischerweise die Environments der geladenen und angehängten Pakete (attached packages) welche mit (\lstinline|package:base|) abgeschlossen wird.

Bis auf das \lstinline|.GlobalEnv| dienen alle folgenden Parent-Environments dieser Environment-Kette der Namenssuche, sind also im Gegensatz zu einem Namespace-Environment üblicherweise kein Enclosing-Environment von Funktionen. Eine Veränderung des Parent-Environments dient dazu ihre Position im Suchpfad und damit ihre Sichtbarkeit gegenüber anderen Environments zu verändern.

Um die Eigenschaften eines vorhandenen Environments nicht zu verändern, also dessen Parent-Environment und der damit verbundenen Namenssuche sowie die darin enthaltenen Namen und Bindungen, sind Environments im Suchpfad entweder Kopien (Lists, Dataframes, Environments) oder dedizierte Package-Environments (\lstinline|package:env|), die die exportierten Bindings des zugehörigen Namespace-Environments enthalten.

Es werden also die Bindungen (Namen und Verweise auf die Objekte) aus dem Original übernommen. Dieses neue Environment wird dann in den Suchpfad eingefügt. Die Werte der Objekte werden dabei referenziert (nicht kopiert), sodass zunächst auf dieselben Daten zugegriffen wird. Nachträgliche Änderungen am Original-Environment haben \emph{keinen} Effekt auf das attached Environment und umgekehrt sondern lösen ein Copy on Modify aus.

Mit \lstinline|search()| wird der Suchpfad angezeigt. Mit \lstinline|searchpaths()| erhält man die vollständigen Dateipfade zu den geladenen Paketen. Beim Start von R werden einige Standardpakete bzw.\ Libraries automatisch geladen. Dadurch stehen deren Funktionen und Daten zur Verfügung. Folgende Pakete stehen bei einem Neustart von R zur Verfügung:

\begin{lstlisting}
search()
# ".GlobalEnv"        "package:stats"     "package:graphics"
# "package:grDevices" "package:utils"     "package:datasets"
# "package:methods"   "Autoloads"         "package:base"

searchpaths()
# ".GlobalEnv" "/usr/local/lib/R/library/stats" ...
\end{lstlisting}

Deren Reihenfolge ist entscheidend. Die Suche erfolgt strikt von vorne nach hinten, d.\,h.\ ein Name in einem Environment maskiert gleiche Namen in nachfolgenden Environments. Dieser Mechanismus ermöglicht eine einfache Nutzung von Funktionen und Daten, birgt jedoch das Risiko von Namenskonflikten (masking), welches bei Verwendung von \lstinline|paket::funktion()| über den Namespace von Paketen umgangen werden kann. Mit \lstinline|as.environment()| kann man auch über den im Suchpfad angegeben Environmennamen auf dieses direkt zugreifen ohne den Suchpfad zu durchwandern.

Dabei geht es zunächst einmal darum welcher Name gefunden wird. Wenn es sich um Daten handelt werden diese zurückgeliefert. Ist es hingegen eine \emph{Funktion}, ist diese mit einem \emph{Enclosing Environment} verbunden und bestimmt damit selbst wo sie, nachdem sie aufgerufen wurde, ihre Namen (Daten und weitere Funktionen) sucht.

Beispielsweise verwendet die Funktion \lstinline|sd| die Funktion \lstinline|sqrt|. Wenn sich der Name \lstinline|sqrt| im \lstinline|.GlobalEnv| befindet wird dieser von der Konsole aus gefunden. Die Funktionalität von \lstinline|sd| wird dadurch jedoch nicht beeinflusst, da \lstinline|sd| die Namenssuche nicht im \lstinline|.GlobalEnv| beginnt.

\begin{lstlisting}
sqrt(4)         # 2
find("sqrt")    # package:base
sd(1:3)         # 1
sqrt <- \(x) 0  # Eigene Funktion mit Namen sqrt
find("sqrt")    # .GlobalEnv, package:base
sqrt(4)         # 0
sd(1:3)         # 1
find("sd")      # package:stats
sd <- sd        # legt weitere Bindung im .GlobalEnv an
find("sd")      # .GlobalEnv package:stats
environment(sd) # <environment: namespace:stats>
environment(sd) <- globalenv() # Ändert Enclosing Environment
sd(1:3)         # 0; Dieses sd findet eigene sqrt Funktion
stats::sd(1:3)  # 1; Verwendet Namespace
as.environment("package:stats")$sd(1:3) # 1; über Suchpfadnamen
rm(sqrt)        # Entfernt sqrt aus .GlobalEnv
find("sqrt")    # package:base
sd(1:3)         # 1; Verwendet sqrt in base
\end{lstlisting}


\paragraph{Suchpfadmodifikation}

\subparagraph{Paket}

\lstinline|library("pkg")| bzw.\ \lstinline|require("pkg")| lädt den Namespace (namespace:pkg) und hängt das Package-Environment (package:pkg) mit den exportierten Objekten in den Suchpfad.
\lstinline|require()| gibt TRUE/FALSE zurück und bricht nicht ab, während \lstinline|library()| mit einem Fehler abbricht, wenn das Paket nicht gefunden wird.

Wenn ein Paket mit \lstinline|library()| oder \lstinline|require()| geladen wird, erscheint es standardmäßig direkt hinter \lstinline|.GlobalEnv| im Suchpfad, sofern es nicht bereits geladen ist.
Mit \lstinline|library(PKG, pos = POSITION)| lässt sich die Einfügeposition gezielt steuern. 
Ein Paket kann dabei weder vor \lstinline|.GlobalEnv| noch hinter \lstinline|package:base| platziert werden.

\lstinline|unloadNamespace()| bzw.\ \lstinline|detach("package:pkg", unload = TRUE)| entlädt das ganze Paket sowohl aus dem Suchpfad als auch aus dem Namespace während \lstinline|detach("package:pkg")| nur das Environment aus dem Suchpfad entfernt wohin es mit \lstinline|attachNamespace()| wieder gebracht werden kann.

\begin{lstlisting}
library(compiler)
search() # ".GlobalEnv" "package:compiler" "package:stats"
library(tools)
search() # ".GlobalEnv" "package:tools" "package:compiler"
library(compiler)            # Bleibt an Position
search() # ".GlobalEnv" "package:tools" "package:compiler"
unloadNamespace("compiler")  # Entlädt Paket
#detach("package:compiler", unload = TRUE) # Alternative
library(compiler)            # Jetzt ganz vorne
search() # ".GlobalEnv" "package:compiler" "package:tools"
unloadNamespace("compiler")
library(compiler, pos = length(search())) # vor base
search() # ".GlobalEnv" ... "package:compiler" "package:base"

detach("package:compiler")   # Entfernt nur aus Suchpfad
loadedNamespaces()           # compiler enthalten
search()                     # ohne package:compiler
attachNamespace("compiler")
search()                     # mit package:compiler
\end{lstlisting}


\subparagraph{Environment und Liste}

Mit \lstinline|attach()| kann man \emph{Kopien} von eigene Environments, Listen oder Dataframes in den Suchpfad bringen und mit \lstinline|detach()| wieder entfernen. Änderungen mit \lstinline|<<-| betreffen die Kopie und nicht das Original.

\begin{lstlisting}
e <- new.env()
e$x <- 0
#x                        ## Error, nicht gefunden
attach(e, name = "meinEnv")
x                         # 0

e                         # <environment: 0x559e3925da70>
as.environment("meinEnv") # <environment: 0x559e3925cd18>
parent.env(e)             # <environment: R_GlobalEnv>
parent.env(as.environment("meinEnv")) # package:stats
tracemem(x)               # <0x559e39218608>
tracemem(e$x)             # <0x559e39218608>
tracemem(as.environment("meinEnv")$x)
                          # <0x559e39218608>
x <- 1                    # Erzeugt x im .GlobalEnv
x                         # 1
e$x                       # 0
as.environment("meinEnv")$x # 0
rm(x)           # Entfernt x aus .GlobalEnv
x <<- 1                     # findet x in meinEnv
x                           # 1
as.environment("meinEnv")$x # 1
e$x                         # 0
e$x <- 2
x                           # 1
as.environment("meinEnv")$x # 1

search()        # ".GlobalEnv" "meinEnv" ...
detach("meinEnv")
attach(e, pos = length(search()), name = "meinEnv")
search() # ".GlobalEnv" ... "meinEnv" "package:base"

detach("package:stats")   # Kann auch ausgehängt werden
#detach(".GlobalEnv")     ## Error
#detach("package:base")   ## Error
\end{lstlisting}


\subsection{Pakete -- Libraries}

Pakete enthalten Funktionen und Daten und können damit die Funktionalität von R erweitern. Pakete werden meist mit \lstinline|library()| oder \lstinline|require()| geladen.

Beim Laden eines Pakets wird dessen Namespace geladen, der ein eigenes
Namespace--Environment besitzt. Dessen Parent ist das Imports--Environment,
welches die importierten Bindungen aus anderen Paketen enthält. Zusätzlich
wird ein Package--Environment erzeugt, das die exportierten Namen enthält und
in den Namenssuchpfad eingehängt wird.

Im Package--Environment befinden sich ausschließlich die exportierten Namen,
während im Namespace--Environment alle Namen des Pakets enthalten sind.

Im Imports--Environment befinden sich Namensbindungen zu Funktionen und Daten
anderer Pakete, die über \lstinline|Imports| oder \lstinline|import()| im
\lstinline|NAMESPACE| eingebunden wurden und im Paket ohne explizite Verwendung
von \lstinline|::| genutzt werden können.

Auf exportierte Namen in Paketen kann man mit \lstinline|::| zugreifen unabhängig davon ob sie im Suchpfad eingetragen sind. Der Zugriff erfolgt über das Namespace--Environment des Pakets, welches, falls es noch nicht geladen wurde, mit \lstinline|::| geladen wird. Mit \lstinline|:::| kann man auf alle, also auch die nicht exportierten Namen eines Paketes zugreifen.

\begin{lstlisting}
compiler::cmpfun(sum)  # Zugriff auf exportierte Funktion 
compiler:::asm         # Zugriff auf interne Funktion 
\end{lstlisting}

\lstinline|library()| bzw.\ \lstinline|installed.packages()| listet alle installierten Pakete auf.
Pakete mit Priority = \lstinline|base| oder \lstinline|recommended| werden bei jeder R-Installation standardmäßig mitgeliefert.
Base-Pakete gehören zum R-Core und haben stets dieselbe Versionsnummer wie die R-Installation selbst.
Recommended-Pakete sind nicht Teil des Core und können unabhängig von der R-Version aktualisiert, entfernt oder neu installiert werden.

\begin{lstlisting}
names(which(installed.packages()[,"Priority"]=="base"))
# base      compiler  datasets  graphics  grDevices grid     
# methods   parallel  splines   stats     stats4    tcltk    
# tools     utils    

names(which(installed.packages()[,"Priority"]=="recommended"))
# boot       class      cluster    codetools  foreign   
# KernSmooth lattice    MASS       Matrix     mgcv      
# nlme       nnet       rpart      spatial    survival  
\end{lstlisting}

Pakete kann man mit \lstinline|update.packages()| aktualisieren, mit
\lstinline|install.packages()| neu installieren, mit
\lstinline|remove.packages()| entfernen und mit
\lstinline|find.package()| suchen.
Alle bereits installierten Pakete können erneut installieren mit:
\begin{lstlisting}
. <- installed.packages()[,"Priority"]
install.packages(names(.[is.na(.) | . != "base"]))
\end{lstlisting}

Pakete auf GitHub können mit \lstinline|remotes::install_github("USER/REPO")|, bestimmte Branches, Tags oder Commits mit \lstinline|remotes::install_github("USER/REPO@BRANCH")| installiert werden.

Die Hilfe zu einem Paket erhält man mit \lstinline|library(help = "pkg")| und alle exportierten Funktionen mit \lstinline|getNamespaceExports("pkg")|.

Ein einfaches R-Paket lässt sich nach folgendem Muster erstellen.
Das Beispiel demonstriert den minimal notwendigen Paketaufbau mit
\lstinline|DESCRIPTION| und \lstinline|NAMESPACE|, den Umgang mit
exportierten und nicht exportierten Objekten im Namespace, die Einbindung
von Abhängigkeiten sowie die Erstellung von Dokumentation und Datensätzen.
Abschließend wird der Build-- und Installationsprozess über
\lstinline|R CMD build| und \lstinline|R CMD INSTALL| gezeigt.

\begin{lstlisting}
# Temporäres Package-Verzeichnis anlegen
pkgDir <- tempfile("meinPkg")
dir.create(file.path(pkgDir, "R"), recursive = TRUE)

# Eine minimale DESCRIPTION und NAMESPACE-Datei
writeLines('Package: meinPkg
Version: 0.0.1
Title: Test
Description: Nur zum Testen
Encoding: UTF-8
Authors@R: c( person("Ich", "Nachname",
   email = "ich@home.at", role = c("aut", "cre")),
 person("Du", "Nachname", role = "ctb") )
URL: https://github.com/ich/meinPkg
BugReports: https://github.com/ich/meinPkg/issues
License: GPL-3
Imports: stats
Depends: R (>= 4.1.0)
LazyData: true', file.path(pkgDir, "DESCRIPTION"))

writeLines('export(x, f, g)
importFrom(stats, rnorm)', file.path(pkgDir, "NAMESPACE"))

# Eine R-Datei mit Inhalt
writeLines(r"(x <- 1
y <- 2
f <- \(n=1) rnorm(n)
g <- \(n=1) stats::runif(n)  # explizit ohne Import
)", file.path(pkgDir, "R", "xyz.R"))

# Dokumentation
dir.create(file.path(pkgDir, "man"), recursive = TRUE)
writeLines(r"(
\name{f}
\alias{f}
\title{Zufallszahlen erzeugen}
\description{
Die Funktion \code{f} erzeugt normalverteilte Zufallszahlen
unter Verwendung von \code{stats::rnorm}.
}
\usage{
f(n = 1)
}
\arguments{
  \item{n}{Anzahl der Zufallszahlen.}
}
\value{
Ein numerischer Vektor der Länge \code{n}.
}
\examples{
f()
f(5)
}
)", file.path(pkgDir, "man", "f.Rd"))

# Daten
dat <- data.frame(id = 1:3, value = 3:1)
dir.create(file.path(pkgDir, "data"), recursive = TRUE)
save(dat, file = file.path(pkgDir, "data", "dat.rda"),
  compress = "xz" )
rm(dat)
  
writeLines(r"(
\name{dat}
\alias{dat}
\docType{data}
\title{Beispieldatensatz}
\description{
Ein kleiner Beispieldatensatz mit IDs und Zahlen.
}
\format{
Ein data.frame mit 3 Zeilen und 2 Variablen:
\describe{
  \item{id}{Ganzzahlige ID.}
  \item{value}{Zahlen.}
}
}
\usage{
dat
}
)", file.path(pkgDir, "man", "dat.Rd"))

# Package Installieren
system2( file.path(R.home("bin"), "R"),
  c("CMD", "INSTALL", shQuote(pkgDir)) )

library(meinPkg)

x               # 1
meinPkg::x      # 1
meinPkg:::x     # 1
#y              ## y nicht gefunden
#meinPkg::y     ## Error nicht exportiert
meinPkg:::y     # 2
set.seed(0)
f()             # 1.262954
g()             # 0.3721239
?f              # Zeigt Hilfe an
?meinPkg::f     # Zeigt Hilfe an
dat             # direkt verfügbar (LazyData: true)
data(dat, package = "meinPkg") # Ohne LazyData
?dat            # Hilfe zu daten

# Tar Datei des Pakets erzeugen
# R CMD build [Verzeichnis]
## R CMD check [Verzeichnis] # Zeigt eventuelle Fehler
system2(
  file.path(R.home("bin"), "R"),
  c("CMD", "build", shQuote(pkgDir)) )
# tar kann in der Shel mit: R CMD INSTALL [PAKET.tar.gz]
# oder in R mit: install.packages("[PAKET.tar.gz]", repos =NULL)
# Installiert werden
install.packages("meinPkg_0.0.1.tar.gz", repos = NULL)
\end{lstlisting}


\subsection{Objektorientierung}

In R können Funktionen abhängig von der Klasse ihrer Argumente unterschiedliches Verhalten zeigen.


\subsubsection{S3-Klassen}

Ein S3-Objekt ist ein beliebiges R-Objekt (z.\,B. Vektor oder Liste), dem ein Klassenattribut zugewiesen wird.  Methoden werden durch Funktionsnamen mit Punktnotation definiert, wobei es hiervon Ausnahmen gibt (\lstinline|t.test|, \lstinline|data.frame|), bei denen dies keine Methoden für die Klasse \lstinline|test| oder \lstinline|frame| sind.  In S3 gibt es keine explizite Klassendefinition.  Eine Klasse entsteht allein durch das Setzen des \lstinline|class|-Attributs.

Beim Aufruf einer generischen Funktion bestimmt R anhand des \lstinline|class|-Attributs üblicherweise des ersten Arguments, welche Methode (\lstinline|generic.classname|) aufgerufen wird. Existiert keine passende Methode, wird \lstinline|generic.default| verwendet.

Mit \lstinline|inherits()| kann man prüfen ob eine Klasse enthalten ist.

Bei der Funktionsauswahl findet keine Typprüfung statt. Objekte unterschiedlichen Basis-Typs (z.\,B.\ \lstinline|character| und \lstinline|numeric|) können dieselbe Klasse zugewiesen bekommen und verzweigen aufgrund der Klasse zur selben Funktion. Diese Typprüfung könnte bei der Erzeugung der Klasse, durch eine selbst geschriebene Funktion, erfolgen.

\lstinline|methods(generic)| zeigt, für welche Klassen Methoden im Suchpfad verfügbar sind. \lstinline|methods(class = "classname")| zeigt welche spezialisierten Funktionen für eine Klasse existieren.

\begin{lstlisting}
f <- \(x) UseMethod("f")  # generische Funktion definieren
f.a <- \(x) "A"           # Methode für Klasse a
f.b <- \(x) "B"           # Methode für Klasse b
f.default <- \(x) "Def"   # Alle anderen Klassen
methods(f)                # f.a f.b f.default
methods(class = "a")      # f

x <- 0
f(x)                      # Def
class(x) <- "a"
f(x)                      # A
class(x) <- "b"
f(x)                      # B
class(x) <- "x"
f(x)                      # Def

class(x) <- c("a", "b")
f(x)                      # A
class(x) <- c("b", "a")
f(x)                      # B
class(x) <- c("x", "a")
f(x)                      # A
inherits(x, "a")          # TRUE
inherits(x, "b")          # FALSE

newA <- \(x) structure(x, class="a")  # Konstruktor
newB <- \(x) structure(x, class="b")
x <- newA(1)
f(x)                      # A
f(newB(2))                # B

f <- \(x, y) UseMethod("f", y)  # Auswahl anhand des zweiten
f.a <- \(x, y) "A"
f.default <- \(x, y) "Def"
x <- structure(0, class="a")
f(x, 0)                   # Def
f(0, x)                   # A

g <- \(x, y) {            # Auswahl über beide
  ux <- unique(class(x))  #  Manual Double Dispatch
  ux <- setNames(seq_along(ux), ux)
  uy <- unique(class(y))
  uy <- setNames(seq_along(uy), uy)
  . <- expand.grid(ux[class(x)], uy[class(y)])
  . <- .[order(pmax(.[,1], .[,2]), .[,1], .[,2]),]
  . <- paste(names(ux)[.[,1]], names(uy)[.[,2]], sep="_")
  class(x) <- unique(c(., class(x), class(y)))
  UseMethod("g", x) }
g.a_b <- \(x, y) c(x, y, "AB")
g.default <- \(x, y) "Def"
x <- structure(0, class="a")
y <- structure(1, class="b")
g(x, y)                   # 0 1 AB
g(x, x)                   # Def
g(y, y)                   # Def
x <- structure(0, class=c("x", "a"))
y <- structure(1, class=c("y", "b"))
g(x, y)                   # 0 1 AB
\end{lstlisting}

Die Klassenreihenfolge in \lstinline|class(x)| entspricht einer einfachen Form von Vererbung. Mit \lstinline|NextMethod()| kann innerhalb einer S3-Methode die nächste passende Methode gemäß der Klassenreihenfolge aufgerufen werden, wodurch spezialisiertes Verhalten schrittweise erweitert werden kann. \lstinline|NextMethod()| kann nur innerhalb einer S3-Methode verwendet werden und ruft keine rekursive Methode, sondern die nächste Klasse in der Klassen-Reihenfolge auf.

\begin{lstlisting}
f <- \(x) UseMethod("f")
f.a <- \(x) {x <- x+1; c("A", x, NextMethod())}
f.b <- \(x) {x <- x-1; c("B", x, NextMethod())}
f.default <- \(x) c("Def", x)

x <- 0
class(x) <- "a"
f(x)                     # A 1 Def 1
class(x) <- c("b", "a", "b")
f(x)                     # B -1 A 0 B -1 Def -1
\end{lstlisting}

In eigenen Paketen sollten Klassen mit Präfix (z.\,B.\ mypkg\_myclass) benannt werden, um Kollisionen zu vermeiden.


\subsubsection{S4-Klassen}

In S4 werden Klassen explizit definiert, der Typ (\lstinline|character|, \lstinline|numeric|, \dots) wird überprüft und die Funktionsauswahl kann über mehrere Argumente erfolgen.

Eine S4-Klasse wird mit \lstinline|setClass| definiert. Dabei werden die enthaltenen Slots (Attribute) sowie deren Typen explizit angegeben. Objekte einer S4-Klasse werden mit \lstinline|new| erzeugt.

Es ist nicht möglich, beliebige Attribute hinzuzufügen oder inkonsistente Objekte zu erzeugen. S4 erzwingt die Einhaltung der definierten Klassenstruktur.

Ein direkter Slot-Zugriff ist mit \lstinline|@| möglich, sollte jedoch nach Möglichkeit mittels selbst geschriebene Zugriffsfunktionen erfolgen.

\lstinline|showClass| gibt eine kompakte, menschenlesbare Übersicht einer Klassendefinition aus.
\lstinline|getClass| liefert die vollständige Klassendefinition als Objekt der Klasse \lstinline|formalClass| und eignet sich für programmatische Auswertung.
\lstinline|getClassDef| verhält sich ähnlich wie \lstinline|getClass|, gibt jedoch \lstinline|NULL| zurück, falls die Klasse nicht existiert.

\begin{lstlisting}
setClass("A", slots = list(x = "numeric"))
showClass("A")            # Info zur Klasse
x <- new("A", x = 1)
x@x                       # 1
#x <- new("A", 1)         ## Error, kein Name
#x <- new("A", y=1)       ## Error, unzulässiger Name
#x <- new("A", x = "a")   ## Error, falscher Typ
x <- new("A")
x@x                       # numeric(0)
\end{lstlisting}

Man kann auch die Slot Inhalte mit \lstinline|validity| überprüfen und Default-Werte mit \lstinline|prototype| vergeben. Validiert wird nur bei \lstinline|new()| oder explizitem Aufruf von \lstinline|validObject()|. Also z.\,B.\ nicht bei \lstinline|@<-|.

\begin{lstlisting}
setClass("A", slots = list(x = "numeric", y = "numeric"),
  validity = \(object)
    if (object@x > 0 && object@y > 0) TRUE else "Nicht > 0")
x <- new("A", x = 1, y = 1)
#y <- new("A", x = 1, y = 0)  ## Error, Nicht > 0

setClass("B", slots = list(x = "numeric"),
  prototype = list(x = 42) )
y <- new("B")
y@x                           # 42
\end{lstlisting}

S4 verwendet generische Funktionen mit expliziter Methodendeklaration. Eine generische Funktion wird mit \lstinline|setGeneric| definiert, wobei die Signatur festlegt, über welche Argumente die Funktionsauswahl erfolgt.

Methoden werden mit \lstinline|setMethod| für konkrete Klassenkombinationen definiert.

Die Methodenauswahl erfolgt anhand der Klassen aller in der Signatur angegebenen Argumente. Existiert keine passende Methode, wird ein Fehler ausgelöst. Eine Default-Methode kann mittels Typ \lstinline|ANY| definiert werden.

Mit \lstinline|showMethods()| kann man alle Methoden einer Funktion anzeigen. \lstinline|getMethod()| zeigt eine konkrete Methode mit den entsprechenden Argumenten.

\begin{lstlisting}
setClass("A", slots = list(x = "integer"))

setGeneric("f", \(x, y) standardGeneric("f"))

setMethod("f",
  signature(x = "A", y = "numeric"),
  \(x, y) {x@x - y} )

a <- new("A", x = 2L)
f(a, 1)              # 1
#f(2L, 1)            ## Error, keine Methode gefunden

setMethod("f",
  signature(x = "ANY", y = "numeric"),
  \(x, y) c(x,  y) )
f(2L, 1)             # 2 1
f("x", 1)            # x 1

setMethod("f",
  signature(x = "missing", y = "numeric"),
  \(x, y) y * 2 )
f(y=3)

setMethod("f",
  signature(x = "missing", y = "missing"),
  \() 7  # wird in eine Funktion mit x und y eingefügt
# \(x, y) 7  # Besser explizit
)
getMethod("f", signature(x = "missing", y = "missing"))
# function (x, y) { .local <- \() 7; .local() }
# Statt: function (x, y) 7

setMethod("f",
  signature(),  # ANY wird automatisch eingefügt
# signature(x = "ANY", y = "ANY"), # Besser explizit
  \(x, y) c(x, y)
)
getMethod("f", signature(x = "ANY", y = "ANY"))
# function (x, y) c(x, y)

setGeneric("getX", function(x) standardGeneric("getX"))
setMethod("getX", "A", \(x) x@x) # Accessor-Funktion
getX(a)              # 2

setGeneric("setX<-",
           function(x, value) standardGeneric("setX<-"))
setMethod("setX<-", "A", \(x, value) {
  x@x <- value
  validObject(x)
  x
})
setX(a) <- 3L

showMethods("f")    # Zeigt alle Methoden von f
\end{lstlisting}

S4 unterstützt Vererbung durch das Argument \lstinline|contains| bei der Klassendefinition. Abgeleitete Klassen erben Slots und Methoden ihrer Basisklassen.

Slots können selbst S4-Klassen sein, was komplexe, geschachtelte Datenstrukturen ermöglicht (Komposition). Im Gegensatz dazu definiert \lstinline|contains| eine \textit{is-a}-Beziehung (Vererbung).

Mit \lstinline|is()| kann man prüfen ob ein Objekt einer Klasse angehört. Mit \lstinline|as()| kann man in eine andere Klasse umwandeln.

Methoden für Basisklassen sind automatisch auch für abgeleitete Klassen gültig, sofern keine speziellere Methode existiert.

\lstinline|callNextMethod()| ruft die nächstweniger spezifische Methode in der Methodenhierarchie auf.

\begin{lstlisting}
setClass("A", slots = list(x = "integer"))
setClass("B", contains = "A", slots = list(y = "numeric"))
setClass("C", contains = c("A", "B"))  # Mehrfachvererbung

setGeneric("f", \(x) standardGeneric("f"))
setMethod("f", signature(x = "A"), \(x) x@x)

a <- new("A", x = 1L)
b <- new("B", x = 2L, y = 3)

is(a, "A")        # TRUE
is(b, "A")        # TRUE
is(a, "B")        # FALSE
is(b, "B")        # TRUE

as(b, "A")        # Wandelt in Klasse A um

f(a)              # 1
f(b)              # 2; Methode der Basisklasse

setMethod("f", signature(x = "B"), \(x) x@x + 1)
f(b)              # 3; Methode der eigenen Klasse

setMethod("f", signature(x = "B"), \(x) callNextMethod() + 2)
f(b)              # 4; Methode für B ruft Methode für A auf
\end{lstlisting}

S3-Klassen kann man mit \lstinline|setOldClass()| nach S4 übernehmen. Für Basisobjekte wie \lstinline|data.frame| ist \lstinline|setOldClass()| in der Regel bereits durchgeführt.

Virtuelle Klassen dienen als abstrakte Basisklassen, von denen keine Instanzen erzeugt werden.

\begin{lstlisting}
setGeneric("f", \(x) standardGeneric("f"))
#setMethod("f", "myS3", \(x) x$a) ## Error myS3 nicht definiert
setOldClass("myS3")
setMethod("f", "myS3", \(x) x$a)
x <- structure(list(a = 1), class = "myS3")
f(x)                 # 1

setClass("A", contains = "VIRTUAL", slots = list(x = "numeric"))
setClass("B", contains = "A", slots = list(y = "numeric"))
#a <- new("A", x = 1)      ## Error, virtuelle Klasse
b <- new("B", x = 2L, y = 3)
\end{lstlisting}

%Aufgrund der komplexen Methodensuche (Dispatch) und der formalen Prüfungen ist S4 rechenintensiver als S3. In performance-kritischen Schleifen sollte der direkte Zugriff auf Slots oder der Einsatz von S3 erwogen werden.

%Bei der Entwicklung von Paketen müssen S4-Klassen und -Methoden explizit im \texttt{NAMESPACE} exportiert werden (\lstinline|exportClasses(A)|, \lstinline|exportMethods(f)|).


\subsubsection{S7-Klassen}

S7 (Paket: \lstinline|S7|, Version 0.2.1, 2025-11-14) kombiniert die Einfachheit von S3 mit der formalen Strenge von S4 und unterstützt Klassen, generische Funktionen und Funktionsauswahl über die Klassen mehrerer Argumente.

Eine S7-Klasse wird mit \lstinline|new_class()| definiert. Dabei werden Eigenschaften (Properties) mit zugehörigen Typen festgelegt. Die Typen der Properties sind selbst S7-Klassen (z.\,B.\ \lstinline|class_integer| oder benutzerdefinierte Klassen). Base-Typen beginnen mit \lstinline|class_|. Der Zugriff auf die Elemente erfolgt mit \lstinline|@|.

Die Typen der Properties werden beim Erzeugen und Ändern eines Objekts geprüft. Zusätzliche, nicht deklarierte Properties sind nicht erlaubt.

Informationen zu einem S7 Objekt erhält man mit \lstinline|S7_class()| und auch für S3 mit \lstinline|class()|.

\begin{lstlisting}
library(S7)

A <- new_class("A", properties = list(x = class_integer))
x <- A(x = 42L)     # Erzeugt S7 Objekt
x@x                 # 42
x@x <- 0L
x@x                 # 0
#x@x <- "a"         ## Error, falscher Typ
#x@y <- 0           ## Error, gibt kein y
S7_class(x)         # <A> class
                    # @ parent     : <S7_object>
                    # @ constructor: function(x) {...}
                    # @ validator  : <NULL>
                    # @ properties :
                    #  $ x: <integer>
class(x)            # "A" "S7_object"
\end{lstlisting}

Mit dem Argument \lstinline|constructor| kann das Standardverhalten beim Erstellen eines Objekts angepasst werden (z.\,B.\ zur Vorverarbeitung von Werten) und auch Default-Werte vorgeben. Der \lstinline|validator| prüft die Konsistenz des Objekts nach der Erstellung oder Änderung, wenn einfache Typprüfungen der Properties nicht ausreichen. Der \lstinline|validator| wird sowohl beim Erzeugen eines Objekts als auch bei jeder Änderung einer Property ausgeführt. Bei der Definition in Paketen sollte das Argument \lstinline|package| gesetzt werden, um Namenskonflikte zu vermeiden.

\begin{lstlisting}
A <- new_class("A", properties = list(x = class_integer),
  constructor = \(x=10L) new_object(S7_object(), x = x - 1L),
  validator = \(self) {if (self@x < 0) "x < 0"},
  package = "meinpaket")
x <- A()
x@x                # 9; durch Constructor
x <- A(x = 2L)
x@x                # 1
x@x <- 2L          # Ohne Constructor
x@x                # 2
#x <- A(x = 0L)    ## Error, x < 0
#x@x <- -1L        ## Error, x < 0; Validator auch hier
\end{lstlisting}

In S7 können Union Types (Klassenvereinigungen) genutzt werden, um für eine Eigenschaft (Property) oder eine Methode mehrere verschiedene Klassentypen zuzulassen. Man definiert sie entweder mit der Funktion \lstinline|new_union()| oder mit \lstinline{|}.

\begin{lstlisting}
A <- new_class("A", properties = list(x = class_integer | NULL))
x <- A(x = 42L)
x <- A(x = NULL)

B <- new_class("B", properties =
       list(x = new_union(class_integer, class_character)))
x <- B(x = 42L)
x <- B(x = "z")
\end{lstlisting}

S7 bietet Computed Properties (berechnete Eigenschaften), welche bei jedem Zugriff neu berechnet werden. Es können auch Defaultwerte über Properties vergeben werden.

\begin{lstlisting}
B <- new_class("B", properties = list(
  x = class_numeric,
  x_sq = new_property(getter = \(self) self@x^2) 
))
b <- B(x=2)
b@x_sq              # 4
#b@x_sq  <- 2       ## Error, Read only
b@x  <- 3
b@x_sq              # 9

E <- new_class("E", properties = list(x =
      new_property(class_integer, default = 4L)))
e <- E()
e@x                 # 4
\end{lstlisting}

S7 verwendet generische Funktionen. Eine generische Funktion wird mit \lstinline|new_generic()| definiert. Die Signatur legt fest, über welche Argumente die Funktionsauswahl (method dispatch) erfolgt. Die Methoden werden mit \lstinline|method()| definiert.

\begin{lstlisting}
f <- new_generic("f", c("x", "y"))  # Auswahl über x und y

method(f, list(x=class_integer,y=class_integer)) <- \(x, y) "ii"
method(f, list(x=class_double, y=class_double)) <- \(x, y) "dd"
#method(f, list(x=class_integer)) <- \(x, y) "i" ## Error
method(f, list(x=class_integer, y=class_any)) <- \(x, y) "ia"

f(0L, 0L)                          # ii
f(0, 0)                            # dd
f(0L, "a")                         # ia
#f(0 , "a")                     ## Error, keine passende Methode

f                                  # Zeigt alle Methoden von f
\end{lstlisting}

S7 unterstützt Vererbung über das Argument \lstinline|parent|. Abgeleitete Klassen erben Properties und Methoden. Abgeleitete Klassen können Properties erweitern, aber nicht entfernen oder umdefinieren. S7 erlaubt die Definition abstrakter Klassen, von denen keine Instanzen erzeugt werden können. Mit \lstinline|super(from, to)| kann man zur nächsten Klasse weiterreichen.

\begin{lstlisting}
A <- new_class("A", abstract = TRUE,
  properties = list(x = class_numeric))
B <- new_class("B", parent = A, properties =
                         list(y = class_numeric))

# a <- A(x = 0)     ## Error, a ist Abstract
b <- B(x = 0, y = 1)

f <- new_generic("f", "x")
method(f, A) <- \(x) "A"
f(b)                  # A; Über Parent Methode
method(f, B) <- \(x) "B"
f(b)                  # B; Jetzt über eigene Methode
method(f, B) <- \(x) c("B",  f(super(x, A)))
f(b)                  # B A

E <- new_class("E")
e <- E()
#f(e)                 ## Error, Keine passende Methode
method(f, S7_object) <- \(x) "Def"  # Für alle S7
f(e)                  # Def
#f()                  ## Error, Keine passende Methode
method(f, class_missing) <- \(x) "Missing"
f()                   # Missing
#f(0)                 ## Error, Keine passende Methode
method(f, class_any) <- \(x) "Any"  # Für alle
f(0)                  # Any
\end{lstlisting}

S7 ist vollständig mit dem bestehenden S3-System interoperabel. S7-Objekte besitzen immer auch eine S3-Klasse, sodass sie nahtlos mit bestehenden S3-Generics und Methoden verwendet werden können.

\begin{lstlisting}
A <- new_class("A", properties = list(x = class_integer))
x <- A(x = 42L)     # Erzeugt S7 Objekt
print(x)   # <A>, @ x: int 42
#print.A <- \(x, ...) print(x@x, ...) # Nicht empfohlen
method(print, A) <- \(x, ...) print(x@x, ...) # empfohlen
print(x)   # 42
\end{lstlisting}

In S7 müssen S3-Klassen explizit mit \lstinline|new_S3_class()| deklariert werden, bevor sie als Typen für Properties oder in Methodensignaturen verwendet werden können. Während Basis-S3-Klassen wie \lstinline|data.frame| bereits vordefiniert sind, ist \lstinline|new_S3_class()| für alle anderen S3-Klassen, z.\,B.\ aus eigenen Klassen zwingend erforderlich.

\begin{lstlisting}
S3 <- list(x = 10)
class(S3) <- "S3"
# A <- new_class("A", properties = list(y = S3)) ## Error
class_S3 <- new_S3_class("S3")
A <- new_class("A", properties = list(y = class_S3))
a <- A(y = S3)
\end{lstlisting}


\subsubsection{Reference-Klassen}

Reference Classes (auch \emph{RC} genannt) stellen in R ein objektorientiertes System mit Referenzsemantik bereit. Im Gegensatz zu S3 und S4 werden Objekte nicht kopiert, sondern in-place verändert. Wird ein Reference-Class-Objekt an eine Funktion übergeben, arbeiten alle Variablen, die darauf verweisen, auf demselben Objekt.

Reference Classes werden mit \lstinline|setRefClass| definiert. Dabei werden Felder (Attribute) und Methoden explizit angegeben. Objekte werden durch den Aufruf des Klassennamens erzeugt.

Innerhalb von RefClass-Methoden kann der Zugriff auf Felder entweder direkt über den Operator \lstinline|<<-| oder explizit über \lstinline|.self$feldname| erfolgen. Empfohlen wird die Verwendung von \lstinline|.self$feldname|, um Namenskollisionen mit lokalen Variablen zu vermeiden.

Der Zugriff auf Felder und Methoden erfolgt über den Operator \lstinline|$|.

Reference Classes unterstützen Vererbung über das Argument \lstinline|contains| bei der Klassendefinition. Abgeleitete Klassen erben Felder und Methoden der Basisklasse.

\begin{lstlisting}
A <- setRefClass("A",
  fields = list(x = "numeric"),
  methods = list( inc = \() { .self$x <- .self$x + 1 } ))

a <- A$new()
a$x               # numeric(0)
a <- A$new(x = 1)
a$x               # 1
a$inc()
a$x               # 2

z <- a
z$inc()
a$x               # 3

f <- \(obj) obj$inc()
f(a)
a$x               # 4

a$x <- 7
#a$x <- "a"       ## Error, falsche Klasse

B <- setRefClass("B",
  contains = "A",           # .self wäre besser als <<-
  methods = list( dec = \() { x <<- x - 1 } ))

b <- B$new(x = 10)
b$x               # 10
b$inc()
b$x               # 11
b$dec()
b$x               # 10
\end{lstlisting}

Mit \lstinline|$copy(TRUE)| kann man eine flache Kopie (\emph{shallow copy}) eines Reference-Class-Objekts erzeugen. Referenzfelder, wie andere Reference-Class-Objekte oder Environments, werden dabei nicht kopiert. Mit \lstinline|$copy()| kann eine tiefe Kopie (\emph{deep copy}) erstellt werden, bei der auch referenzierte Objekte rekursiv kopiert werden.

\begin{lstlisting}
A <- setRefClass("A", fields = list(x = "numeric"))
B <- setRefClass("B", fields = list(x = "A", y = "numeric"))
a <- A$new(x = 0)
b <- B$new(x = a, y = 0)

c <- b$copy()     # Deep Copy
c$x$x <- 1
c$y <- 1
a$x           # 0
b$x$x         # 0
b$y           # 0

c <- b$copy(TRUE) # Shallow copy
c$x$x <- 2
c$y <- 2
a$x           # 2
b$x$x         # 2
b$y           # 0

c <- b            # Referenz
c$x$x <- 3
c$y <- 3
a$x           # 3
b$x$x         # 3
b$y           # 3
\end{lstlisting}

Im Gegensatz zu S3 und S4 erfolgt der Methodenaufruf bei Reference Classes nicht über generische Funktionen und Funktionsauswahl, sondern über direkte Methodenbindung an das Objekt. Polymorphes Verhalten wird durch Vererbung und Überschreiben von Methoden realisiert.

Man kann auch eine eigene \lstinline|initialize|-Methode definieren. \lstinline|callSuper()| ruft die gleichnamige Methode der Basisklasse auf. Die Funktion \lstinline|callSuper(...)| sollte in der Regel am \emph{Anfang} der \lstinline|initialize|-Methode aufgerufen werden. Dadurch werden die Felder zuerst mit den übergebenen Argumenten initialisiert, woraufhin die spezifische Logik der Subklasse diese Werte validieren oder modifizieren kann. Würde \lstinline|callSuper()| am Ende stehen, könnten manuelle Zuweisungen innerhalb der Methode durch die Standard-Initialisierung der Basisklasse überschrieben werden. Am Ende der \lstinline|initialize|-Methode sollte \lstinline|.self| stehen. Wenn keine eigene initialize-Methode geschrieben wird, nutzt RC eine Standardmethode, die benannte Argumente den Feldern zuweist.

\begin{lstlisting}
A <- setRefClass("A",
  fields = list(x = "numeric"),
  methods = list( inc = \() { .self$x <- .self$x + 1 },
    initialize = \(x = 0, ...) {
      callSuper(...)  # für den Fall weiterer Basisklassen
      .self$x <- x
      .self } ))
a <- A$new()
a$x                # 0
a <- A$new(x=1)
a$x                # 1

B <- setRefClass("B",
  contains = "A",
  methods = list(
    inc = \() {
      callSuper()  # ruft inc() von A auf
      .self$x <- .self$x + 10 } ))
b <- B$new(x = 1)
b$inc()
b$x                # 12
\end{lstlisting}


\iffalse
\subsubsection{R6-Klassen}

R6 ist ein modernes objektorientiertes System für R mit Referenzsemantik, das viele Konzepte von Reference Classes (RC) übernimmt, jedoch kompakter und effizienter umgesetzt ist.  
Wie bei RC werden Objekte in-place verändert und Methoden sind direkt an das Objekt gebunden. R6-Objekte sind \emph{mutable}: Änderungen wirken auf alle Variablen, die auf dasselbe Objekt verweisen.

R6-Klassen werden mit \lstinline|R6Class()| definiert. Dabei werden \emph{public} Felder (Attributes) und Methoden explizit angegeben. Objekte werden mit \lstinline|$new()| erzeugt. Der Zugriff auf Felder und Methoden erfolgt über den Operator \lstinline|$|.

\begin{lstlisting}
library(R6)

A <- R6Class("A",
  public = list(
    x = NULL,
    initialize = function(x = 0) { self$x <- x },
    inc = function() { self$x <- self$x + 1 }
  )
)

a <- A$new()
a$x               # 0
a$inc()
a$x               # 1

z <- a
z$inc()
a$x               # 2

f <- function(obj) obj$inc()
f(a)
a$x               # 3

a$x <- 7
#a$x <- "a"       ## Error, falscher Typ nicht automatisch geprüft
\end{lstlisting}

---

R6 unterstützt Vererbung über das Argument \lstinline|inherit|. Abgeleitete Klassen erben Felder und Methoden der Basisklasse. Methoden können überschrieben werden, wobei auf die Basisklassenmethode mit \lstinline|super$method()| zugegriffen werden kann.

\begin{lstlisting}
B <- R6Class("B",
  inherit = A,
  public = list(
    dec = function() { self$x <- self$x - 1 },
    inc = function() {
      super$inc()    # ruft inc() von A auf
      self$x <- self$x + 10 }
  )
)

b <- B$new(x = 1)
b$inc()
b$x               # 12
b$dec()
b$x               # 11
\end{lstlisting}

---

R6-Objekte können \emph{kopiert} werden, wobei standardmäßig eine flache Kopie erstellt wird. Für eine tiefe Kopie kann \lstinline|clone(deep = TRUE)| verwendet werden, ähnlich wie bei Reference Classes.

\begin{lstlisting}
A <- R6Class("A", public = list(x = 0))
B <- R6Class("B", inherit = A, public = list(y = NULL))

a <- A$new()
b <- B$new()
b$x <- a$x
b$y <- a

c <- b$clone(deep = TRUE)  # Deep copy
c$y$x <- 1
a$x               # 0
b$y$x             # 0

d <- b$clone()     # Shallow copy
d$y$x <- 2
a$x               # 2
b$y$x             # 2
\end{lstlisting}

---

Im Gegensatz zu S3, S4 oder S7 erfolgt der Methodenaufruf nicht über generische Funktionen, sondern direkt über das Objekt. Polymorphismus wird durch Vererbung und Überschreiben von Methoden realisiert, nicht durch Dispatch auf Klassen.

\begin{lstlisting}
# R6-Polymorphismus-Beispiel
C <- R6Class("C",
  inherit = A,
  public = list(
    inc = function() { self$x <- self$x + 100 }
  )
)

c <- C$new(x = 1)
c$inc()
c$x               # 101
\end{lstlisting}

---

R6 ist besonders geeignet für:

- mutable Objekte, die in Simulationen, GUIs oder iterativen Algorithmen benötigt werden,
- klare Kapselung von Daten und Methoden,
- kompakte, moderne Syntax im Vergleich zu Reference Classes.

Im Vergleich zu RC bietet R6:

- **leichtere Syntax** (kein \lstinline|<<-| notwendig),
- **schnellere Implementierung**, da kein S4-Metaclass-System beteiligt ist,
- klarere Trennung zwischen public, private und active fields.

R6 ergänzt damit das Spektrum objektorientierter Systeme in R und bildet die moderne Variante referenzbasierter Klassen.

\fi


\section{Typen}

Alle Objekte haben einen bestimmten Typ. Dieser Typ bestimmt, welche Werte bzw.\ Daten ein Objekt enthalten kann und welche Operationen darauf zulässig sind. Neben dem Typ bestimmt die Objektklasse, wie Operatoren und Funktionen auf ein Objekt angewendet werden.

R ist dynamisch typisiert, d.\,h.\ der Typ ist an das Objekt gebunden und wird zur Laufzeit festgelegt. Mit \lstinline|typeof()| kann der interne Typ eines Objekts bestimmt werden.

Ob ein Objekt zu einem bestimmten Typ gehört, lässt sich mit Funktionen der Form
\lstinline|is.TYP()|, z.\,B.\ \lstinline|is.numeric()|, prüfen. Ob es zu einer bestimmten Klasse gehört kann mit \lstinline|is()| geprüft werden.

\begin{lstlisting}
x <- 1
typeof(x)        # double;  interner Typ
class(x)         # numeric; Klasse(n)
is.double(x)     # TRUE
is.numeric(x)    # TRUE
is.character(x)  # FALSE
is(x, "double")  # FALSE; ist Typ nicht Klasse
is(x, "numeric") # TRUE
\end{lstlisting}

Mit \lstinline|as.TYP()| wird in den Typ, mit \lstinline|as()| in die Klasse konvertiert. R prüft dabei nicht streng auf Genauigkeit, sondern führt die Konvertierung stillschweigend durch. Mit \lstinline|canCoerce()| kann geprüft werden ob ein Objekt in eine andere Klasse konvertiert werden kann.

\begin{lstlisting}[language=R]
as.integer(1)     # Wandelt Double in Integer
as.integer(1.0)   # Wandelt Double in Integer
as.integer(1.8)   # wird abgeschnitten => 1
as.integer("a")   # NA; Warnung
floor(1.3)        # Abrunden  => 1 Double
ceiling(1.3)      # Aufrunden => 2 Double
round(1.3)        # Runden    => 1 Double
x <- "1.5"
canCoerce(x, "numeric")  # TRUE
as(x, "numeric")         # 1.5
\end{lstlisting}


\subsection{Vektor}

In R ist selbst ein einzelnes Element bereits ein Vektor. Vektoren zählen zu den atomaren Objekten, welche nur Werte eines einzigen elementaren Typs enthalten können. \lstinline|is.atomic()| prüft, ob ein Objekt atomar ist. \lstinline|is.vector()| ist nur dann \lstinline|TRUE|, wenn das Objekt atomar ist und außer \lstinline|names()| keine weiteren Attribute besitzt.

\begin{lstlisting}
x <- 1
is.atomic(x)     # TRUE
is.vector(x)     # TRUE
\end{lstlisting}

Werden unterschiedliche Typen gemischt, werden sie automatisch in den flexibelsten Typ umgewandelt (Hierarchie: logical < integer < double < character).

\begin{lstlisting}
c(TRUE, 1L)          # 1 1; Wird integer-Vektor
c(1, "a")            # "1" "a"; Wird character-Vektor
\end{lstlisting}

Die Funktion \lstinline|length()| dient nicht nur zum Abfragen, sondern kann auch zum Vergrößern (Auffüllen mit \lstinline|NA|) oder Kürzen von Vektoren genutzt werden.

\begin{lstlisting}
x <- c(1, 3, 2)
length(x)            # 3
length(x) <- 4
x                    # 1 3 2 NA; Auffüllen mit NA
length(x) <- 2
x                    # 1 3; verkürzt Vektor
\end{lstlisting}

\subsubsection{Erzeugen von Vektoren}

\paragraph{Initialisierung}

Ein Vektor kann mit der allgemeinen Funktion \lstinline|vector()| oder über spezifische Typ-Konstruktoren erzeugt werden. Dies ist besonders effizient, wenn die finale Länge bereits bekannt ist (Prä-Allokation), um Speicherplatz zu reservieren.

\begin{lstlisting}
x <- vector("logical", 3)  # Vektor mit 3 Logical Elementen
x <- logical(3)            # Vektor mit 3 Logical Elementen
numeric(0)                 # Leerer Vektor
\end{lstlisting}

\paragraph{Aneinanderfügen}

Die Funktion \lstinline|c()| (combine) verknüpft einzelne Werte oder bestehende Vektoren zu einem neuen, längeren Vektor.

\begin{lstlisting}
x <- c(3, 1, 2)     # Vektor mit den angegebenen Elementen
c(x, 4, c(6, 5))    # 3 1 2 4 6 5; Fügt Vektoren zusammen
\end{lstlisting}

\paragraph{Sequenzen}

Der Operator \lstinline|:| erzeugt Ganzzahlfolgen. Für komplexere Schrittweiten nutzt man \lstinline|seq()|. 

Die Schreibweise \lstinline|1:n| ergibt bei \lstinline|n = 0| \lstinline|1 0|, was beim Iterieren über einzelne Elemente meist nicht beabsichtigt ist. Daher sollten in Schleifen \lstinline|seq_len()| oder \lstinline|seq_along()| bevorzugt werden, da diese bei Nullwerten einen leeren Vektor zurückgeben.

\begin{lstlisting}
x <- 1:3             # 1 2 3; Erzeugt eine Integer Sequenz
3:1                  # 3 2 1
seq(1, 3)            # 1 2 3; Erzeugt eine Integer Sequenz
seq(1, 6, 2)         # 1 3 5; double Sequenz
seq(1L, 6L, 2L)      # 1 3 5; Integer Sequenz
seq(3, by=2, length.out=4) # 3 5 7 9
seq(0, by=3, along.with=x) # 0 3 6; so lange wie x
seq_along(x)         # 1 2 3

x <- integer(0)      # Vektor mit Länge 0
seq_along(x)         # integer(0)
n <- 3
seq_len(n)           # 1 2 3
n <- 0
seq_len(n)           # integer(0)
1:n                  # 1 0
\end{lstlisting}

\paragraph{Wiederholen}

Die Funktion \lstinline|rep()| erlaubt es, Objekte oder deren Elemente systematisch zu vervielfältigen.

\begin{lstlisting}
rep(1:3, 2)          # 1 2 3 1 2 3; Objekt wiederholen
rep(1:3, each=2)     # 1 1 2 2 3 3
rep(1:3, 3:1)        # 1 1 1 2 2 3
rep_len(1:2, 5)      # 1 2 1 2 1
\end{lstlisting}


\subsubsection{Recycling-Regel}

R verwendet bei Vektoroperationen die sogenannte \emph{Recycling-Regel}. Kürzere Vektoren werden automatisch wiederholt. Ist die Länge kein ganzzahliges Vielfaches, gibt R eine Warnung aus. Ein Skalar (einzelne Zahl) ist in R ein Vektor der Länge 1 und wird bei Operationen mit längeren Vektoren auf deren Länge erweitert.

\begin{lstlisting}
1:4 + 1:2 + 1        # 3 5 5 7; Auto Wiederholung
1:4 + 1:3            # 2 4 6 5; Warnung Länge
1:3 + 1:4            # 2 4 6 5; Warnung Länge
\end{lstlisting}


\subsubsection{Zugriff auf Vektorelemente}

Auf einzelne Elemente in einem Vektor kann mit \lstinline|[INDEX]| zugegriffen werden. Der Index selbst ist dabei wiederum ein Vektor. Bei \lstinline|[]| bleiben Namen erhalten. \lstinline|[[INDEX]]| liefert ausschließlich das Element wobei der index nur ein Element haben darf.

\begin{lstlisting}
10[c(1,1)]       # 10 10

x <- c(10, 20, 30, 40)
x                # ganzer Vektor
x[]              # ganzer Vektor
x[0]             # leerer Vektor
x[-0]            # leerer Vektor
x[NULL]          # leerer Vektor
x[integer(0)]    # leerer Vektor
x[-integer(0)]   # leerer Vektor
\end{lstlisting}


\paragraph{Positionsbasierte Indizierung}

Bei der positionsbasierten Indizierung werden Elemente über ihre numerische Position im Vektor ausgewählt.

\begin{lstlisting}
x <- c(10, 20, 30, 40)
x[2]             # 20; Element an Position 2
x[2:3]           # 20 30; Element 2 bis 3
x[3:2]           # 30 20; Element 3 bis 2
x[c(1,3,2)]      # 10 30 20; Mehrere Elemente
i <- c(1,3,2)
x[i]             # 10 30 20
x[c(1,1)]        # 10 10; Mehrfach gleiches Element

x[5]             # NA

which(x > 20)    # 3 4; which gibt TRUE Positionen
x[which(x > 20)] # 30 40; Über Position
\end{lstlisting}


\paragraph{Negative Indizes}

Negative Indizes schließen die angegebenen Positionen aus dem Ergebnis aus. Positive und negative Indizes dürfen nicht gemischt werden.

\begin{lstlisting}
x <- c(10, 20, 30, 40)
x[-c(1,3)]       # 20 40; Alle außer Position 1 und 3

x[-which(x>20)]  # 10 20
x[-which(x>50)]  # leerer Vektor

#x[c(-1,3)]      ## Error, positiv und negativ
\end{lstlisting}


\paragraph{Logische Indizierung}

Bei der logischen Indizierung wird ein logischer Vektor verwendet, um Elemente
auszuwählen. Der logische Index wird bei Bedarf automatisch wiederholt.

\begin{lstlisting}
x <- c(10, 20, 30, 40)
x[c(TRUE,FALSE,FALSE,TRUE)] # 10 40
x[c(TRUE,FALSE)] # 10 30; Wird automatisch wiederholt

x > 20           # FALSE FALSE TRUE TRUE
x[x > 20]        # 30 40
x[!(x > 20)]     # 10 20; ! (not)
x[! x > 20]      # 10 20; Das gleiche
x[!(x > 50)]     # 10 20 30 40
\end{lstlisting}


\subsubsection{Benannte Vektoren}

Elemente können auch Namen haben, über die auf sie zugegriffen werden kann.
Mit \lstinline|names()| können Namen abgefragt oder gesetzt werden.
Namen können bei bestehenden Vektoren mit \lstinline|setNames()| gesetzt werden.
Mit \lstinline|unname()| können Namen entfernt werden.

\begin{lstlisting}
x <- c("3"=10, b=20, c=30, d=40)
x["c"]           # 30; behält Namen
x[["c"]]         # 30; Nur Wert, ohne Namen
x[c("c", "d")]   # 30 40
#x[[c("c", "d")]]## Error, geht nur für ein Element
#x$c             ## Error, $ nicht bei Vektor
x[3]             # 30; Über Position
x["3"]           # 10; Über Namen

x <- c(1, 3, 2)
names(x)         # NULL
names(x) <- c("a", "c", "b")
x                              # a c b
                               # 1 3 2
unname(x)                      # 1 3 2
names(x) <- NULL               # Namen Löschen

setNames(x, c("a", "c", "b"))  # a c b
                               # 1 3 2
setNames(nm = x)               # 1 3 2; Namen aus den Werten
                               # 1 3 2
x <- c(a=1, b=2)
x[1]                           # Element mit Namen
dput(x[1])                     # c(a = 1)
x[1] <- 4                      # Name bleibt erhalten
dput(x[1])                     # c(a = 4)
x[1] <- c(z = 9)               # z wird ignoriert
x[[1]] <- 9                    # Muss in zwei Schritten erfolgen
names(x)[1] <- "z"
dput(x[1])                     # c(z = 9)
\end{lstlisting}

Wird der gleiche Name öfters vergeben wird nur der erste Treffer zurückgegeben. Eindeutige Namen können mit \lstinline|make.names| oder mit \lstinline|make.unique| erzeugt werden.

\begin{lstlisting}
x = c(a=1, "b b"=2, a=3)
names(x)                   # "a" "b b" "a"
x["a"]                     # 1; gibt ersten Treffer zurück
x[names(x) == "a"]         # 1 3; Beide Treffer
make.names(names(x), TRUE) # "a" "b.b" "a.1"
make.unique(names(x))      # "a" "b b" "a.1"
x[c(1, 1)]                 # a a; Namen unverändert
                           # 1 1
\end{lstlisting}


\subsubsection{Anfang und Ende}

Mit \lstinline|head()| und \lstinline|tail()| erhält man den Anfang bzw.\ das Ende eines Vektors.

\begin{lstlisting}
x <- 1:5
head(x, 2)    # 1 2; Ersten zwei Elemente
tail(x, 2)    # 4 5; Letzten zwei Elemente
head(x, -2)   # 1 2 3; Ohne die letzten beiden
tail(x, -2)   # 3 4 5; Ohne die ersten beiden
\end{lstlisting}


\subsubsection{Veränderung}

\paragraph{Zusammenfügen}

Bestehende Vektoren können mit \lstinline|c()| aneinander gehängt werden.

\begin{lstlisting}
x <- 1:3
x <- c(x, 4L)     # 1 2 3 4; Element anhängen
y <- 5:6
c(x, y)           # 1 2 3 4 5 6
\end{lstlisting}

Die Funktion \lstinline|c()| erzeugt jedes Mal einen \emph{neuen} Vektor und kopiert dabei alle Elemente. Das wiederholte Anhängen von Elementen in einer Schleife kann bei großen Vektoren langsam werden.

\begin{lstlisting}
x <- integer(0)
for (i in 1:100000) x <- c(x, i)

x <- integer(100000)
for (i in 1:100000) x[i] <- i
\end{lstlisting}

\paragraph{Einfügen}

Mit \lstinline|append()| kann an einer bestimmten Position eingefügt werden.

\begin{lstlisting}
x <- 1:3
append(x, 5:6, 2)   # 1 2 5 6 3; nach Position 2 einfügen
append(x, 5:6, 9)   # 1 2 3 5 6; Position 9 gibt es nicht
\end{lstlisting}

\paragraph{Überschreiben}

Elemente können mit \lstinline|<-| überschrieben werden.

\begin{lstlisting}
x <- 1:3          # 1 2 3; Integer
x[2] <- 4L        # 1 4 3; zweites Element ändern
x[2] <- 2         # 1 2 3; Int wird Numeric
x[2:3] <- 5:6     # 1 5 6
x[x>1] <- 2       # 1 2 2; Alle >1 auf 2 ändern
x[5] <- 5         # 1 2 2 NA 5; Element hinterm Ende einfügen
x[] <- 2          # 2 2 2 2 2: Alle Elemente werden 2
x[c(2,4)] <- 3    # 2 3 2 3 2
\end{lstlisting}

\paragraph{Invertieren}

Die Reihenfolge kann mit \lstinline|rev()| umgedreht werden.

\begin{lstlisting}
rev(1:3)          # 3 2 1
\end{lstlisting}

\paragraph{Sortieren}

Einen Index, mit dem die Elemente sortiert sind, erhält man mit \lstinline|order()|. Mit \lstinline|sort()| kann man einen Vektor sortieren. Mit \lstinline|rank()| bekommt man den Rang.

\begin{lstlisting}
x <- c(1,3,2,1)
i <- order(x)       # 1 4 3 2
x[i]                # 1 1 2 3
is.unsorted(x)      # TRUE
is.unsorted(x[i])   # FALSE
sort(x)             # 1 1 2 3
rank(x)             # 1.5 4.0 3.0 1.5
\end{lstlisting}

\paragraph{Duplikate entfernen}

Einmalige Elemente erhält man mit \lstinline|unique()|, die Positionen von doppelten Elementen mit \lstinline|duplicated|.

\begin{lstlisting}
x <- c(2, 2, 1, 1, 3)
unique(x)         # 2 1 3
duplicated(x)     # FALSE TRUE FALSE TRUE FALSE
\end{lstlisting}

\subsubsection{Sparse Vector}

Sparse-Vektoren (dünnbesetzte Vektoren) können verwendet werden, wenn nur sehr wenige Einträge von 0 verschieden sind. Anstatt jeden Wert einzeln im Arbeitsspeicher abzubilden, werden nur die von 0 verschiedenen Elemente zusammen mit ihren Positionen (Indizes) gespeichert.

Dies ist jedoch nur dann speichereffizient, wenn die Anzahl der Nullen deutlich überwiegt, da für jeden Eintrag zusätzlich der Index verwaltet werden muss. In R können Sparse-Vektoren mit der Funktion \lstinline|sparseVector()| aus dem Paket \lstinline|Matrix| erzeugt werden.

\begin{lstlisting}
x <- Matrix::sparseVector(
  c(3, 5, 7),    # Werte
  c(1, 10, 90),  # Indizes
  100 )          # Länge des Vektors
x[1]             # 3
x[2]             # .;  implizite 0
x[2] + 1         # 1
x[101]           # NA; außerhalb der Dimension
x <- x + 10      # Nicht mehr sparse, alle + 10
x[1]             # 13
x[2]             # 10
\end{lstlisting}

Alternativ können bestehende Standard-Vektoren (dense) in eine Sparse-Darstellung umgewandelt werden. Dabei kann man die Zielklasse automatisch über \lstinline|"sparseVector"| bestimmen lassen oder spezifische Typen explizit angeben:
\begin{itemize}
\item \lstinline|nsparseVector|: \emph{Pattern} (speichert nur die Position, keine Werte).
\item \lstinline|lsparseVector|: \emph{logical} (TRUE, FALSE, NA).
\item \lstinline|isparseVector|: \emph{integer} (Ganzzahlen).
\item \lstinline|dsparseVector|: \emph{double} (Fließkommazahlen).
\item \lstinline|zsparseVector|: \emph{complex} (Komplexe Zahlen).
\end{itemize}

\begin{lstlisting}
x <- numeric(1e6)
x[c(1, 100, 900)] <- c(3, 5, 7)
y <- as(x, "sparseVector")  # Automatische Wahl
y <- as(x, "dsparseVector") # Explizite Angabe
object.size(x)   # 8000048 bytes
object.size(y)   #    1048 bytes
\end{lstlisting}


\subsection{Grundtypen}

Die elementaren Datentypen bilden die Basis aller atomaren Vektoren.

Bei Operationen (\lstinline|+|, \lstinline|*|, \lstinline|==|, \dots)  mit unterschiedliche Typen, wird automatisch zum höheren Typ konvertiert (implizite Coercion: logical < integer < double < complex < character).

\subsubsection{logical}

Kann entweder \lstinline|FALSE| oder \lstinline|TRUE| sein. Die Abkürzungen \lstinline|T| und \lstinline|F| entsprechen \lstinline|TRUE| und \lstinline|FALSE|, sollten jedoch vermieden werden, da sie im Gegensatz zu den reservierten Wörtern \lstinline|TRUE| und \lstinline|FALSE| Variablennamen sind, die vom Nutzer neu zugewiesen werden können (z.\,B.\ \lstinline|T <- FALSE|).

\begin{lstlisting}
TRUE == T              # TRUE
FALSE == F             # TRUE
FALSE == T             # FALSE
#TRUE <- FALSE         ## Error
T <- FALSE
FALSE == T             # TRUE; !
\end{lstlisting}

Übliche Operatoren für \emph{einzelne} Elemente sind \lstinline|&&| (and, und) und \lstinline{||} (or, oder).

\begin{lstlisting}
FALSE && TRUE          # FALSE
TRUE  || FALSE         # TRUE
\end{lstlisting}

Für mehrere Elemente werden \lstinline|&| bzw.\ \lstinline{|} verwendet. Sie funktionieren jedoch auch für einzelne logische Werte. Zusätzlich gibt es noch die Funktion \lstinline|xor()|.

\begin{lstlisting}
x <- c(FALSE, TRUE, FALSE)
y <- c(TRUE, TRUE, FALSE)
x & y                  # FALSE TRUE FALSE
x | y                  # TRUE TRUE FALSE
xor(x, y)              # TRUE FALSE FALSE
#x && y                ## Error, länger als 1
#x || y                ## Error, länger als 1
FALSE & TRUE           # FALSE
TRUE  | FALSE          # TRUE
\end{lstlisting}

\lstinline|&&| und \lstinline{||} werden meist in Kontrollstrukturen (\lstinline|if|, \lstinline|while|) verwendet, während \lstinline|&| und \lstinline{|} elementweise auf Vektoren angewendet werden.

Bei \lstinline|&&| und \lstinline{||} wird die Auswertung abgebrochen, sobald das Ergebnis feststeht (Kurzschlussauswertung), was bei \lstinline|&| und \lstinline{|} nicht der Fall ist.

\begin{lstlisting}
x <- 0
TRUE && (x <- 1)
x                   # 1
TRUE || (x <- 2)
x                   # 1
FALSE && (x <- 3)
x                   # 1
FALSE || (x <- 4)
x                   # 4

TRUE & (x <- 5)
x                   # 5
TRUE | (x <- 6)
x                   # 6
FALSE & (x <- 7)
x                   # 7
FALSE | (x <- 8)
x                   # 8
\end{lstlisting}

Das Gegenteil erhält man mit \lstinline|!| (not, nicht).

\begin{lstlisting}
!TRUE                  # FALSE
!FALSE                 # TRUE
\end{lstlisting}

Bei Funktionen kann man deren Rückgabe mit \lstinline|Negate()| umkehren.

\begin{lstlisting}
f <- Negate(as.logical)
f(TRUE)                # FALSE
f(FALSE)               # TRUE

f <- \(...) !as.logical(...)
f(TRUE)                # FALSE
f(FALSE)               # TRUE
\end{lstlisting}

Die Zahl \lstinline|0| wird als \lstinline|FALSE| interpretiert, jede von Null verschiedene Zahl (auch negativ oder nicht-ganzzahlig) als \lstinline|TRUE|. Umgekehrt können logische Elemente z.\,B.\ auch addiert werden wobei \lstinline|FALSE| den Wert \lstinline|0| und \lstinline|TRUE| den Wert \lstinline|1| annehmen.

\begin{lstlisting}
0 & TRUE               # FALSE
1 & TRUE               # TRUE
-9.3 & TRUE            # TRUE
!0 & TRUE              # TRUE
TRUE + TRUE            # 2
FALSE + FALSE          # 0
\end{lstlisting}

Logische Werte entstehen meist durch Vergleichsoperatoren wie \lstinline|==| (gleich), \lstinline|!=| (ungleich), \lstinline|<|, \lstinline|>|, \lstinline|<=| oder \lstinline|>=|. Daneben gibt auch die Gruppe der \lstinline|is.| Funktionen (\lstinline|is.na()|, \lstinline|is.nan()||, \dots) meist logische Vektoren zurück.

Um einen logischen Vektor auf einzelne Bedingungen zu prüfen, nutzt man \lstinline|any()| (mindestens ein Element ist \lstinline|TRUE|) oder \lstinline|all()| (alle Elemente sind \lstinline|TRUE|).

\begin{lstlisting}
x <- 1:3
x > 2                  # FALSE FALSE TRUE
all(x > 2)             # FALSE
any(x > 2)             # TRUE
all(x > 0)             # TRUE
\end{lstlisting}


\subsubsection{integer}

R verwendet standardmäßig den numerischen Typ \lstinline|double| (Gleitkommazahlen mit doppelter Präzision), da dieser flexibler ist. Um explizit eine ganze Zahl vom Typ \lstinline|integer| zu erstellen, muss an die Zahl das Suffix \lstinline|L| angehängt werden. Alternativ können Objekte mit \lstinline|as.integer()| umgewandelt werden. Sowohl \lstinline|integer| als auch \lstinline|double| gehören zur Gruppe \lstinline|numeric|.

\begin{lstlisting}
typeof(1)        # double
typeof(1L)       # integer; standardmäßig 32 Bit
1 == 1L          # TRUE; int wird in double umgewandelt
identical(1, 1L) # FALSE (Typvergleich)
1.9L             # Warnung, wird double
0x2aL            # 42, Integer (hexadezimal)
as.integer(1)    # 1
as.integer(1.9)  # 1
is.integer(1)    # FALSE; ist double
is.integer(1L)   # TRUE
is.numeric(1)    # TRUE
is.numeric(1L)   # TRUE; integer ist auch numeric
\end{lstlisting}

Arithmetische Operationen mit \lstinline|double|-Werten wandeln das Ergebnis automatisch in \lstinline|double| um:
\begin{lstlisting}
1L + 0.5         # 1.5
typeof(1L + 0.5) # double
1L * 2           # 2
typeof(1L * 2)   # double; 2 ist double
\end{lstlisting}

Das direkte Setzen von \lstinline|mode()| bzw.\ \lstinline|storage.mode()| ist möglich, wird jedoch im Allgemeinen nicht empfohlen. Stattdessen sollte \lstinline|as.integer()| verwendet werden.

\begin{lstlisting}
x <- 1
typeof(x)        # double
mode(x) <- "integer"
typeof(x)        # integer
\end{lstlisting}

Ein integer-Vektor verbraucht nur halb so viel Speicher (4~Bytes pro Element) wie ein double-Vektor (8~Bytes). Das ist bei sehr großen Datensätzen, die ausschließlich Ganzzahlen enthalten, relevant.

\begin{lstlisting}
object.size(integer(0))      #   48 bytes
object.size(integer(1000))   # 4048 bytes
object.size(double(1000))    # 8048 bytes
\end{lstlisting}

32~Bit-Integer können Werte von $-2^{31}$ bis $2^{31}-1$ darstellen.
Der Wert $-2^{31}$ wird in R als spezielles Bitmuster zur Darstellung von
\lstinline|NA_integer_| verwendet, wodurch ein nutzbarer Wertebereich von -2147483647 bis 2147483647 entsteht.

Bei einem Überlauf (Integer Overflow) wird \lstinline|NA| zurückgegeben und eine Warnung ausgegeben.

\begin{lstlisting}
2147483647L          # Größte Integerzahl
2147483647L + 1L     # NA; Ganzzahlüberlauf
2147483648L          # Warnung Umwandlung in Double
\end{lstlisting}

Der \lstinline|:|-Operator erzeugt automatisch Integer-Sequenzen,
solange Start- und Endwert als Integer darstellbar sind.

\begin{lstlisting}
typeof(1:3)                # integer
typeof(1L:3L)              # integer
typeof(1.0:3.0)            # integer
typeof((2^31-2):(2^31-1))  # integer
typeof((2^31-2):(2^31))    # double
\end{lstlisting}

Zur exakten Berechnung mit sehr großen ganzen Zahlen oder rationalen Zahlen kann das Paket \lstinline|gmp| verwendet werden. Dabei sollten Zahlen als character String, zwischen Anführungszeichen, übergeben werden, um nicht die Rundungsproblematik abermals zu haben. Diese werden derzeit intern als \lstinline|raw| mit der Klasse \lstinline|bigz| bzw.\ \lstinline|bigq| gespeichert. Manchmal kann es effizienter sein \lstinline|bigz| bzw.\ \lstinline|bigq| in einer \lstinline|list| anstatt in einem \lstinline|vector| zu speichern.

\begin{lstlisting}
library(gmp)
as.bigz("2147483648")            #  2147483648 als Ganzzahl
#as.bigz(9007199254740993)       ## 9007199254740992
as.bigz("9007199254740993")      #  9007199254740993
is.numeric(as.bigz("1"))         # FALSE

as.bigq(1L, 3L)                  #  exakter Bruch 1/3
as.bigq(2L, 4L)   # 1 / 2
as.bigq(0.5, 1)   # 1 / 2
\end{lstlisting}

Das Paket \lstinline|bit64| stellt mit \lstinline|integer64| einen 64-Bit-Integer-Typ bereit, der den Bereich von -9\,223\,372\,036\,854\,775\,807 bis 9\,223\,372\,036\,854\,775\,807 abdeckt.

\begin{lstlisting}
library(bit64)
x <- as.integer64("9223372036854775807")
is.integer(x)                   # FALSE
is.numeric(x)                   # TRUE
\end{lstlisting}


\subsubsection{double}

Der Datentyp \lstinline|double| ist der Standard-Zahlentyp in R und repräsentiert reelle Zahlen als Gleitkommazahlen mit doppelter Präzision (IEEE~754). Alle numerischen Literale ohne explizites \lstinline|L|-Suffix werden automatisch als \lstinline|double| interpretiert.

\begin{lstlisting}
typeof(1)        # double
typeof(1.0)      # double
typeof(1e3)      # double
typeof(pi)       # double
0x2a             # 42, Double (hexadezimal)
\end{lstlisting}

In R ist \lstinline|numeric| kein eigener Datentyp, sondern eine Oberklasse: \lstinline|is.numeric(x)| ist \lstinline|TRUE| für sowohl \lstinline|integer| als auch \lstinline|double|. Die Funktion \lstinline|as.numeric()| erzeugt jedoch immer einen \lstinline|double|.

\begin{lstlisting}
typeof(as.numeric(1))  # double
typeof(1L)             # integer
is.numeric(1L)         # TRUE
\end{lstlisting}

\lstinline|double|-Werte können sowohl ganze Zahlen als auch Dezimalzahlen darstellen. Allerdings sind nicht alle Dezimalzahlen exakt repräsentierbar, was zu Rundungsfehlern führen kann.

\begin{lstlisting}
print(0.1, digits = 19)       # 0.1000000000000000056
print(0.2, digits = 19)       # 0.2000000000000000111
print(0.3, digits = 19)       # 0.2999999999999999889
print(0.1 + 0.2, digits = 19) # 0.3000000000000000444
0.1 + 0.2 == 0.3              # FALSE; Rundungsfehler
\end{lstlisting}

Zum Vergleich von Gleitkommazahlen sollte daher nicht \lstinline|==| verwendet werden, sondern eine Toleranz, z.\,B.\ mit \lstinline|all.equal()| oder durch explizite Schranken.

\begin{lstlisting}
all.equal(0.1 + 0.2, 0.3)     # TRUE; Einstellbare Toleranz
abs((0.1 + 0.2) - 0.3) < 1e-8 # TRUE
identical(0.1 + 0.2, 0.3)     # FALSE (exakter Vergleich)
\end{lstlisting}

Der darstellbare Wertebereich von \lstinline|double| ist sehr groß, jedoch mit endlicher Präzision. Ein double verwendet 64 Bit: 1 Bit Vorzeichen, 11 Bit Exponent und 52 Bit Mantisse, was etwa 15--16 verlässliche signifikante Dezimalstellen ermöglicht.

Ab etwa $9 \cdot 10^{15}$ können nicht mehr alle ganzen Zahlen exakt dargestellt werden. Das ist besonders problematisch bei IDs, welche dann als \lstinline|character| eingelesen werden sollten.

Die Reihenfolge von Operationen kann das Ergebnis beeinflussen, da Gleitkommaarithmetik nicht assoziativ ist.

\begin{lstlisting}
as.character(2^53)               # 9007199254740992
as.character(2^53 - 1)           # 9007199254740991
as.character(2^53 + 1)           # 9007199254740992 !
as.character(2^53 + 2)           # 9007199254740994

2^53 + 1 + 1 - 2^53              # 0
sum(2^53, 1, 1, -2^53)           # 0
sum(c(2^53, 1, 1, -2^53))        # 2

(1e16 + 1) - 1e16               # 0
1e16 + (1 - 1e16)               # 0
(1e16 - 1e16) + 1               # 1
\end{lstlisting}

\lstinline|.Machine$double.xmin| ist die kleinste positive normalisierte Gleitkommazahl. Kleinere Werte sind zwar noch darstellbar (subnormale Zahlen), besitzen jedoch eine geringere \emph{relative} Präzision, da die Anzahl verfügbarer Mantissenbits mit abnehmendem Betrag schrumpft, während die absolute Schrittweite konstant bleibt.

Die Maschinenpräzision für \lstinline|double| hängt von ihrem aktuellen Wert ab.
\lstinline|.Machine$double.eps| gibt die Präzision an, wenn der Wert \lstinline|1| ist.

Man kann die C-Funktion \lstinline|nextafter| verwenden, um die \emph{absolute} Maschinenpräzision (den Abstand zur nächsten darstellbaren Zahl) für andere Werte zu bestimmen. \lstinline|nextafter(x, Inf)| liefert die kleinstmögliche Zahl, die im Computer gerade noch größer als x darstellbar ist.

Das Addieren des Werts a zum Wert b verändert b nicht, wenn a kleiner oder gleich der Hälfte seiner Maschinenpräzision ist. Diese Eigenschaft führt zur Nicht-Assoziativität der Gleitkommaaddition.

\begin{lstlisting}
Rcpp::cppFunction("double getPrec(double x) {
  return nextafter(x,
    std::numeric_limits<double>::infinity()) - x;}")

.Machine$double.eps             # 2.220446e-16
(pr <- getPrec(1))              # 2.220446e-16
1 + pr == 1                     # FALSE
1 + pr/2 == 1                   # TRUE
1 + (pr/2 + getPrec(pr/2)) == 1 # FALSE
1 + pr/2 + pr/2 == 1            # TRUE
pr/2 + pr/2 + 1 == 1            # FALSE

.Machine$double.xmax  # 1.797693e+308
.Machine$double.xmin  # 2.225074e-308
2^-1022               # 2.225074e-308
2^-1074               # 4.940656e-324
  # kleinste positive darstellbare Zahl
getPrec(0)            # 4.940656e-324; 2^-1074
getPrec(2^-1074)      # 4.940656e-324; 2^-1074
getPrec(2^-1022)      # 4.940656e-324; 2^-1074
getPrec(2^-1021)      # 9.881313e-324; 2^-1073
getPrec(2^-1020)      # 1.976263e-323; 2^-1072

getPrecR <- function(x) {
  y <- log2(pmax(.Machine$double.xmin, abs(x)))
  ifelse(x < 0 & floor(y) == y, 2^(y-1), 2^floor(y)) *
     .Machine$double.eps
}
getPrecR(1)                     # 2.220446e-16
getPrecR(2^53)                  # 2
\end{lstlisting}

Die Beispiele illustrieren die konstante absolute Schrittweite subnormaler Zahlen sowie deren exponentielle Zunahme im normalisierten Bereich.

Die Funktion \lstinline|getPrecR| liefert für normalisierte Zahlen die wertabhängige relative Maschinenpräzision. Für subnormale Zahlen ergibt sich aufgrund der begrenzten Darstellbarkeit automatisch die konstante minimale absolute Schrittweite von $2^{-1074}$.

R kennt spezielle Werte für ungültige oder unendliche Zahlen.

\begin{lstlisting}
NaN               # Not a Number
0/0               # NaN
Inf               # Unendlich
1/0               # Inf
-Inf              # Negativ unendlich
-1/0              # -Inf
is.nan(NaN)       # TRUE
is.infinite(-Inf) # TRUE
\end{lstlisting}

Für Gleitkommazahlen mit beliebiger Genauigkeit kann das Paket \lstinline|Rmpfr| verwendet werden.

\begin{lstlisting}
library(Rmpfr)
mpfr("9007199254740992.5", 55L)  # 9007199254740992.5
mpfr("9007199254740992.75", 55L) # 9007199254740993
mpfr("9007199254740992.75", 56L) # 9007199254740992.75

format(1/3, digits=20)           # 0.33333333333333331483
mpfr(as.bigq(1L, 3L), 64)        # 0.333333333333333333342
\end{lstlisting}


\subsubsection{complex}

R besitzt einen dedizierten Datentyp für komplexe Zahlen. Die imaginäre Einheit wird als \lstinline|1i| dargestellt. Komplexe Zahlen können direkt (z.\,B. \lstinline|3+4i|), über die Funktion \lstinline|complex()| oder durch explizite Umwandlung mittels \lstinline|as.complex()| erzeugt werden. 

Ohne expliziten komplexen Anteil rechnet R im reellen Zahlenraum. Um komplexe Arithmetik zu erzwingen (z.\,B. für Wurzeln aus negativen Zahlen), muss mindestens ein Operand vom Typ \lstinline|complex| sein.

\begin{lstlisting}
3+4i                                       # 3+4i
complex(real = 3, imaginary = 4)           # 3+4i
complex(modulus = 5, argument = atan(4/3)) # 3+4i
complex(real = 1:3, imaginary = 4:6) # 1+4i 2+5i 3+6i

#sqrt(-4)      ## NaN; Warnung, reelle Rechnung
sqrt(-4+0i)          # 0+2i
sqrt(as.complex(-4)) # 0+2i

x <- 3+4i
Re(x)    # 3; Realteil
Im(x)    # 4; Imaginärteil
Mod(x)   # 5; Betrag, Modulus: sqrt(3^2 + 4^2)
Arg(x)   # 0.9272952; Phasenwinkel, Argument: atan(4/3) rad
Conj(x)  # 3-4i; konjugiert-komplexe Zahl

is.complex(x)     # TRUE
typeof(x)         # "complex"
1+2i + 3+4i       # 4+6i
(1+2i) * (3+4i)   # -5+10i
1+2i * 3+4i       #  1+10i; ! * bindet stärker als +
\end{lstlisting}


\subsubsection{character}

Der Datentyp \lstinline|character| ist in R der zentrale Typ zur Speicherung und Verarbeitung von Textdaten (Zeichenketten oder Strings). Zeichenketten werden immer in einfachen oder doppelten Anführungszeichen notiert. R kennt keinen separaten Datentyp für einzelne Zeichen. Ein einzelnes Zeichen ist einfach eine Zeichenkette der Länge~1.

Wie fast alles in R sind auch character-Objekte vektorbasiert. Die meisten Funktionen verarbeiten daher ganze Vektoren von Zeichenketten gleichzeitig (Element-weise).

Zeichenketten sind in der Datenanalyse unverzichtbar, z.\,B.\ für Variablennamen, Kategorien, Texte aus Dateien oder die Erzeugung von Berichten.

R unterstützt auch Raw-Strings mit dem Präfix \lstinline|r"()"|, bei denen Backslash-Sequenzen \emph{nicht} interpretiert werden (nützlich z. B. für reguläre Ausdrücke).

\begin{lstlisting}
'Mehr Licht'          # String mit Interpretation
"Mehr Licht"          # String mit Interpretation
r"(Mehr Licht)"       # String ohne Interpretation
""                    # leere Zeichenkette
cat("Mehr \"Licht\"") # Mehr "Licht"
cat(r"(Mehr "Licht")")# Mehr "Licht"
\end{lstlisting}

R verwendet intern einen globalen Pool eindeutiger Zeichenketten (CHARSXP), sodass identische Strings nur einmal im Speicher existieren und von Objekten gemeinsam referenziert werden.

\begin{lstlisting}
s1 <- "Mehr Licht"
s2 <- "Mehr Licht"
s3 <- "Weniger Licht"
.Internal(inspect(s1))  # @558705fa2ef8 09 CHARSXP; gleich
.Internal(inspect(s2))  # @558705fa2ef8 09 CHARSXP; gleich
.Internal(inspect(s3))  # @558705fa2ff8 09 CHARSXP; anders
\end{lstlisting}

Zeichenketten können explizit mit der Funktion \lstinline|as.character()| erzeugt werden. Dabei werden andere Datentypen in ihre textuelle Darstellung umgewandelt.

\begin{lstlisting}
as.character(42)      # "42"
as.character(TRUE)    # "TRUE"
as.character(3+4i)    # "3+4i"
\end{lstlisting}

R führt keine impliziten Konvertierungen von Strings zu Zahlen durch. Arithmetische Operationen sind daher nicht definiert.

\begin{lstlisting}
#"3" + "4"                         ## Error
as.numeric("3") + as.numeric("4")  # 7
\end{lstlisting}

Der Typ einer Zeichenkette kann mit \lstinline|is.character()| überprüft werden.

\begin{lstlisting}
x <- "a"
is.character(x)    # TRUE
typeof(x)          # "character"
class(x)           # "character"
\end{lstlisting}

Die folgenden Beispiele zeigen typische Operationen zur Verarbeitung von Zeichenketten, einschließlich Zählen, Suchen, Ersetzen, Aufteilen, Formatieren und Vergleichen von Strings.

\paragraph{Grundlegende Operationen}

Diese Funktionen dienen zur Bestimmung der Länge von Zeichenketten sowie zur elementaren Transformation einzelner Zeichen oder ganzer Strings.

\begin{lstlisting}
s <- c("Mehr", "Licht")

length(s)                  # 2; Vektor der Länge 2
nchar(s)                   # 4 5; Anzahl der Zeichen
nchar(c("a", "ä"), "bytes")# 1 2; Anzahl Bytes bei UTF-8
nzchar(s)                  # TRUE TRUE; Länge > 0

toupper(s)                 # "MEHR" "LICHT"
tolower(s)                 # "mehr" "licht"
chartr("hi", "Xy", s)      # "MeXr" "LycXt"; Zeichen austauschen
\end{lstlisting}

\paragraph{Steuerzeichen (Escape-Sequenzen)}

Innerhalb von Anführungszeichen (Strings) leitet der Backslash \lstinline|\| eine Escape-Sequenz ein. Diese Kombination wird als ein einzelnes Zeichen interpretiert.

\begin{itemize}
\item \lstinline|\n| : \emph{Newline} (Zeilenumbruch). Schiebt den nachfolgenden Text in eine neue Zeile.
\item \lstinline|\t| : \emph{Tab} (Tabulator). Erzeugt einen horizontalen Abstand.
\item \lstinline|\\| : \emph{Backslash}. Um einen echten Backslash im Text anzuzeigen, muss dieser verdoppelt werden.
\item \lstinline|\"| bzw.\ \lstinline|\'| : \emph{Anführungszeichen}. Ermöglicht die Verwendung des Begrenzer-Zeichens innerhalb des Strings.
\item \lstinline|\b| : \emph{Backspace}. Löscht das vorangegangene Zeichen.
\end{itemize}

\begin{lstlisting}[language=R]
cat("Zeile 1\nZeile 2")   # Umbruch zwischen den Worten
cat("Spalte1\tSpalte2")   # Grosser Abstand (Tab)
cat("Der Pfad ist C:\\R") # Ausgabe: Der Pfad ist C:\R
\end{lstlisting}

Informationen zu allen unterstützten Escape-Sequenzen finden sich in \lstinline|?Quotes|.

\paragraph{Encoding und Unicode}

Bei der Arbeit mit nicht-englischem Text (Umlaute, Akzente, Sonderzeichen) spielen Zeichencodierung und Locale eine große Rolle. Für die korrekte Verarbeitung internationaler Zeichen bietet R Funktionen zur Arbeit mit Unicode, Bytes und Zeichencodierungen.

\begin{lstlisting}
charToRaw("ä")              # c3 a4; UTF-8 Bytes
s <- "\u00e4"               # Unicode-Escape für "ä"

iconv("Müller", "UTF-8", "latin1") # Encoding ändern
utf8ToInt("ä")              # 228
intToUtf8(228)              # "ä"
\end{lstlisting}

\paragraph{Sortierung und Locale}

Die lexikographische Sortierung von Zeichenketten hängt von der aktuellen Locale ab und kann sprach- und systemspezifisch variieren.

\begin{lstlisting}
s <- c("ä", "a", "b")

Sys.setlocale("LC_COLLATE", "C")   # ASCII-Reihenfolge
sort(s)                            # "a" "b" "ä"
"ä" < "z"                          # FALSE

Sys.setlocale("LC_COLLATE", "de_AT.UTF-8")
sort(s)                            # "a" "ä" "b"
"ä" < "z"                          # TRUE
\end{lstlisting}

\paragraph{Ersetzen und Bereinigen}

Die folgenden Funktionen erlauben das gezielte Ersetzen von Teilstrings sowie das Bereinigen von Texten, etwa durch Entfernen überflüssiger Leerzeichen.

\begin{lstlisting}
sub("a", "xz", "aba")     # "xzba"; erstes Vorkommen ersetzen
gsub("a", "xz", "aba")    # "xzbxz"; alle Vorkommen
gsub("([ac])", "<\\1>", "abc") # "<a>b<c>"; Treffer verwenden
gsub("\\s+", " ", "a  b") # "a b"; Mehrfach-Leerzeichen=> " "
trimws("  Text  ")        # "Text"; führende/trailing Spaces
\end{lstlisting}

\paragraph{Zusammenfügen und Formatieren}

Zum Erzeugen neuer Zeichenketten können Strings kombiniert, zerlegt oder mithilfe von Formatvorlagen zusammengesetzt werden.

\begin{lstlisting}
s <- c("Mehr", "Licht")
toString(s)                # "Mehr, Licht"; mit ", " verbunden
s <- paste(s[1], s[2])     # "Mehr Licht"
strsplit(s, " ", TRUE)     # Liste: "Mehr" "Licht"; Trennt String

paste(c("A","B","C"), collapse=", ") # "A, B, C"
paste("A", 1:3, sep="-")   # "A-1" "A-2" "A-3"
paste0("A", 1:3)           # "A1" "A2" "A3"; sep=""
paste0("A", 1:3, collapse="-")  # "A1-A2-A3"
sprintf("Pi: %0.2f", pi)   # "Pi: 3.14"; formatiert
\end{lstlisting}

\lstinline|strsplit| gibt immer eine \lstinline|list| zurück.

\paragraph{Teilstrings und Tests}

Teilstrings können extrahiert oder ersetzt werden; zusätzlich lassen sich Anfangs- und Endmuster von Zeichenketten überprüfen.

\begin{lstlisting}
s <- c("Mehr Licht")
substr(s, 1, 4)            # "Mehr"
substring(s, 6)            # "Licht"
substr(s, 1, 4) <- "Weniger"
s                           # "Weni Licht"; Teil ersetzt

strtrim(s, 3)              # "Wen"; auf Länge kürzen
startsWith(s, "Wen")       # TRUE; beginnt mit
endsWith(s, "ht")          # TRUE; endet mit
\end{lstlisting}

\paragraph{Suchen und Vergleichen}

R stellt Funktionen bereit, um Zeichenketten nach festen Mustern oder regulären Ausdrücken zu durchsuchen und Übereinstimmungen zu testen oder zu extrahieren.

Mit \lstinline|fixed=TRUE| wird kein Regex verwendet, sondern eine exakte Zeichenkette gesucht.
Mit \lstinline|ignore.case=TRUE| wird die Groß-/Kleinschreibung ignoriert.

\begin{lstlisting}
s <- c("Mehr", "Licht")
grepl("c.", s)             # FALSE TRUE; Regex "c."
grepl("c.", s, fixed=TRUE) # FALSE FALSE; fester String "c."
grep("ch", s)              # 2; Index des Treffers
grep("ch", s, value=TRUE)  # "Licht"; Trefferwert
grepl("me", s)             # FALSE FALSE
grepl("me", s, ignore.case=TRUE) # TRUE FALSE

agrep("Meer", s)           # 1; Ungefähre Übereinstimmung
adist("Meer", s)           # 1 5; String-Abstände
\end{lstlisting}

\paragraph{Reguläre Ausdrücke}

Reguläre Ausdrücke (Regular Expressions, kurz \emph{Regex}) dienen dazu, Suchmuster für Zeichenketten zu beschreiben. Sie ermöglichen es, Text gezielt zu durchsuchen, Treffer zu extrahieren oder diese zu verändern. In R werden reguläre Ausdrücke unter anderem in folgenden Funktionen verwendet:

\begin{itemize}
\item \lstinline|grep| \dots gibt Indizes der Treffer zurück
\item \lstinline|grepl| \dots gibt logischen Vektor zurück
\item \lstinline|sub| \dots ersetzt ersten Treffer
\item \lstinline|gsub| \dots ersetzt alle Treffer
\item \lstinline|regexpr| \dots Position des ersten Treffers
\item \lstinline|gregexpr| \dots Positionen aller Treffer
\item \lstinline|regexec| \dots Position des ersten Treffers inklusive aller Capture Groups
\end{itemize}

\subparagraph{Wichtige Metazeichen regulärer Ausdrücke}

Im Folgenden sind die wichtigsten Metazeichen zusammengefasst:

\begin{itemize}
\item \lstinline|.| \dots Steht für genau ein beliebiges Zeichen (außer Zeilenumbruch).
\item \lstinline|*| \dots Wiederholt das vorherige Zeichen null- oder mehrmals.
\item \lstinline|+| \dots Ein- oder mehrfache Wiederholung des vorherigen Zeichens.
\item \lstinline|?| \dots Null- oder einmal Wiederholung des vorherigen Zeichens.
\item \lstinline|.*| \dots Kombination aus Punkt und Stern. Steht für eine beliebige Anzahl beliebiger Zeichen. \lstinline|.*| ist gierig und matched so viel wie möglich.
\item \lstinline|.*?| \dots ist genügsam (nicht gierig) und matched so wenig wie möglich.
\item \lstinline|{n}|, \lstinline|{n,m}| \dots Gibt an, wie oft das vorherige Zeichen wiederholt werden soll. \lstinline|{n}| genau n-mal, \lstinline|{n,m}| mindestens n-mal, höchstens m-mal, \lstinline|{n,}| mindestens n-mal, nach oben offen.
\item \lstinline|[ ]| \dots Zeichenklasse: trifft auf eines der angegebenen Zeichen.
\item \lstinline|[^ ]| \dots Negierte Zeichenklasse: trifft auf alle Zeichen \emph{außer} den angegebenen.\\
Typische Klassen sind:
  \begin{itemize}
  \item \lstinline|[a-z]| \dots Kleinbuchstaben
  \item \lstinline|[A-Z]| \dots Großbuchstaben
  \item \lstinline|[0-9]| \dots Ziffern
  \item \lstinline|\\d| \dots Ziffer (entspricht [0-9])
  \item \lstinline|\\D| \dots Keine Ziffer
  \item \lstinline|\\s| \dots Whitespace (Leerzeichen, Tab, Zeilenumbruch)
  \item \lstinline|\\S| \dots Kein Whitespace
  \item \lstinline|\\w| \dots „Word“-Zeichen (Buchstaben, Ziffern, Unterstrich)
  \item \lstinline|\\W| \dots Kein Word-Zeichen
  \item \lstinline|\\b| \dots Wortgrenze (Anfang oder Ende eines Wortes).
  \end{itemize}
\item \lstinline|\\| \dots Backslash zum Escapen von Metazeichen. In R-Strings muss ein Backslash verdoppelt werden, um ein Sonderzeichen zu escapen.
\item \lstinline{|} \dots Alternative (oder): trifft auf das linke oder rechte Muster.
\end{itemize}

PCRE unterstützt Inline-Modifier:
\begin{itemize}
\item \lstinline|(?i)| – ignore case
\item \lstinline|(?m)| – multiline (\lstinline|^| und \lstinline|$| zeilenweise)
\item \lstinline|(?s)| – Dot matches newline
\end{itemize}

Quantifizierer sind standardmäßig gierig und erfassen so viele Zeichen wie möglich. Durch ein angehängtes Fragezeichen werden sie nicht gierig. 

Bei Verwendung von Raw-Strings werden Backslashes nicht verdoppelt:: \lstinline|grep(r"(\d+)", x)| statt \lstinline|grep("\\\\d+", x)|.

\begin{lstlisting}
grep("L.cht", c("Licht", "Lacht", "Leicht"))          # 1 2
grep("Li*", c("L", "Li", "Liii", "Licht"))            # 1 2 3 4
grep("L.*t$", c("Licht", "Lacht", "Leute"))           # 1 2
grep("colou?r", c("color", "colour", "colur"))        # 1 2
grep("i{2}", c("viel", "pii", "iiii"))                # 2 3
grep("[aeiou]", c("Mehr", "Licht"))                   # 1 2
grep("[^0-9]", c("123", "abc", "a1"))                 # 2 3
grep("i+", c("L", "Li", "Liii"))                      # 2 3
grep("\\.", c("Datei.txt", "Version2", "readme"))     # 1
grep("\\d+", c("123", "abc", "a1b2"), perl=TRUE)      # 1 3
grep("Licht|Goethe", c("Mehr Licht", "Faust", "Licht")) # 1 3
sub("b.*", "", "abc")                                 # a
sub("b.*?", "", "abc")                                # ac
grep("\\bTag\\b", c("Guten Tag", "Tageslicht"))       # 1

s <- c("Mehr", "Licht")
i <- regexpr("[eih]", s)   # Erster Treffer von e, i oder h
regmatches(s, i)           # "e" "i"; Treffer ausgeben

i <- gregexpr("[eih]", s)  # Alle Treffer von e, i oder h
regmatches(s, i)           # "e" "h", "i" "h"

s1 <- lapply(regmatches(s, i), \(x) paste0("<", x, ">"))
regmatches(s, i) <- s1     # Treffer überschreiben
s                          # "M<e><h>r" "L<i>c<h>t"
\end{lstlisting}

\subparagraph{Anker für Anfang und Ende}

Mit \lstinline|^| und \lstinline|$| kann der Anfang bzw. das Ende einer Zeichenkette festgelegt werden.

\begin{lstlisting}
grep("^L.*t$", c("Licht", "Last", "Leute", "Land"))  # 1 2
\end{lstlisting}

Im Perl-Modus (perl=TRUE) gibt es zudem die Anker \lstinline|\A| und \lstinline|\z|. \lstinline|^| und \lstinline|$| matchen standardmäßig den Anfang/Ende des gesamten Strings. Im Multiline-Modus (\lstinline|(?m)|) matchen sie jedoch den Anfang/Ende jeder einzelnen Zeile innerhalb eines Strings. \lstinline|\A| und \lstinline|\z| Matchen immer nur den absoluten Anfang bzw.\ das absolute Ende des gesamten Strings, unabhängig vom Multiline-Modus.

\begin{lstlisting}
text <- "Zeile 1\nZeile 2\nZeile 3"
grep("^Zeile", text, value = TRUE)
  # "Zeile 1\nZeile 2\nZeile 3"
gsub("(?m)^Zeile", "ID", text, perl = TRUE)
  # "ID 1\nID 2\nID 3"
gsub("(?m)\\AZeile", "ID", text, perl = TRUE)
  # "ID 1\nZeile 2\nZeile 3"
\end{lstlisting}

\subparagraph{Gruppierung und Extraktion von Teilen}

Runde Klammern \lstinline|( )| bilden \emph{Capture Groups}. Diese können später mit Backreferences \lstinline|\1|, \lstinline|\2| usw. referenziert werden oder zum Extrahieren von Teiltreffern dienen. Daher müssen man Klammern escapen um sie suchen zu können \lstinline|\\(| \lstinline|\\)|.

\begin{lstlisting}
gsub("([A-Z])([a-z]+)", "\\2\\1", c("Mehr", "Licht"))
  # "ehrM" "ichtL"; (Großbuchstabe und Rest vertauscht)

gsub("([a-z])(\\d+)", "\\1_\\2", c("abc123", "xyz99"))
  # "abc_123" "xyz_99"

s <- c("Preis: 10€", "Preis: 25$")
m <- gregexpr("(\\d+)([€$])", s)
regmatches(s, m)  # 10€, 25$
\end{lstlisting}

\subparagraph{Quantifizierer auf Gruppen}

Auch ganze Gruppen können quantifiziert werden. Zum Beispiel
\lstinline|(ab){2}| sucht nach zwei aufeinanderfolgenden Wiederholungen der Gruppe \lstinline|ab|, also nach \lstinline|abab|. 
Analog funktionieren auch die anderen Quantifizierer:

\begin{itemize}
  \item \lstinline|(ab){3}|: genau dreimal hintereinander \lstinline|ababab|
  \item \lstinline|(ab){2,4}|: mindestens 2, höchstens 4 Wiederholungen, also \lstinline|abab|, \lstinline|ababab| oder \lstinline|abababab|
  \item \lstinline|(ab){2,}|: mindestens 2 Wiederholungen, also \lstinline|abab|, \lstinline|ababab|, \lstinline|abababab| usw.
\end{itemize}

\subparagraph{TRE vs. PCRE}

Ohne Angabe von \lstinline|perl=TRUE| wertet R reguläre Ausdrücke mit der \emph{TRE (Tiny Regex Engine)} aus. Diese unterstützt nur grundlegende Konstrukte.

Mit \lstinline|perl=TRUE| wird die leistungsfähigere \emph{PCRE (Perl Compatible Regular Expressions)} verwendet, die erweiterte Funktionen wie Lookahead oder Lookbehind ermöglicht.

\begin{lstlisting}
s <- c("foo1", "foo2", "bar3")
#grep("foo(?=\\d)", s)   ## Error; TRE unterstützt kein Lookahead
grep("foo(?=\\d)", s, perl=TRUE) # 1 2
\end{lstlisting}

\subparagraph{Lookahead und Lookbehind (Lookaround)}

Lookaround-Konstrukte sind sogenannte „Zero-Width Assertions“. Sie prüfen, ob ein Muster vor oder nach dem aktuellen Zeichen vorhanden ist, ohne diese Zeichen selbst als Teil des Treffers zu „verbrauchen“ (\emph{non-consuming}). Sie prüfen das Muster an der aktuellen Position, ohne Zeichen zu konsumieren oder die Match-Position zu verändern. Lookarounds beeinflussen also nur die Gültigkeit eines Matches, nicht dessen Ausdehnung.

Dies ist besonders nützlich, wenn man ein Muster nur dann finden möchte, wenn es in einem bestimmten Kontext steht, den Kontext selbst aber nicht verändern oder extrahieren will.

Lookaround-Unterstützung erfordert in R den Perl-kompatiblen Modus: \lstinline|perl = TRUE|.

\begin{itemize}
\item \lstinline|(?=...)| \dots Positiver Lookahead: Schaut nach vorne, ob das Muster folgt.
\item \lstinline|(?!...)| \dots Negativer Lookahead: Schaut nach vorne, ob das Muster \textbf{nicht} folgt.
\item \lstinline|(?<=...)| \dots Positiver Lookbehind: Schaut zurück, ob das Muster vorhergeht.
\item \lstinline|(?<!...)| \dots Negativer Lookbehind: Schaut zurück, ob das Muster \textbf{nicht} vorhergeht.
\end{itemize}

\begin{lstlisting}
s <- c("Preis: 10€", "Preis: 20$", "100 Personen")
gsub("\\d+(?=€)", "XXX", s, perl = TRUE)
  # "Preis: XXX€"  "Preis: 20$"   "100 Personen"
gsub("\\d+\\b(?![€$])", "XXX", s, perl = TRUE)
  # "Preis: 10€"   "Preis: 20$"   "XXX Personen"
gsub("(?<=Preis: )\\d+", "XXX", s, perl = TRUE)
  # "Preis: XXX€"  "Preis: XXX$"  "100 Personen"

x <- c("Preis: 10€", "Rabatt: -10€", "Preis: 20€")
gsub("(?<!-)\\b\\d+\\b(?=€)", "XXX", x, perl = TRUE)
  # "Preis: XXX€"  "Rabatt: -10€" "Preis: XXX€"

strsplit("aaa", "a")[[1]]                   # "" "" ""
strsplit("aaa", "(?=a)", perl = TRUE)[[1]]  # "a" "a" "a"
\end{lstlisting}

Da Lookaround-Ausdrücke \emph{non-consuming} sind, können sie verwendet werden, um überlappende Muster zu finden oder mehrere Bedingungen gleichzeitig an derselben Textstelle zu prüfen. Während ein normaler Ausdruck wie \lstinline|a.b| die Zeichenkette „verbraucht“, prüft ein Lookaround nur die Bedingung und lässt den „Lese-Cursor“ für den nächsten Teil des regulären Ausdrucks an derselben Stelle stehen.

In der PCRE-Engine (die durch \lstinline|perl=TRUE| genutzt wird) müssen Lookbehinds (\lstinline|(?<=...)| und \lstinline|(?<!...)|) in der Regel eine feste Länge haben. Dort können also kein \lstinline|*| oder \lstinline|+| innerhalb der Klammern verwendet werden.

\subparagraph{Klammern}

Um den Text innerhalb von Klammern zu extrahieren, verwendet man Capture Groups \lstinline|()|. Da Klammern in Regex Sonderzeichen sind, müssen sie mit \lstinline|\\| maskiert werden.

\begin{lstlisting}
s <- "abc (de) fg hij (klm) nop"

m <- gregexpr("\\(.*?\\)", s)     # *? .. non Greedy
regmatches(s, m)    # (de) (klm)

m <- gregexpr("\\([^)]*\\)", s)   # [^)] .. kein )
regmatches(s, m)    # (de) (klm)
\end{lstlisting}

Der Ausdruck \lstinline|(?R)| ruft das gesamte Muster rekursiv auf. Dies ist notwendig, um verschachtelte Klammern (z.\,B.\ \lstinline|(a(b)c)|) korrekt zu verarbeiten.

\begin{lstlisting}
s <- "(abc (de (fg) hij) klm (nop) qrs ((tuv)) wxy () z"

m <- gregexpr("\\((?:[^()]+|(?R))*\\)", s, perl = TRUE)
regmatches(s, m)  # "(de (fg) hij)" "(nop)" "((tuv))" "()"
\end{lstlisting}

Die erste öffnende Klammer hat keine schließende und passt daher nicht in das Suchmuster, das ausschließlich gepaarte Klammern findet.

\begin{itemize}
\item \lstinline|\\(| \dots Beginne bei einer öffnenden Klammer.
\item \lstinline|(?: ... )*| \dots Eine Non-Capturing Group (gruppiert, ohne den Index zu belegen, \lstinline|( ... )*| ginge auch), die sich beliebig oft wiederholt. Sie sucht entweder:
  \begin{itemize}
  \item \lstinline|[^()]| \dots Zeichen, die keine Klammern sind, oder
  \item \lstinline|(?R)| \dots ruft das gesamte Muster rekursiv erneut auf, um eine verschachtelte Klammerstruktur, oder andere Patterns, zu erkennen.
  \end{itemize}
\item \lstinline|\\)| \dots Schließe die äußere Klammer ab.
\end{itemize}

Bei Verwendung einer normalen Capturing Group \lstinline|( ... )*| würden Capture Groups erzeugt. Diese wären über Backreferences \lstinline|\1|,  \lstinline|\2| usw.\ ansprechbar,

\subparagraph{Mehrfaches Ersetzen}

Durch Kombination von regulären Ausdrücken und Ersetzungsregeln lassen sich mehrere Zeichen oder Muster in einem Schritt transformieren.

\begin{lstlisting}
s <- c("abcd", "dcba")
r <- c(ef="a", gh="c")     # a => ef, c => gh
i <- gregexpr(paste(r, collapse="|"), s)
s1 <- lapply(regmatches(s, i), \(x) names(r)[match(x, r)])
regmatches(s, i) <- s1
s                          # "efbghd" "dghbef"
\end{lstlisting}

\paragraph{Ausgabe und fehlende Werte}

Das Ausgabeformat von Zeichenketten sowie der Umgang mit fehlenden Werten (`NA`) lassen sich gezielt beeinflussen.

\begin{lstlisting}
s <- noquote(c("Ab", "C"))  # Ausgabe ohne Anführungszeichen
s                           # Ab C

s <- c("Ab", NA, "C")
paste("x", s, sep="-")     # "x-Ab" "x-NA" "x-C"; NA als Text
\end{lstlisting}


\subsubsection{raw}

Der Datentyp \lstinline|raw| dient in R der Speicherung und Verarbeitung von Binärdaten auf Byte-Ebene. Jedes Element belegt genau ein Byte und kann Werte von 0 bis 255 annehmen. Intern werden die Werte als Bytes gespeichert, bei der Ausgabe jedoch standardmäßig als zweistellige hexadezimale Zahlen (Kleinbuchstaben ohne Präfix \lstinline|0x|) dargestellt (z.\,B. \lstinline|00| bis \lstinline|ff|).

Dieser Typ wird primär für die Arbeit mit binären Daten verwendet. Während arithmetische Operationen (\lstinline|+|, \lstinline|*| etc.) nicht unterstützt werden, sind bitweise logische Operationen möglich.

Wichtige Funktionen zur Erzeugung und Konvertierung:

\begin{lstlisting}[language=R]
as.raw(97)             # Zahl zu Byte: 61
charToRaw("a")         # Zeichen 'a' (ASCII) -> 61
rawToChar(as.raw(97))  # Byte zurück zu Zeichen: "a"
raw(5)                 # Erzeugt Null-Bytes: 00 00 00 00 00
as.integer(as.raw(10)) # Konvertierung zum Rechnen

x <- as.raw(97)        #     Binär: 0110 0001
y <- as.raw(98)        #     Binär: 0110 0010
x & y                  # 60; Binär: 0110 0000)
x | y                  # 63; Binär: 0110 0011)
\end{lstlisting}


\subsubsection{NA -- Fehlende Werte}

In der Praxis sind Datensätze oft unvollständig (z.\,B.\ nicht beantwortete Umfragen oder Sensorfehler). R verwendet hierfür den speziellen Wert \lstinline|NA| (\emph{not available}). \lstinline|NA| ist kein eigener Datentyp, sondern ein spezieller Wert, der für jeden atomaren Typ existiert.

\paragraph{Typisierung von NA}

Da atomare Vektoren homogen sind, gibt es für jeden Grundtyp eine technisch eigene Variante von \lstinline|NA|. Das unqualifizierte \lstinline|NA| hat den Typ \lstinline|logical| und ist damit die einfachste Form eines fehlenden Wertes. Dies ist der Standardfall und wird in den meisten Situationen automatisch in den benötigten Typ umgewandelt (\emph{Coercion}).

\begin{lstlisting}
NA              # logical NA (Standardfall)
NA_integer_     # integer NA
NA_real_        # double NA (numeric)
NA_character_   # character NA

typeof(1L + TRUE)         # integer
typeof(1L + NA)           # integer; NA wird zu NA_integer_
typeof(1L + 1.5)          # double
typeof(1L + NA_real_)     # double; Integer wird zu double
\end{lstlisting}

\paragraph{Propagation und Logik}

Bei den meisten arithmetischen, logischen und Vergleichsoperationen propagiert R das \lstinline|NA|, d.\,h.\ das Ergebnis wird ebenfalls \lstinline|NA|. R nutzt zudem eine \emph{dreiwertige Logik}. Ein Ergebnis ist nur dann eindeutig (\lstinline|TRUE| oder \lstinline|FALSE|), wenn es unabhängig vom unbekannten Wert feststeht:

\begin{lstlisting}
NA && FALSE    # FALSE; bereits ein FALSE entscheidet
NA && TRUE     # NA
NA || TRUE     # TRUE; bereits ein TRUE entscheidet
NA || FALSE    # NA
\end{lstlisting}

\paragraph{Zuweisen}

Genauso wie man Werte in einem Vektor zuweisen kann, kann man auch \lstinline|NA| zuweisen. Alternativ lässt sich dafür die Funktion \lstinline|is.na()| verwenden.

\begin{lstlisting}
x <- 1:5
x[1] <- NA      # Erster Wert wird NA
is.na(x) <- 3:4 # 3-4 werden NA
x               # NA 2 NA NA 5
\end{lstlisting}

\paragraph{Vergleich und Prüfung}

Da \lstinline|NA| unbekannt ist, liefert der Vergleich \lstinline|NA == NA| folgerichtig \lstinline|NA|. Man kann nicht wissen, ob zwei unbekannte Werte identisch sind. Zur Prüfung auf fehlende Werte muss die vektorisierte Funktion \lstinline|is.na()| verwendet werden. Viele Funktionen besitzen einen \lstinline|na.rm|-Parameter, um fehlende Werte zu ignorieren.

\begin{lstlisting}
x <- c(1, NA, 3)
x == NA            # NA NA NA
is.na(x)           # FALSE TRUE FALSE
anyNA(x)           # TRUE
x + 1              # 2 NA 4
sum(x)             # NA
sum(x, na.rm=TRUE) # 4
na.omit(x)         # 1 3; entfernt NA und setzt ein Attribut
na.exclude(x)      # 1 3; entfernt NA und setzt ein Attribut
x[!is.na(x)]       # 1 3
\end{lstlisting}

\paragraph{Abgrenzung}
\begin{itemize}
  \item \lstinline|NULL|: Repräsentiert ein leeres Objekt oder die Abwesenheit eines Wertes (kann nicht Teil eines Vektors sein).
  \item \lstinline|NaN|: Not a Number (z.\,B.\ \lstinline|0/0|). Mathematisch undefiniert. \lstinline|is.na()| erkennt auch \lstinline|NaN| als fehlend, aber \lstinline|is.nan()| erkennt kein \lstinline|NA|.
  \item \lstinline|Inf|, \lstinline|-Inf|: Repräsentieren unendliche numerische Werte, gelten nicht als fehlend.
\end{itemize}

Im Gegensatz zu \lstinline|NA| wird \lstinline|NULL| beim Zusammenfügen von Vektoren einfach entfernt.

\begin{lstlisting}
is.na(NaN)        # TRUE
is.nan(NaN)       # TRUE
is.nan(NA)        # FALSE
c(1, 2, NULL, 4)  # 1 2 4  (NULL wird entfernt)
\end{lstlisting}


\subsection{NULL}

In R gibt es die Möglichkeit \emph{Nichts} (die vollständige Abwesenheit eines Objekts) mittels \lstinline|NULL| und \emph{fehlende Information} (ein Platzhalter für einen existierenden, aber unbekannten Wert) mittels \lstinline|NA| darzustellen.

Im Gegensatz zu \lstinline|NA| ist \lstinline|NULL| ein eigenständiger Typ mit genau einem möglichen Wert. Es hat Länge 0, keinen Inhalt und ist definitionsgemäß kein atomarer Vektor. \lstinline|NULL| steht für ein Objekt ohne Wert oder Inhalt und kann für leere Rückgaben, optionale Funktionsargumente oder das Löschen von Einträgen verwendet werden.

\begin{lstlisting}
is.null(NULL)   # TRUE
NULL == NULL    # logical(0)
typeof(NULL)    # "NULL"
length(NULL)    # 0
length(NA)      # 1
is.atomic(NULL) # FALSE
is.vector(NULL) # FALSE
x <- NULL
y <- 1
x %||% y        # 1; if (is.null(x)) y else x
\end{lstlisting}

\lstinline|NULL| ist kein gültiges Vektorelement, sondern steht für die Abwesenheit eines Objekts. Beim Kombinieren von Elementen mittels \lstinline|c()| wird \lstinline|NULL| entfernt. Die Indizierung mit \lstinline|NULL| (z.\,B.\ \lstinline|x[NULL]|) selektiert keine Elemente und ergibt daher stets einen leeren Vektor des entsprechenden Typs.

\begin{lstlisting}
x <- c(1, NULL, 3, 4) # 1 3 4; NULL wird entfernt
#x[2] <- NULL         ## Error
x[NULL]               # numeric(0); NULL selektiert nichts
x[2] <- list(NULL)    # Wandelt Vector x in Liste um
\end{lstlisting}

\lstinline|NULL| kann zum Löschen von Listenelementen oder Data-Frame-Spalten verwendet werden.

\begin{lstlisting}
x <- list(1, NULL, 3) # [[1]] 1  [[2]] NULL  [[3]] 3
unlist(x)             # 1 3; NULL wird bei Vektor entfernt
x[[3]] <- NULL        # Löscht drittes Element
x[2] <- NULL          # Löscht zweites Element
x[1] <- list(NULL)    # Fügt NULL ein

x <- data.frame(a=1:2, b=3:4)
x$c <- list(NULL, 2)  # Fügt neue Liste ein
x$b <- NULL           # Löscht Spalte b
x["a"] <- NULL        # Löscht Spalte a
#x[2,] <- NULL        ## Error
x[, "c"] <- NULL      # Löscht Spalte c

x <- as.list(1:5)
%||%
\end{lstlisting}

Funktionen können \lstinline|NULL| zurückgeben, wenn sie nichts zurückzugeben haben. Ebenso wird \lstinline|NULL| oft als Standardwert für optionale Funktionsargumente verwendet, um das Fehlen eines Eingabewerts zu signalisieren.

\begin{lstlisting}
x <- list()
x$foo              # NULL

y <- if (FALSE) 1
y                  # NULL

(\() {})()         # NULL

x <- c(3, NA, 1)
order(x)                  # 3 1 2
order(x, na.last = TRUE)  # 3 1 2
order(x, na.last = FALSE) # 2 3 1
order(x, na.last = NULL)  # 3 1

f <- \(x = NULL) if (is.null(x)) print("Kein Argument.")
f()               # "Kein Argument."
f <- \(x) if (is.null(x)) print("Kein Argument.")
#f()              ## Error, Argument "x" fehlt
f(NULL)           # "Kein Argument."
\end{lstlisting}


\subsection{Liste}

Während atomare Vektoren nur Werte eines einzigen Typs aufnehmen können, dienen Listen als flexible Container zur gemeinsamen Speicherung unterschiedlicher R-Objekte.

Eine Liste ist ein spezieller Vektor, dessen Elemente Zeiger auf beliebige R-Objekte sind. Auf der Speicherebene ist eine Liste damit homogen, da alle Elemente Zeiger sind. Auf Benutzerebene erlaubt sie jedoch heterogene Inhalte, da diese Zeiger auf Objekte beliebiger Typen, Längen und Strukturen, einschließlich weiterer Listen oder \lstinline|NULL|, verweisen können. Listen werden daher auch als \emph{rekursive} oder \emph{generische} Vektoren bezeichnet.


\begin{lstlisting}
x <- list(1, 2L)
is.atomic(x)         # FALSE
is.list(x)           # TRUE
is.vector(x)         # TRUE
is.recursive(x)      # TRUE
\end{lstlisting}


\subsubsection{Erzeugen von Listen}

Listen werden mit \lstinline|list()| erzeugt. Alternativ lässt sich mit \lstinline|vector("list", n)| eine leere Liste fester Länge erzeugen, was beispielsweise vor Schleifen verwendet werden kann, um ein ineffizientes schrittweises Vergrößern zu vermeiden.

\begin{lstlisting}
list(1, "a", NULL, c(1, 2)) # Liste mit verschiedenen Typen
vector("list", 3)           # Leere Liste mit 3 Elementen
\end{lstlisting}

Beim Zusammenfügen von Listen mit \lstinline|c()| werden die Elemente der Listen auf oberster Ebene zusammengeführt (kein Verschachteln). Im Gegensatz zu Vektoren findet dabei \emph{keine Typkonvertierung} statt. Wird ein atomarer Vektor mit einer Liste kombiniert, konvertiert R den Vektor erst in eine Liste und führt sie dann zusammen. Bei gleichen Namen bleibt die Reihenfolge erhalten, und es kann zu mehrfach vergebenen Namen kommen.

\begin{lstlisting}
c("a", list(2, 3))    # Liste mit 3 Elementen: "a", 2, 3
c(list("a"), list(2, 3)) # Ident, explizit
l <- list(a = 1:3, b = c("x", "y"), c = TRUE)
l2 <- list(a = 1, b = 2)
l3 <- c(l, l2)        # Hier gibt es zweimal a und b
l3[["a"]]             # 1 2 3; erster Treffer
l3[names(l3) == "a"]  # Alle Treffer
l2[c(1, 1)]           # Erstes Element doppelt
  # Namen bleiben unverändert
replicate(2, 1:3, simplify=FALSE) # n-mal wiederholen
                      # [[1]] 1 2 3  [[2]] 1 2 3
\end{lstlisting}

Elemente können auch Namen haben, über die auf sie zugegriffen werden kann.
Mit \lstinline|names()| können Namen abgefragt oder gesetzt werden.
Namen können bei bestehenden Listen mit \lstinline|setNames()| gesetzt werden.
Mit \lstinline|unname()| können Namen entfernt werden.

\begin{lstlisting}
x <- list(1, 3, 2)
names(x)         # NULL
names(x) <- c("a", "c", "b")
names(x)         # a c b
unname(x)        # Liste ohne Namen
names(x) <- NULL # Namen Löschen
setNames(x, c("a", "c", "b"))  # Liste mit Namen

x <- list(a = 1, c = 3, b = 2)
x[1]             # Gibt Liste mit Namen
dput(x[1])       # list(a = 1)
x[1] <- 7        # Name bleibt erhalten
dput(x[1])       # list(a = 7)
x[1] <- list(z = 0) # z wird ignoriert
dput(x[1])       # list(a = 0)
x[[1]] <- 9      # Muss in zwei Schritten erfolgen
names(x)[1] <- "z"
dput(x[1])       # list(z = 9)
\end{lstlisting}


\subsubsection{Zugriff auf Listenelemente}

Der Zugriff auf Listenelemente erfolgt analog zu Vektoren mit \lstinline|[ ]| und \lstinline|[[ ]]|. Zusätzlich kann bei benannten Elementen der Operator \lstinline|$| verwendet werden. Mit \lstinline|[ ]| können beliebig viele Elemente ausgewählt werden, wobei immer eine Liste zurückgegeben wird, während \lstinline|[[ ]]| bzw.\ \lstinline|$| jeweils genau ein Element extrahieren und das eigentliche Objekt liefern. \lstinline|[ ]| behält die Listenstruktur bei, \lstinline|[[ ]]| entfernt sie. \lstinline|l$a| findet auch ein Element \lstinline|l$afel|, wenn es kein anderes Element gibt, das mit \lstinline|a| beginnt. Beim Zuweisen findet hingegen kein Partial Matching statt. Dort wird ein neues Element mit diesem Namen erzeugt.

\begin{itemize}
  \item \lstinline|[ ]| wählt beliebig viele Elemente aus und liefert eine \emph{Liste}
  \item \lstinline|[[ ]]| extrahiert genau ein \emph{Element}
  \item \lstinline|$| extrahiert über den Namen genau ein \emph{Element}
\end{itemize}

\begin{lstlisting}
l <- list(a=1, b=c(a=2, b=3, c=4), c="Licht")

l[2]            # 2 3 4; Liste mit zweitem Element
l[[2]]          # 2 3 4; Zweites Element
l[[2]][[1]]     # 2; Zweites Element, erster Eintrag
l[[c(2, 1)]]    # 2; Zweites Element, erster Eintrag
l[[c("b", "a")]]# 2; Element b, Eintrag a
#l[[1,2]]       ## Fehler, falsche Anzahl Subscripts

l$b             # 2 3 4; Element b
l["b"]          # 2 3 4; Liste mit Element b
l[["b"]]        # 2 3 4; Element b
l[["b"]]["a"]   # 2; Element b, Eintrag a mit Namen
l[["b"]][["a"]] # 2; Element b, Eintrag a ohne Namen
i <- "b"
l[i]            # 2 3 4; Element b
l$i             # NULL; sucht nach i

l <- list(apfel=1)
l$a             # 1; findet apfel
l$a <- 2        # Erzeugt a
l$a             # 2; findet jetzt a
\end{lstlisting}

Mehrere Elemente können wie bei Vektoren ausgewählt werden:

\begin{lstlisting}
l <- list(a=1, b=c(a=2, b=3, c=4), c="Licht")
l[1:2]          # Liste mit Element 1 und 2
l[c("a", "c")]  # Liste mit Element a und c
l[-2]           # Liste ohne zweites Element
l[c(TRUE, FALSE)] # Jedes zweite Element
\end{lstlisting}

Ungültige Indizes liefern bei \lstinline|[ ]| eine Liste, deren Element \lstinline|NULL| ist, bei \lstinline|[[ ]]| hingegen einen Fehler. Der Operator \lstinline|$| liefert bei nicht existierenden Namen das Element \lstinline|NULL|.

\begin{lstlisting}
l <- list(a=1, b=c(a=2, b=3, c=4), c="Licht")
l[4]                # NULL; Liste
# l[[4]]            ## Fehler
l$x                 # NULL; Element
is.null(list(NULL)) # FASLE; Ist eine Liste
is.null(l[4])       # FASLE; Ist eine Liste
is.null(l$x)        # TRUE
\end{lstlisting}

Verschachtelte Listen können komfortabel mit \lstinline|$| adressiert werden:

\begin{lstlisting}
l <- list(x = 1, y = list(z = 2, w = 3))
l$y$z           # 2
\end{lstlisting}


\subsubsection{Längen und Inhalte}

Die Länge einer Liste ist die Anzahl ihrer Elemente.
Mit \lstinline|lengths()| erhält man die Länge jedes einzelnen Elements.
Zur strukturellen Übersicht komplexer Listen eignet sich außerdem \lstinline|str()|.

\begin{lstlisting}
l <- list(a = 1:3, b = NULL, c = c("x", "y"))
length(l)       # 3     ; Länge der Liste
lengths(l)      # 3 0 2 ; Länge ihrer Elemente
str(l)          # List of 3
                #  $ a: int [1:3] 1 2 3
                #  $ b: NULL
                #  $ c: chr [1:2] "x" "y"
\end{lstlisting}


\subsubsection{Verändern von Listen}

R verwendet für Listen wie für andere Vektoren das Prinzip
\emph{Copy-on-modify}. Das bedeutet, dass Objekte erst dann kopiert werden,
wenn sie verändert werden. Dabei wird nicht zwangsläufig die gesamte Liste
kopiert, sondern nur die tatsächlich veränderten Teile.

\begin{lstlisting}
l1 <- list(1:3, 4:6)
l2 <- l1                               # Kein Kopieren
tracemem(l1) == tracemem(l2)           # TRUE
l2[[1]][1] <- 0
tracemem(l1) == tracemem(l2)           # FALSE
tracemem(l1[[1]]) == tracemem(l2[[1]]) # FALSE
tracemem(l1[[2]]) == tracemem(l2[[2]]) # TRUE
\end{lstlisting}

Obwohl \lstinline|l1| und \lstinline|l2| zunächst dieselben Referenzen teilen, wird beim Modifizieren von \lstinline|l2[[1]]| dieses Element sowie die Zeiger der Liste kopiert. Das zweite Listenelement bleibt unverändert geteilt.

Neue Elemente können durch Zuweisung erzeugt werden:

\begin{lstlisting}
l <- list(a = 1:3, b = c("x", "y"), c = TRUE)
l$d <- 99       # Neues Element
\end{lstlisting}

Bestehende Elemente können ersetzt oder entfernt werden. Eine Besonderheit ergibt sich jedoch beim Umgang mit dem Wert \lstinline|NULL|. Sowohl die Zuweisung \lstinline|l[1] <- NULL| als auch \lstinline|l[[1]] <- NULL| entfernen das Element vollständig. Um einem Element stattdessen den Wert \lstinline|NULL| zuzuweisen, muss die Syntax \lstinline|l[1] <- list(NULL)| verwendet werden.

\begin{lstlisting}
l <- list(a = 1:3, b = c("x", "y"), c = NULL)
l$a <- c(10, 20)     # Element ersetzen
l$c <- NULL          # Element entfernen
l["c"] <- list(NULL) # NULL als Element einfügen

l <- as.list(1:6)
l[1] <- NULL         # Entfernt Element
l[[1]] <- NULL       # Entfernt ebenfalls Element
l[1:2] <- NULL       # Entfernt zwei Element

l[1] <- list(NULL)   # Fügt Null als Element ein
l[[2]] <- list(NULL) # Fügt Liste mit Null ein!

l[1] <- list(NULL, 1)# Warnung Länge passt nicht zum Ziel
l[[1]] <- list(NULL, 1) # Fügt Liste an Position 1 ein
l[1:2] <- list(1, 2) # Längen passen zusammen
l[1:2] <- list(NULL) # 1 und 2 werden NULL
\end{lstlisting}


\subsubsection{Umwandlung zwischen Liste und Vektor}

Mit \lstinline|unlist()| kann eine Liste in einen atomaren Vektor umgewandelt werden, wobei bei heterogenen Inhalten eine Typkonvertierung erfolgt. Dabei werden rekursiv alle Elemente vereinfacht und \lstinline|NULL| entfernt.

\begin{lstlisting}
l <- list(a = list(1:2), b = NULL, c = c("x", "y"))
unlist(l)        # "1" "2" "x" "y"; kein NULL, alles Char
unlist(l, FALSE) # [1 2], x, y; Nicht rekursiv
\end{lstlisting}

Unterschied zwischen \lstinline|list()| und \lstinline|as.list()|:

\begin{lstlisting}
list(1:3)        # [[1]] 1 2 3; ein Element
as.list(1:3)     # [[1]] 1    ; drei Elemente
                 # [[2]] 2
                 # [[3]] 3
as.list(iris)    # data.frame -> Liste (eine Spalte pro Element)
\end{lstlisting}


\subsubsection{Umwandlung zwischen Liste und Environment}

Listen mit benannten Elementen können in Environments und Environments wieder in Listen umgewandelt werden. Dabei geht die ursprüngliche Reihenfolge der Elemente verloren, da Environments keine Ordnung besitzen.

\begin{lstlisting}
x <- list(1, 2)
#list2env(x)            # Error, keine Namen
x <- list(a=1, b=2)
y <- as.environment(x)  # Wandelt Liste in Environment
y <- list2env(x)        # hat mehr Optionen
z <- as.list(y)         # Wandelt Environment in Liste
\end{lstlisting}


%\subsection{Klassen, die auf atomaren Typen aufbauen}

\subsection{factor -- Kategorische Daten}

Ein \lstinline|factor| ist ein Datentyp zur Darstellung kategorialer (qualitativer) Daten. Er wird verwendet, um nominale (ungeordnete, z.\.B.\ ja, nein) oder ordinale (geordnete, z.\.B.\ wenig, viel) Kategorien zu erfassen. Intern speichert R Faktoren als Ganzzahlen (Integer), denen ein Label (\emph{level}) zugewiesen ist.

Im Gegensatz zu \lstinline|character| besitzt ein \lstinline|factor| eine feste Menge vordefinierter Ausprägungen (Levels), die durch ihre interne Kodierung als Ganzzahl eine fixe Reihenfolge haben. Dadurch können Ausprägungen existieren, die in den Daten selbst nicht vorkommen (z.\,B.\ bei einer Ja-/Nein-Frage, haben alle mit nein geantwortet).

Im Gegensatz zu \lstinline|character|-Vektoren erzeugen Faktoren in Grafiken und Tabellen keine alphabetische Sortierung, sondern gehen nach der Reihung ihrer Levels vor. Tippfehler werden sichtbar, weil nicht vorhandene Faktoren \lstinline|NA| erzeugen, und lineare Modelle erhalten eine sinnvolle Referenzkategorie.


\subsubsection{Erzeugung und interne Struktur}

Faktoren werden meist mit der Funktion \lstinline|factor()| erzeugt. Die Reihenfolge der Levels wird standardmäßig alphabetisch festgelegt, kann aber explizit angegeben werden.

\begin{lstlisting}
f <- factor(c("rot", "blau", "rot")) 
levels(f)        # "blau" "rot"
nlevels(f)       # 2
unclass(f)       # 2 1 2; interne Ganzzahl-Repräsentation

# Explizite Festlegung der Levels
f <- factor(c("rot", "blau", "rot"), levels = c("rot", "blau"))
levels(f)        # "rot" "blau"
\end{lstlisting}

Mit \lstinline|gl()| (generate levels) lassen sich balancierte Faktoren für Versuchsdesigns erzeugen, z.\,B.\ \lstinline|gl(n=3, k=2)| für drei Gruppen mit jeweils zwei Beobachtungen.

\begin{lstlisting}
gl(3, 2)  # 1 1 2 2 3 3; 3 Levels, je 2 Wiederholungen
gl(3, 2, labels=c("A", "B", "C")) # A A B B C C
\end{lstlisting}


\subsubsection{Manipulation von Levels}

Rohdaten enthalten oft nicht die volle Information. Leere Kategorien müssen ergänzt, Synonymen zusammengefasst oder eine Reihenfolge bzw.\  Referenzkategorie festgelegt werden.

\paragraph{Levels umordnen}

Die Reihenfolge der Levels bestimmt deren Anordnung in Abbildungen sowie welche Kategorie in Regressionsmodellen als Basis dient. In linearen Modellen wird der erste Level automatisch als Referenzkategorie für Dummy-Variablen genutzt.

Mit \lstinline|relevel()| kann man die Referenzkategorie setzen, welche dann an erste Position steht. \lstinline|reorder()| kann z.\,B.\ verwendet werden, um Kategorien anhand einer numerischen Zielgröße (etwa Mittelwerten) neu anzuordnen.

\begin{lstlisting}
f <- factor(c("rot", "blau"))
levels(f)               # "blau" "rot"
f <- relevel(f, "rot")  # "rot" wird erster Level
levels(f)               # "rot" "blau"

f <- factor(c("A", "B", "C"))
levels(f)               # "A" "B" "C"
n <- c(3, 2, 2)
f <- reorder(f, n)      # sortiert Levels basierend auf Vektor n
levels(f)               # "B" "C" "A"
\end{lstlisting}


\paragraph{Levels umbenennen oder zusammenfassen}

Levels eines Factors lassen sich nachträglich umbenennen oder zu gemeinsamen Kategorien zusammenfassen. Dies ist insbesondere bei uneinheitlichen Eingaben oder mehreren Schreibweisen derselben Kategorie nützlich. Dies kann manuell, über Indizes oder via Listen-Zuweisung geschehen.

\begin{lstlisting}
f <- factor(c("rot", "blau", "rot"))
levels(f)                 # "blau" "rot"
levels(f)[levels(f) == "rot"] <- "grün" # rot wird zu grün
levels(f)                 # "blau" "grün"

# Zusammenfassen mehrerer Schreibweisen
f0 <- factor(c("j","n","ja","X","ja","nein","X"))
levels(f0)                # "j" "ja" "n" "nein" "X"

## Listen-Zuordnung
f <- f0
levels(f) <- list(ja=c("ja","j"), nein=c("nein","n"), X="X")
levels(f)                # "ja" "nein" "X"

## Match
f <- f0
levels(f)[match(c("j","n"), levels(f))] <- c("ja","nein")
levels(f)                # "ja" "nein" "X"

## Programmatische Variante
f <- f0
local({
  s <- c(ja="j", nein="n", m="u")
  i <- match(levels(f), s, 0)
  levels(f)[i != 0] <<- names(s)[i]
})
levels(f)                # "ja" "nein" "X"
\end{lstlisting}


\paragraph{Ungenutzte Levels}

Nach der Auswahl von Teilmengen bleiben alle Levels im Objekt erhalten. Dies führt in Tabellen oder Legenden zu leeren Kategorien.

\begin{lstlisting}
f <- factor(c("A","B","C"))
levels(f)                 # "A" "B" "C"
levels(f[1:2])            # "A" "B" "C"; Behält alle Levels
levels(f[2:1, drop=TRUE]) # "A" "B"; Nur die vorhandenen Levels
levels(droplevels(f[1:2]))# "A" "B"

f <- factor(c("A","B"), c("A","B","C"))
levels(f)                 # "A" "B" "C"
f <- droplevels(f)        # Entfernt unbenutzte Levels
levels(f)                 # "A" "B"
f[3] <- "C"               # Warning => NA
levels(f) <- c(levels(f), "C") # Neuer Level
f[4] <- "C"
f                         # A B <NA> C
levels(f) <- c(levels(f), "A") # Levels sind unique
levels(f)                 # "A" "B" "C''
\end{lstlisting}


\paragraph{Faktoren kombinieren}
Beim Zusammenhängen mehrerer Faktoren mit \lstinline|c()| werden die Levels vereinigt:

\begin{lstlisting}
f1 <- factor(c("A","B"))
f2 <- factor(c("B","C"))
c(f1, f2)  # A B B C; Levels: A B C
\end{lstlisting}


\subsubsection{Geordnete Faktoren (ordinal)}

Bei ordinalen Daten gibt es eine natürliche Reihenfolge (z.\,B.\ „niedrig < mittel < hoch“), aber die Abstände sind unbekannt. Dafür gibt es die Klasse \lstinline|ordered|.

Faktoren kann man auf Gleichheit prüfen, \lstinline|ordered|-Faktoren zusätzlich ob sie größer oder kleiner sind. Die Angabe der Reihung erfolgt über \lstinline|levels| von klein nach groß.

\begin{lstlisting}
f1 <- factor(c("wenig", "mittel", "viel"))
f1 == "mittel"  # FALSE TRUE FALSE
f1 < "mittel"   # NA NA NA
f2 <- factor(c("mittel", "nichts"))
f2 %in% f1      # TRUE FALSE

o <- ordered(c("wenig", "mittel", "viel"),
             levels = c("wenig", "mittel", "viel"))
o < "mittel"  # TRUE TRUE FALSE
\end{lstlisting}


\subsubsection{Fehlende Werte (NA)}

\lstinline|NA| ist standardmäßig kein Level, sondern ein fehlender Wert. Soll es als eigene Kategorie modelliert werden, muss dies explizit angegeben werden. In Modellen werden fehlende Werte standardmäßig ausgeschlossen, während ein explizites NA-Level als eigene Kategorie behandelt wird.

\begin{lstlisting}
f <- factor(c("ja", "nein", NA))
f                    # ja nein <NA>
levels(f)            # "ja" "nein"
table(f)             # ja:1 nein:1
f <- addNA(f)        # fügt Level <NA> hinzu
levels(f)            # "ja" "nein" NA
table(f)             # ja:1 nein:1 <NA>:1
levels(f)[is.na(levels(f))] <- "unbekannt" # Umbenennen
levels(f)            # "ja" "nein" "unbekannt"
\end{lstlisting}


\subsubsection{Typumwandlungen}

Faktoren sind intern Ganzzahlen die mit Character verknüpft sind. \lstinline|as.numeric()| liefert die internen Codes (1, 2, 3...), nicht die dargestellten Levelwerte. Eine numerische Umwandlung von Faktoren macht nur Sinn, wenn die Levels tatsächlich numerische Bedeutung haben.

\begin{lstlisting}
f <- factor(c("10", "30", "20"))
as.integer(f)               # 1 3 2
as.numeric(f)               # 1 3 2
unclass(f)                  # 1 3 2
as.character(f)             # "10" "30" "20"
as.numeric(as.character(f)) # 10 30 20
as.numeric(levels(f))[f]    # 10 30 20; empfohlen
\end{lstlisting}


\subsection{Datum und Zeit}

In R gibt es verschiedene Klassen für Datum und Zeit. Welche man verwendet, hängt davon ab, ob man nur das Datum, die genaue Uhrzeit oder Zeitdifferenzen benötigt.

\begin{description}
\item[Kalenderdaten:] (\lstinline|Date|): Wenn nur der Tag relevant ist.
\item[Zeitpunkte:] (\lstinline|POSIXct/lt|): Wenn Tag und Uhrzeit (Stunden/Minuten/Sekunden) eine Rolle spielt.
\item[Zeitspannen:] (\lstinline|difftime|): Zur Erfassung von Zeitdifferenzen.
\end{description}

\subsubsection{Formatierungscodes}

Um Zeichenketten (Strings) in Zeitobjekte umzuwandeln, nutzt R die \lstinline|strptime|-Syntax. Die wichtigsten Platzhalter sind:

\begin{itemize}
  \item \lstinline|%Y| / \lstinline|%y|: Jahr 4-stellig (2025) / 2-stellig (25).
  \item \lstinline|%m| / \lstinline|%b| / \lstinline|%B|: Monat als Zahl / Kürzel / Name (Abhängig von Ländereinstellung).
  \item \lstinline|%d|: Tag des Monats (01--31).
  \item \lstinline|%j|: Tag des Jahres (001--366).
  \item \lstinline|%H| / \lstinline|%M| / \lstinline|%S|: Stunde / Minute / Sekunde.
\end{itemize}


\subsubsection{Reine Datumsangaben: Date}

Die Klasse \lstinline|Date| speichert intern die Anzahl der Tage seit dem 01.01.1970 als \lstinline|double|. Tage können mit \lstinline|+| oder \lstinline|-| einfach addiert oder subtrahiert werden. Für Zeitabschnitte mit unterschiedlich vielen Tagen (z.\,B.\ Monat) kann \lstinline|seq| verwendet werden.

\begin{lstlisting}
Sys.Date()                # "2025-10-24"; aktuelles Datum

as.Date("2025-10-24")     # Standardformat: "%Y-%m-%d"
#as.Date("2025-02-29")    ## Error: "invalid date"
as.Date("24.10.2025", format = "%d.%m.%Y")
d <- as.Date("2025-10-24")
unclass(d)                # 20385; Tage seit 01.01.1970
d + 7                     # "2025-10-31; + 7 Tage
seq(d, by = "month", length.out = 2)[2]   # "2025-11-24"
seq(d, by = "3 month", length.out = 2)[2] # "2026-01-24"
\end{lstlisting}


\subsubsection{Datum und Uhrzeit: POSIXct und POSIXlt}

Für einen Timestamp (Datum und Uhrzeit) gibt es zwei Repräsentationen unter der gemeinsamen Oberklasse \lstinline|POSIXt|:

\begin{enumerate}
  \item \textbf{\lstinline|POSIXct|} (\emph{continuous time}): Speichert Sekunden seit 1970 als double. (\emph{empfohlen})
  \item \textbf{\lstinline|POSIXlt|} (\emph{list time}): Speichert eine Liste (Jahr, Monat, etc.). Nützlich, um direkt auf Komponenten wie \lstinline|$hour| zuzugreifen.
\end{enumerate}

Alternativ zu \lstinline|as.POSIXlt()| kann \lstinline|strptime()| verwendet werden.

Viele Funktionen in R sind so implementiert, dass sie für alle Objekte der Klasse \lstinline|POSIXt| gelten, unabhängig davon, ob die konkrete Repräsentation \lstinline|POSIXct| oder \lstinline|POSIXlt| ist.

Standardmäßig nutzt R die lokale Zeitzone (\lstinline|Sys.timezone()|). Beim Einlesen kann diese mit \lstinline|tz = "UTC"| explizit gesetzt werden. Die Anzeige eines Zeitobjekts hängt von der Zeitzone ab, der gespeicherte Zeitpunkt bleibt jedoch eindeutig.

\begin{lstlisting}
Sys.time()                # "2025-10-24 08:16:44 CEST"
Sys.timezone()            # "Europe/Vienna"; Lokale Zeitzone
ct <- as.POSIXct("2025-10-24 08:16:44")
       # "2025-10-24 08:16:44 CEST"
ct + 2 # "2025-10-24 08:16:46 CEST"; + 2 Sekunden
format(ct, tz = "UTC")    # "2025-10-24 06:16:44"
u <- as.POSIXct(format(ct, tz="UTC"), "UTC") # Umwandeln auf UTC
  # "2025-10-24 06:16:44 UTC"
ct == u                   # TRUE
as.POSIXct("2025-10-24 08:16:44", "UTC")
 # "2025-10-24 08:16:44 UTC"
ISOdatetime(2025, 10, 24, 8, 16, 44)
 # "2025-10-24 08:16:44 CEST"
ISOdate(2025, 10, 24)       # mittags in UTC/GMT
 # "2025-10-24 12:00:00 GMT"
format(ct, "%d.%m.%Y %H:%M")
 # "24.10.2025 08:16"
format(ct, "%H")          # 8; Nur die Stunde
format(ct, "%m")          # 10; Monat
unclass(ct)               # 1761286604; Sekunden seit 1970-01-01
lt <- as.POSIXlt("2025-10-24 08:16:44") #Liste mit Jahr, Monat..
lt$hour                   # 8
lt$mon                    # 9; Monat (0 = Januar, 11 = Dezember)
lt$year                   # 125; Jahr - 1900
strptime("2025-10-24 08:16:44","%Y-%m-%d %H:%M:%OS") == lt #TRUE
\end{lstlisting}


\subsubsection{Zeitdifferenzen}

Differenzen zwischen Datums- oder Zeitobjekten werden als \lstinline|difftime|
interpretiert und können in verschiedenen Einheiten ausgegeben werden.

Mit \lstinline|as.difftime()| können Zeitdifferenzen von \lstinline|secs|, \lstinline|mins|, \lstinline|hours|, \lstinline|days| oder \lstinline|weeks| angegeben werden.

Monate und Jahre können nicht direkt als \lstinline|difftime| angegeben werden, da ihre Länge variiert. Um Differenzen in Monaten oder Jahren zu berechnen, sollte man stattdessen konkrete Datumsangaben verwenden, z.\,B.\ mit \lstinline|seq()| oder durch Addition von Monaten über \lstinline|seq()|.

\begin{lstlisting}
as.Date("2024-3-1") - as.Date("2024-2-1") # 29 days
a <- ISOdate(2025, 10, 1, 8, 0, 0)
e <- ISOdate(2025, 10, 1, 9, 10, 30)
e - a                                     # 1.175 hours
difftime(e, a, units = "mins")            # 70.5 mins
as.numeric(difftime(e, a, units = "mins"))# 70.5

as.difftime(2, units="weeks")  # 2 Wochen
\end{lstlisting}


\subsubsection{Sequenzen von Datums- und Zeitwerten}

Mit \lstinline|seq()| lassen sich regelmäßig verteilte Datums- oder Zeitpunkte erzeugen. Mögliche Schritte sind: \lstinline|sec|, \lstinline|min|, \lstinline|hour|, \lstinline|day|, \lstinline|DSTday| (Daylight Saving Time), \lstinline|week|, \lstinline|month|, \lstinline|quarter| und \lstinline|year|.

Bei \lstinline|day| werden exakt 24~Stunden addiert, daher kann die Uhrzeit bei einer Sommerzeit/Winterzeit-Umstellung um eine Stunde verschoben sein. Bei Monats- oder Jahresfolgen passt \lstinline|seq()| automatisch Schaltjahre oder unterschiedliche Monatslängen an.

\begin{lstlisting}[language=R]
seq(as.Date("2025-01-01"), as.Date("2025-04-01"), "1 month")
 # "2025-01-01" "2025-02-01" "2025-03-01" "2025-04-01"
seq(as.Date("2024-02-29"), by = "2 years", length.out = 4)
 # "2024-02-29" "2026-03-01" "2028-02-29" "2030-03-01"

a <- as.POSIXct("2025-03-29 12:00:00", tz="CET")
seq(a, by="DSTday", length.out=2)
 # "2025-03-29 12:00:00 CET"  "2025-03-30 12:00:00 CEST"
seq(a, by="day", length.out=2)
 # "2025-03-29 12:00:00 CET"  "2025-03-30 13:00:00 CEST"
\end{lstlisting}


\subsubsection{Kalenderreformen}

R wendet den \emph{proleptischen Gregorianischen Kalender} an. Das bedeutet, dass die Gregorianische Kalenderreform von 1582, bei der mehrere Kalendertage übersprungen wurden (in vielen Ländern folgte auf den 4.~Oktober direkt der 15.~Oktober), \emph{nicht} berücksichtigt wird. Die Datumsfunktionen in R behandeln die Tage vor 1582 so, als wären sie kontinuierlich nach dem Gregorianischen Schema gezählt worden. Dies erleichtert Berechnungen und Differenzen zwischen historischen Daten, ist aber aus historischer Sicht nicht exakt.

\begin{lstlisting}
seq(as.Date("1582-10-4"), as.Date("1582-10-15"), "1 day") # !
 # "1582-10-04" "1582-10-05", ..., "1582-10-14" "1582-10-15"
\end{lstlisting}


\subsubsection{Schaltsekunden}

Schaltsekunden sind zusätzliche Sekunden, die unregelmäßig eingefügt werden, um die Differenz zwischen der koordinierten Weltzeit (UTC) und der Erdrotation auszugleichen.
Bei der Berechnung von Zeitunterschieden werden in R Schaltsekunden \emph{nicht} berücksichtigt. Alle Minuten haben immer exakt 60~Sekunden.
\lstinline|POSIXlt| erlaubt lediglich für beliebige Zeitpunkte eine Darstellung von \lstinline|sec = 60|, was jedoch immer als \lstinline|sec = 00| der nächsten Minute betrachtet wird.
Bei Berechnungen mit \lstinline|difftime| oder Sequenzen über Schaltsekunden wird die zusätzliche Sekunde nicht berücksichtigt.

\begin{lstlisting}
.leap.seconds  # Zeigt Schaltsekunden
seq(ISOdate(2016,12,31,23,59,59), by="1 sec", length.out = 3)
 # "2016-12-31 23:59:59 GMT" "2017-01-01 00:00:00 GMT"
 # "2017-01-01 00:00:01 GMT"
ISOdate(2016, 12, 31, 23, 59, 60)   #  "2017-01-01 GMT"
x <- as.POSIXlt("2016-12-31 23:59:60", tz = "UTC")
 # "2016-12-31 23:59:60 UTC"
as.POSIXlt("2017-01-01 00:00:00", tz = "UTC") - x # 0 sec
as.POSIXlt("2020-02-15 07:01:60", tz = "UTC")
 # "2020-02-15 07:01:60 UTC"
\end{lstlisting}


\subsection{Matrizen und Arrays}

\emph{Matrizen} und \emph{Arrays} dienen genauso wie \emph{Vektoren} der Speicherung von Elementen des \emph{gleichen (atomaren) Typs}. Ein \emph{Array} ist ein Vektor, bei dem zusätzlich Angaben über seine Ausdehnungen (Dimension) vorhanden sind. Dadurch lassen sich ein- oder mehrdimensionale Datenstrukturen darstellen. Eine \emph{Matrix} ist ein spezieller Fall eines Arrays mit zwei Dimensionen.

In R werden Matrizen und mehrdimensionale Arrays spaltenweise (column-major order), also entlang der ersten Dimension, im Speicher abgelegt. Operationen, die dieser spaltenweisen Anordnung folgen, sind meist schneller als z.\,B.\ zeilenorientierte Zugriffe.


\subsubsection{Erzeugung}

Matrizen und Arrays werden in R mit den Funktionen \lstinline|matrix()| bzw. \lstinline|array()| erzeugt. Dabei gibt man einen Datenvektor sowie die gewünschten Dimensionen an. Standardmäßig füllt R die Daten \emph{spaltenweise} (column-major order). Mit dem Argument \lstinline|byrow=TRUE| kann man zeilenweises Füllen erzwingen. 

Wichtige Funktionen zur Untersuchung der Struktur sind \lstinline|dim()| (Dimensionen), \lstinline|nrow()|, \lstinline|ncol()| und \lstinline|length()| (Gesamtzahl der Elemente) sowie \lstinline|is.matrix()| und \lstinline|is.array()|.

Für sehr große Matrizen mit vielen Nullen lohnt sich die Verwendung von \emph{Sparse-Matrizen} aus dem Paket \lstinline|Matrix|. Sparse-Matrizen speichern nur von Null verschiedene Einträge und sind daher speichereffizient für große, dünn besetzte Matrizen.

\begin{lstlisting}
array(1:6)                       # 1x6 Array
array(1:6, dim=6)                # mit dim Angabe
array(1:6, c(6,1))               # 6x1 Array

x <- array(1:6, c(2, 3))         # 2x3 Array bzw. Matrix
structure(1:6, dim = c(2L,3L))   # Das gleiche
matrix(1:6, nrow=2, ncol=3)      # Das gleiche
matrix(1:6, 2, 3)                # Das gleiche
matrix(1:6, 2)                   # Das gleiche; 3 col = 6/2
matrix(1:6, 2, 3, byrow=TRUE)    # Füllt zeilenweise
a <- array(1:8, c(2,2,2))        # 2x2x2 Array

length(x)                        # 6 (Gesamtzahl Elemente)
nrow(x)                          # 2
ncol(x)                          # 3
dim(x)                           # 2 3
length(a)                        # 8
nrow(a)                          # 2; erste Dimension
ncol(a)                          # 2; zweite Dimension
dim(a)                           # 2 2 2
is.vector(x)                     # FALSE; Hat dim
is.matrix(a)                     # FALSE (da 3D)
is.array(a)                      # TRUE

# Sparse Matrix
x <- Matrix::sparseMatrix(c(1,100), c(1,100), x=c(2,3),
                          dims=c(100,100))
x[1,1]            # 2
x[5,5]            # 0
x[100,100]        # 3
\end{lstlisting}


\subsubsection{Dimensionsnamen}

Dimensions- bzw.\ Achsennamen können bereits bei der Erzeugung eines Objekts vergeben oder später ergänzt und geändert werden. Sie erlauben den Zugriff auf Elemente über Namen und verbessern die Lesbarkeit von Ausgaben.

Mit \lstinline|rownames()|, \lstinline|colnames()| und \lstinline|dimnames()| lassen sich die Dimensionsnamen von Matrizen und Arrays abfragen und verändern.

\begin{lstlisting}
x <- matrix(1:6, 2, dimnames =   # Mit Namen
  list(A=c("i","j"), B=c("x","y","z")))
a <- array(1:8, c(2,2,2),
  list(A=c("i","j"), B=c("k","l"), C=c("x","y")))
  
rownames(x)  # i j; Zeilennamen
colnames(x)  # x y z; Spaltennamen
dimnames(x)  # A: i j, B: x y z; Liste der Dimensionsnamen
rownames(a)  # i j; erste Dimension
colnames(a)  # k l; zweite Dimension
dimnames(a)  # A: i j, B: k l, C: x y
dimnames(a)[[1]] # i j; Nur die erste Achse
names(dimnames(a)) # A B C; Achsennamen

x[c(1,1),c(1,1)]     #   x x; Namen umverändert
                     # i 1 1
                     # i 1 1

rownames(x) <- c("a","b")     # Vergibt neue Namen
colnames(x) <- c("c","d","e")
names(dimnames(x)) <- c("X", "Y") # Neue Achsennamen
dimnames(x) <- list(X=c("a","b"), Y=c("c","d","e"))
dimnames(a)[[1]] <- c("a","b")  # Nur eine Achse
names(dimnames(a))[1] <- "X"    # Nur eine Achse
\end{lstlisting}


\subsubsection{Zugriff auf Elemente (Subsetting)}

Der Zugriff auf Elemente erfolgt über eckige Klammern mit kommagetrennten Indizes für jede Dimension: \lstinline|[Zeile, Spalte, Schicht, ...]|. Zusätzlich kann man auch linear (wie bei Vektoren) indizieren.

Abhängig von der verwendeten Klammerart (\lstinline|[]| vs.\ \lstinline|[[]]|) und den Indizes können einzelne Elemente extrahiert, Teilstrukturen ausgewählt oder Werte ersetzt werden. \lstinline|[[]]| extrahiert genau ein Element ohne Dimensionen oder Namen. Dabei kommen numerische Indizes, Namen oder logische Vektoren zum Einsatz.

Standardmäßig fällt die Dimension weg (\lstinline|drop=TRUE|), wenn nur eine Dimensionsausprägung übrig bleibt. Mit \lstinline|drop=FALSE| behält man die ursprüngliche Struktur in jedem Fall bei.

\begin{lstlisting}[language=R]
m <- matrix(1:6, 2, dimnames=list(c("a","b")))
m[2, 3]         # 6; Zeile 2, Spalte 3
m[[2, 3]]       # 6; Extrahiert Einzelwert ohne Attribute
#m[[c(3, 2)]]   ## Fehler (Indizierung nur mit Einzelwerten)
#m[1, 4]        ## Fehler (außerhalb des Bereichs)
#m[[1, 4]]      ## Fehler, Indizierung außerhalb

m[1, ]          # 1 3 5; Vektor der 1. Zeile
#m[[1, ]]       ## Fehler,  missing subscript
m["a", ]        # 1 3 5; Zugriff ueber Namen
m[1, , drop=FALSE]  # Matrix-Struktur bleibt erhalten (1x3)
m[, 2]          # 3 4; Ganze Spalte 2
m[-1, -3]       # Ohne Zeile 1 und Spalte 3
m[2, 2:3]       # Zeile 2, Spalten 2-3
m[4]            # 4; Lineare Indizierung (wie Vektor)
m[[4]]          # 4
m[3:4]          # 3 4
#m[[3:4]]       # Error, mehr als ein Element
m[7]            # NA (Out of bounds fuer Vektor-Index)
m[m>3]          # 4 5 6; Filterung
m["a", m["a",] > 3] # Zeile "a", nur Spalten mit Werten > 3
m[m>3] <- 3     # Setzt alle > 3 auf 3
m[] <- 4        # Setzt alle auf 4, Matrix bleibt erhalten

a <- array(1:24, dim=c(2,3,4))
a[ , , 1]       # Erste Schicht des 3D-Arrays
b <- a[1,,,drop=FALSE]
drop(b)         # Entfernt 1-Element-Dimensionen

i <- which(a > 20)          # Liefert lineare Vektor-Indizes
which(a > 20, arr.ind=TRUE) # Liefert Matrix-Indizes
arrayInd(i, dim(a))         # lineare Indizes in Koordinaten
\end{lstlisting}


\subsubsection{Arithmetik}

R unterstützt sowohl elementweise Arithmetik auf Vektoren, Matrizen und Arrays als auch klassische Matrixoperationen aus der linearen Algebra. Welche Art von Operation durchgeführt wird, hängt vom verwendeten Operator und den Dimensionen der Operanden ab.

\paragraph{Elementweise}

Elementweise Operationen wie \lstinline|+|, \lstinline|*|, \lstinline|-| oder \lstinline|/| werden unabhängig von der dimensionalen Struktur der Operanden durchgeführt. Stimmen die Längen nicht überein, greift das \emph{Recycling}-Prinzip. Kürzere Objekte werden wiederholt, bis die Länge der längeren Operanden erreicht ist.

\begin{lstlisting}
m <- matrix(1:4, 2)  # 1 3
                     # 2 4
m + 1                # 2 4; Addiert 1 zu jedem Element
                       3 5
m + m                # 2 6; Elementweise Addition zweier Matrx
                       4 8
\end{lstlisting}


\paragraph{Vektor-Vektor-Operationen}

Mit \lstinline|outer()| lassen sich Funktionen auf \emph{alle Kombinationen} zweier Vektoren anwenden. 
Das Ergebnis ist eine Matrix, in der jede Zeile einem Element des ersten Vektors und jede Spalte einem Element des zweiten Vektors entspricht.

\begin{lstlisting}
x <- 1:2
y <- 1:3
outer(x, y, `+`)         # 2 3 4; alle Summen
                         # 3 4 5
outer(x, y, \(a, b) a+b) # 2 3 4; Eigene Funktion
                         # 3 4 5
\end{lstlisting}


\paragraph{Vektor-Matrix-Operationen}

Mit \lstinline|sweep()| lassen sich Vektoren gezielt entlang einer Dimension (Margin) auf Matrizen oder Arrays anwenden.

Funktionen wie \lstinline|row()|, \lstinline|col()| und \lstinline|slice.index()| erzeugen Indexmatrizen, die z.\,B.\ für komplexe Operationen oder bedingte Berechnungen nützlich sind.

Das Matrix-Vektor-Produkt wird mit \lstinline|%*%| durchgeführt. Alternativen für spezielle Produkte sind \lstinline|crossprod()| und \lstinline|tcrossprod()|. Eine Matix kann man mit \lstinline|t()| transponieren. Mit \lstinline|%x%| erhält man das Kronecker-Produkt.

\begin{lstlisting}
m <- matrix(1:4, 2)  # 1 3
                     # 2 4
v <- 1:2             # 1 2

t(m)                 # 1 2
                     # 3 4

m + v                # 2 4; Spaltenweises Recycling von v
                     # 4 6
sweep(m, 1, v, `+`)  # 2 4; Addiert v entlang Margin 1
                     # 4 6

m + v[col(m)]        # 2 5; Zeilenweise Addition von v
                     # 3 6
sweep(m, 2, v, `+`)  # 2 5; Addiert v entlang Margin 2
                     # 3 6

row(m)               # 1 1; Matrix der Zeilenindizes
                     # 2 2
col(m)               # 1 2; Matrix der Spaltenindizes
                     # 1 2
slice.index(m, 1)    # 1 1; Index für Dimension 1
slice.index(m, 1:2)  # 1 3; Index über Dimension 1 und 2
                     # 2 4

v %*% m              # 5 11; Vektor-Matrix-Produkt
c(sum(m[,1] * v), sum(m[,2] * v)) # 5 11

m %*% v              # 7   ; Matrix-Vektor-Produkt
                     # 10
c(sum(m[1,] * v), sum(m[2,] * v)) # 7 10

crossprod(m, v)      # t(m) %*% v
tcrossprod(v, m)     # v %*% t(m)

kronecker(v, m) # Kronecker-Produkt
v %x% m         # Kronecker-Produkt
\end{lstlisting}

\paragraph{Matrix-Matrix-Operationen}

Für Matrix-Matrix Produkte werden die gleichen Operatoren wie für Vektor-Matrix Produkte verwendet (\lstinline|%*%|, \lstinline|crossprod()|, \lstinline|tcrossprod()|).
\begin{lstlisting}
m <- matrix(1:4, 2)  # 1 3
                     # 2 4

m %*% m              #  7 15; Matrixprodukt
                     # 10 22
c(sum(m[1,] * m[,1]), sum(m[1,] * m[,2])) #  7 15
c(sum(m[2,] * m[,1]), sum(m[2,] * m[,2])) # 10 22
\end{lstlisting}


\paragraph{Lineare Algebra und Spezialfunktionen}

R bietet umfangreiche Funktionen für lineare Algebra, die insbesondere für Matrizen und Vektoren nützlich sind. Diese Funktionen erleichtern das Lösen linearer Gleichungssysteme, die Analyse von Matrizen sowie die Berechnung spezieller Eigenschaften wie Determinanten, Eigenwerte oder Zerlegungen.  

\begin{lstlisting}
A <- matrix(c(2,1,1,3), 2)
b <- c(1,4)

solve(A, b)     # Löst A x = b
solve(A)        # Berechnet Inverse von A
det(A)          # Determinante
eigen(A)        # Eigenwerte und Eigenvektoren
svd(A)          # Singularwertzerlegung
qr(A)           # QR-Zerlegung
chol(A)         # Cholesky-Zerlegung
\end{lstlisting}

\paragraph{Diagonalen und Einheitsmatrizen}

\lstinline|diag()| kann eine Einheitsmatrize erzeugen und Diagonalelemente extrahieren.

\begin{lstlisting}
m <- matrix(1:4, 2)
diag(2)              # 2x2 Einheitsmatrix
diag(m)              # Extrahiert Diagonalelemente von m
diag(m) <- 0         # Setzt Diagonalelemente von m auf 0
\end{lstlisting}


\subsubsection{Strukturänderung und Kombination}

Arrays werden umgeformt oder zusammengefügt, ohne ihre Werte zu ändern.

Typumwandlungen erfolgen z.\,B.\ mit \lstinline|as.vector()|, \lstinline|as.matrix()| oder \lstinline|as.data.frame()|.

Dimensionen lassen sich direkt über \lstinline|dim()| ändern.

\lstinline|t()| transponiert Matrizen.

\lstinline|aperm()| erlaubt die Neuordnung von Achsen bei Arrays. 

\begin{lstlisting}
m <- matrix(1:6, 2)  # 1 3 5
                     # 2 4 6
as.vector(m)         # 1 2 3 4 5 6; Matrix wird Vektor
as.data.frame(m)     #   V1 V2 V3; Matrix in Data Frame
                     # 1  1  3  5
                     # 2  2  4  6
as.matrix(1:4)       # Vektor in 4x1 Matrix (Spaltenvektor)

t(m)                 # 1 2; Transponieren
                     # 3 4
                     # 5 6
dim(m) <- c(3,2)     # Dimensionen ändern
m                    # 1 4
                     # 2 5
                     # 3 6
aperm(m, c(2,1))     # 1 2 3; Neue Dim Reihenfolge
                     # 4 5 6
\end{lstlisting}

Matrizen können entlang ihrer Dimensionen kombiniert oder aufgeteilt werden:
\begin{itemize}
\item \lstinline|rbind()| / \lstinline|cbind()| / \lstinline|abind::abind()|: fügt Matrizen untereinander / nebeneinander oder beliebig zusammen
\item \lstinline|split()|, \lstinline|asplit()|: zerlegt eine Matrix in eine Liste von Vektoren
\item \lstinline|simplify2array()| / \lstinline|replicate()|: erzeugt höherdimensionale Arrays aus Listen oder wiederholten Berechnungen
\end{itemize}

\begin{lstlisting}
m <- matrix(1:12, 4)

rbind(m, m)          # Untereinander hängen
n <- m
colnames(m) <- 1:3
colnames(n) <- 3:1
rbind(m, n)          # Geht nach Position, ignoriert Namen
cbind(m, m)          # Nebeneinander hängen
abind::abind(m, m, along=3) # hintereinander

simplify2array(list(m, m)) # Array aus Matrix-Liste
replicate(2, m)            # Wiederholt Matrix in 3. Dimension

split(m, col(m))     # Spaltenweise Zerlegung in Liste
asplit(m, 2)         # Spaltenweise Zerlegung
split(m, row(m))     # Zeilenweise Zerlegung
asplit(m, 1)         # Zeilenweise Zerlegung
\end{lstlisting}


\subsubsection{Aggregation und Kennwerte}

Aggregationen reduzieren Daten entlang bestimmter Dimensionen zu statistischen Kennwerten. 

Mit \lstinline|apply()| können beliebige Funktionen entlang bestimmter Dimensionen eines Arrays oder einer Matrix angewendet werden. 
Das Argument \lstinline|margin| gibt die Dimension an (1 = Zeilen, 2 = Spalten).

Für Standardaufgaben sind spezialisierte Funktionen wie \lstinline|rowSums()|, \lstinline|colSums()|, \lstinline|rowMeans()| oder \lstinline|colMeans()| meist effizienter. 

Eine Besonderheit ist \lstinline|rowsum()|, das Summen für Gruppen berechnet, die durch einen zusätzlichen Vektor definiert sind. Für höherdimensionale Arrays können Aggregationen über mehrere Achsen mit \lstinline|apply()| erfolgen.

\begin{lstlisting}
m <- matrix(1:6, 2)   # 1 3 5
                      # 2 4 6
rowSums(m)            # 9 12; Summen
colSums(m)            # 3 7 11
apply(m, 2, sum)      # 3 7 11; Margin 2..Spalte
colMeans(m)           # 1.5 3.5 5.5
rowMeans(m)           # 3 4; Mittelwerte
apply(m, 1, mean)     # 3 4; Margin 1..Zeile
apply(m, 1, sd)       # 2 2; Standard Deviation

g <- c("A","B","A","B") # Gruppierte Aggregation
m2 <- matrix(1:12, 4)
rowsum(m2, g)         # A 4 12 20; # Summen für A und B
                      # B 6 14 22

a <- array(1:24, dim=c(2,3,4)) # Höherdimensional
apply(a, 1, sum)      # 144 156; Summe je Zeile
apply(a, 3, sum)      # 21 57 93 129; Summe je Schicht
apply(a, c(1,3), sum) # Summe je Zeile je Schicht
\end{lstlisting}


\subsubsection{Transformation und Hilfsfunktionen}

Die folgenden Funktionen verändern die Werte innerhalb eines Arrays.

\begin{description}
\item[Skalierung] \lstinline|scale()| zentriert und standardisiert Spalten.
\item[Verhältnisse] \lstinline|proportions()| berechnet relative Anteile an der Gesamtsumme oder pro Zeile/Spalte.
\item[Analyse] \lstinline|max.col()| ermittelt die Position des Maximums pro Zeile.
\item[Darstellung] \lstinline|addmargins()| erweitert Matrizen um Summenzeilen/-spalten; \lstinline|ftable()| bereitet höherdimensionale Arrays als flache Tabellen auf.
\end{description}

\begin{lstlisting}
m <- matrix(1:6, 2)  # 1 3 5
                     # 2 4 6

y <- scale(m)        # Spaltenweise mean=0 und sd=1
x <- sweep(m, 2, colMeans(m))  # Manuelle Skalierung
x <- sweep(x, 2, apply(x, 2, sd), `/`)
all(x == y)          # TRUE

proportions(m)       # Anteile an Gesamtsumme
proportions(m, 1)    # Anteile pro Zeile (Zeilensumme = 1)
proportions(m, 2)    # Anteile pro Spalte

max.col(m)            # 3 3; Spalte mit größtem Wert
apply(m, 1, which.max)# 3 3; Spalte mit größtem Wert

addmargins(m)        # Sum; Mit Zeilen- und Spaltensummen
         #      1 3  5   9
         #      2 4  6  12
         #  Sum 3 7 11  21

a <- array(1:8, dim=c(2,2,2), list(A=1:2,B=3:4,C=5:6))
ftable(a)            # Flache Darstellung eines 3D-Arrays
 #     C 5 6
 # A B      
 # 1 3   1 5
 #   4   3 7
 # 2 3   2 6
 #   4   4 8
\end{lstlisting}


%\subsection{Klassen, die auf Listen aufbauen}

\subsection{data.frame}

Ein \lstinline|data.frame| ist eine Datenstruktur zur Speicherung tabellarischer Daten. Es ist als eine \lstinline|list()| gleich langer Spalten organisiert.

Während es visuell einer \lstinline|matrix()| ähnelt, besteht der wesentliche Unterschied darin, dass jede Spalte eines Data Frames einen eigenen Datentyp besitzen kann (z.\,B.\ eine Spalte für Zahlen, eine andere für Text oder logische Werte).

Die Spalten sind in der Regel Vektoren, können aber auch komplexere Objekte (wie Listen oder Matrizen) enthalten, solange alle Spalten exakt die gleiche Länge haben.


\subsubsection{Erzeugung}

Data Frames können nicht nur einfache Vektoren, sondern auch Listen, Matrizen oder andere Data Frames als Spalten enthalten. Beim Erstellen oder Hinzufügen neuer Spalten wird das \emph{Recycling-Prinzip} genutzt. Kürzere Elemente (wie Einzelwerte) werden automatisch auf die erforderliche Länge wiederholt. Recycling funktioniert nur, wenn die Längen kompatibel sind (z.\,B.\ 1 oder ein ganzzahliger Teiler der maximalen Länge).

\begin{lstlisting}
d <- data.frame(a=1:4, b=c("x","y"), c=TRUE)
  # b und c werden automatisch wiederholt
d             #   a b    c
              # 1 1 x TRUE
              # 2 2 y TRUE
              # 3 3 x TRUE
              # 4 4 y TRUE

d = data.frame(Name=c("Anna", "Otto"), Alter=c(33, 44))
d$l = list(3:2, "a")                   # list als Spalte
d$m = matrix(1:6, 2)                   # matrix als Spalte
d$d = data.frame(a=c("c", "d"), b=2:1) # data.frame als Spalte

#data.frame(a=1:3, b=1:2) # Error, unterschiedliche Anzahl
\end{lstlisting}

Doppelte Namen werden automatisch in eindeutige umgewandelt. Beim Subsetting kann das nicht verhindert werden. Beim Erstellen kann dies für die Spaltennamen mit \lstinline|check.names = FALSE| deaktiviert werden. Die Zeilennamen müssen beim Erstellen eindeutig sein. Alternativ kann eine eigene Spalte für die Zeilennamen verwendet werden.

\begin{lstlisting}
data.frame(a=1:2, a=3:4)  #   a a.1
                          # 1 1   3
                          # 2 2   4
data.frame(a=1:2, a=3:4, check.names = FALSE)
                          #   a a
                          # 1 1 3
                          # 2 2 4

#data.frame(a=1:2, row.names = c("b", "b")) ## Error
d <- data.frame(a=1:2)
#rownames(d) <- c("b", "b") ## Error
d <- data.frame(rn = c("B", "B"), a=1:2)
d[c(1,1), c(1,1)]         #     rn rn.1
                          # 1    B    B
                          # 1.1  B    B
i <- c(1,1)
d2 <- d[c(1,1), i]
colnames(d2) <- colnames(d)[i]
d2                        #     rn rn
                          # 1    B  B
                          # 1.1  B  B
\end{lstlisting}

Zeichen können mit \lstinline|stringsAsFactors = TRUE| als \lstinline|faktor| interpretiert werden.

Alle \lstinline|levels| von Faktoren bleiben bei Subabfragen erhalten. Die Funktion \lstinline|droplevels()| entfernt ungenutzten \lstinline|levels| aus allen Faktor-Spalten des Data Frames auf einmal.

\begin{lstlisting}
d <- data.frame(x = c("a","b"))
class(d$x)                # character
d <- data.frame(x = c("a","b"), stringsAsFactors = TRUE)
class(d$x)                # factor

d <- data.frame(x = factor(1:3), y = factor(3:1))
d1 <- d[1,]
levels(d1$x)   #  "1" "2" "3"
levels(d1$y)   #  "1" "2" "3"
d1 <- droplevels(d1)
levels(d1$x)   #  "1"
levels(d1$y)   #  "3"
\end{lstlisting}


\subsubsection{Struktur und Eigenschaften}

In R stehen diverse Funktionen zur Verfügung, um einen schnellen Überblick über die Dimensionen, Inhalte und die interne Struktur eines Data Frames zu erhalten.

\begin{lstlisting}
d <- data.frame(a=1:4, b=c("x","y"), c=TRUE)
names(d)      # "a" "b" "c"; Spaltennamen
row.names(d)  # "1" "2" "3" "4"; Zeilennamen
length(d)     # 3; Anzahl Spalten (Listen-Logik)
ncol(d)       # 3; Anzahl Spalten (Matrix-Logik)
nrow(d)       # 4; Anzahl Zeilen
dim(d)        # 4 3; Zeilen Spalten
head(d)       # Anfang (erste Zeilen)
tail(d)       # Ende (letzte Zeilen)
summary(d)    # Datenüberblick
str(d)        # Daten Struktur
typeof(d)     # "list"
class(d)      # "data.frame"
\end{lstlisting}


\subsubsection{Indizierung und Subsetting}

Der Zugriff auf Data Frames ist sehr flexibel, da sowohl die Listen-Logik als auch die Matrix-Logik unterstützt wird. Der Zugriff erlaubt sowohl die Listen-Syntax (\lstinline|$|, \lstinline|[[]]|) als auch die Matrix-Syntax (\lstinline|[,]|). Die Wahl der Syntax beeinflusst das Rückgabeformat (Vektor vs.\ Data Frame).

\begin{itemize}
\item \lstinline|[| kann mehrere Elemente zurückgeben
\item \lstinline|[[| greift immer auf genau ein Element zu
\item \lstinline|drop = FALSE| verhindert das automatische Vereinfachen
\end{itemize}

\begin{lstlisting}
d <- data.frame(a=c("d","e"), b=2:1)

d[1, ]          # d 2; data.frame, Erste Zeile
d[, 2]          # 2 1; Vektor, Zweite Spalte
d[[2]]          # 2 1; Vektor, Zweite Spalte
d[2]            # 2 1; data.frame, Zweite Spalte
d[, 2, drop=FALSE] # 2 1; data.frame, Zweite Spalte
d[, "b"]        # 2 1; Vektor
d$b             # 2 1; Vektor

d$b[1]          # 2; Erstes Element von Spalte b
d[1, "b"]       # 2; Variante
d[1, 2]         # 2; Variante
d[[2]][1]       # 2; Variante
d[[2]][[1]]     # 2; Variante
d[[1, 2]]       # 2; Variante
d[[c(2, 1)]]    # 2; Variante
d[[1, "b"]]     # 2; Variante

d$b[2:1]        # 1 2; Element 2, 1 von Spalte b
d[2:1, "b"]     # 1 2; Variante
d[2:1, 2]       # 1 2; Variante
d[[2]][2:1]     # 1 2; Variante
#d[[2]][[2:1]]  ## Error; [[ geht nur für ein Element
#d[[2:1, 2]]    ## Error; [[ geht nur für ein Element
d[2:1, 2:1]     # Reihenfolge von Zeilen und Spalten ändern
d[-1, ]         # data.frame ohne erste Zeile
d[, -1]         # Da nur eine Spalte => Vektor
d[, 1:2]        # Spalten 1 bis 2
d[c(TRUE, FALSE),] # Jede zweite Zeile
d[0]            # data.frame mit 0 Spalten
d[0,]           # data.frame mit 0 Zeilen, nur Header

d[d$a == "d", ] # Zeilen, bei denen a == "d"
d[d$b > 1, "a"] # Spalte a, Zeilen mit b > 1
d[d$a == "d" & d$b > 1, ] # d 2; Kombinierter Filter
#d[3]           ## Fehler, nicht definierte Spalte
#d[[3]]         ## Fehler, Indizierung außerhalb
d$b[3]          # NA
\end{lstlisting}

\paragraph{Fehlende Werte (NA)}

Folgende Funktionen können zum identifizieren, auszuschließen oder zu ersetzen von fehlende Werte (\lstinline|NA|) verwendet werden.

\begin{lstlisting}
d <- data.frame(a = c(1, 2, NA), b = c("x", NA, "y"))
is.na(d)          # FALSE FALSE
                  # FALSE  TRUE
                  #  TRUE FALSE
complete.cases(d) # TRUE FALSE FALSE
d[complete.cases(d), ] # 1 x
na.omit(d)             # 1 x
d[is.na(d)] <- 0  # Ersetzt alle NA mit 0
\end{lstlisting}

\subsubsection{Manipulation und Transformation}

Inhalte können direkt oder über komfortable Umgebungs-Funktionen (\lstinline|within|, \lstinline|transform|) geändert werden. Die Verwendung von \lstinline|attach()| wird nicht empfohlen

\begin{lstlisting}
d <- data.frame(a=1:4, b=c("x","y"))
#d$d <- 1:3   ## Error, Länge passt nicht
#d$d <- 1:5   ## Error, Länge passt nicht
d$d <- 1:4    # Neue Spalte
d$e <- 1:2    # Wird zu 1 2 1 2
d$f <- 1      # Wird zu 1 1 1 1
d$a <- 4:1              # Spalte ersetzen
d[2,] <- list(5L, "z")  # Zeile ersetzen
d[2:3,] <- list(7:8, "X") # Mehrere Zeilen ersetzen
d$a <- NULL             # Löscht Spalte a
#d[2,] <- NULL          ## Error
d <- d[-2,,drop=FALSE]  # Löscht Zeile 2

d <- data.frame(a=1:2, b=2:1)
transform(d, a=b, b=a, x=a-b) # a b  x; Zuweisung erst danach
                              # 2 1 -1
                              # 1 2  1
#transform(d, x=a+b, y=x)     ##Error, x nicht gefunden
within(d, {a<-b; b<-a; x<-a-b}) # a b x; Zuordnung sofort
                                # 2 2 0
                                # 1 1 0
within(d, {x<-a+b; y<-x})       # Geht
with(d, a+b)                    # 3 3
attach(d)                       # Zum Suchpfad
a+b                             # 3 3
detach(d)                       # Aus dem Suchpfad
\end{lstlisting}

Das Sortieren eines Data Frames nach dem Wert einer oder mehrerer Spalten kann mit \lstinline|order()| erfolgen, welches die Indizes in der Reihenfolge zurück, in der die Elemente sortiert wären.

\begin{lstlisting}
d <- data.frame(a = c(3, 1, 1), b = c(1, 2, 3))
order(d$a)       # 2 3 1
d[order(d$a),]   #   a b
                 # 2 1 2
                 # 3 1 3
                 # 1 3 1
order(d$a, d$b)  # 2 3 1
order(d$a, -d$b) # 3 2 1
\end{lstlisting}


\subsubsection{Anhängen und Verknüpfen}

Das Zusammenfügen erfolgt über Zeilen (\lstinline|rbind()|), Spalten (\lstinline|cbind()|) oder über Schlüsselvariablen (\lstinline|merge()|).

\begin{lstlisting}
d <- data.frame(a=1:2, b=c("x","y")) #   a b
                                     # 1 1 x
                                     # 2 2 y
d2<- data.frame(b=c("a","b"), a=4:3) #   b a
                                     # 1 a 4
                                     # 2 b 3
d <- rbind(d, d2) # a b; anfügen über Spaltennamen
                # 1 1 x
                # 2 2 y
                # 3 4 a
                # 4 3 b
d3 <- data.frame(d=5:6, e=c("f","g"))
#rbind(d, d3)     ## Error, Namen passen nicht
rbind(d, setNames(d3, names(d))) # Spalten umbenenne

d <- data.frame(a=1:2, b=c("x","y"))
d2<- data.frame(a=2:3, c=c(TRUE, FALSE))
cbind(d, d2)      # Spalten anhängen
merge(d, d2)      # Spalten über gemeinsame Spalte a anhängen
merge(d, d2, all=TRUE)   # Alle Daten erhalten
merge(d, d2, all.x=TRUE) # Alle Daten von d  erhalten
merge(d, d2, all.y=TRUE) # Alle Daten von d2 erhalten

d3<- data.frame(a=1, c=c(TRUE, FALSE))
merge(d, d3)      # Zeile 1 von d wird wiederholt
d4<- data.frame(a=1, b=c("x","y"))
merge(d4, d3)      # Alle Kombinationen werden generiert
\end{lstlisting}


\subsubsection{Aggregation und Reshaping}

Um Daten gesamt oder für Untergruppen zusammenzufassen gibt es verschiedene Aggregationsfunktionen. Diese nutzen häufig die Formel-Syntax (\lstinline|~|, Tilde), wobei die Variable links der Tilde aggregiert und die Variable(n) rechts als Gruppierungsschlüssel verwendet werden. Die Formel \lstinline|y ~ g| bedeutet: Aggregiere die Variable \lstinline|y| getrennt nach den Ausprägungen von \lstinline|g|. Für spezifische Aufgaben wie die reine Summierung sind spezialisierte Funktionen oft performanter.

\begin{lstlisting}
d <- data.frame(a=1:4, b=4:1, g=c("x","y"),h=c("k","k","k","l"))
aggregate(a ~ g, d, mean) # x 2, y 3;Funktion je Gruppe anwenden
aggregate(a ~ g, d, sum)  # x 4, y 6
rowsum(d$a, d$g)          # x 4, y 6; Bei Summierung schneller
tapply(d$a, d$g, sum)     # x 4, y 6; Für einzelne Spalten
xtabs(a ~ g, d)           # x 4, y 6; Alternative
aggregate(a ~ g + h, d, sum) #   g h a; Mehrere Gruppen
                             # 1 x k 4; Als Tabelle
                             # 2 y k 2
                             # 3 y l 4
xtabs(a ~ g + h, d)          #   k l; Mehrere Gruppen
                             # x 4 0; Als Matrix
                             # y 2 4
aggregate(. ~ g, d, sum)  #   g a b; Mehrere Spalten
                          # 1 x 4 6
                          # 2 y 6 4
aggregate(d[1:2], d[3], sum) # Alternativer Aufruf
rowsum(d[1:2], d[,3])     # Schnelle Alternative für Summen
sapply(split(d[1:2], d[3]), colSums) # Alternative
by(d$a, d$g, mean)        # x 2, y 3; Objekt-Liste
as.vector(by(d$a, d$g, mean))     # 2 3
as.data.frame(by(d$a, d$g, mean)) # x 2, y 3
by(d$a, list(d$g, d$h), sum) # mehreren Gruppen
\end{lstlisting}

Umstrukturierung (Reshaping) erlaubt den Wechsel zwischen dem Long-Format (jede Beobachtung eine Zeile) und dem Wide-Format (zusammengefasste Beobachtungen in eigenen Spalten).

\begin{lstlisting}
d <- data.frame(x=1:4, g=c("x","y"), t=c(1,1,2,2))
w <- reshape(d, idvar="g", timevar="t", direction="wide")
# g x.1 x.2;    Breitformat
# x   1   3
# y   2   4
reshape(w, idvar="g", direction="long")
#     g t x.1;  Zurueck zu Langformat
# x.1 x 1   1
# y.1 y 1   2
# x.2 x 2   3
# y.2 y 2   4
\end{lstlisting}


\subsubsection{Konvertierung}

Die Konvertierung zwischen verschiedenen Datenstrukturen (wie Listen, Matrizen, Data Frames) ist teilweise möglich. Nicht jede Kombination aus Spalten ist sinnvoll in eine Matrix konvertierbar, da Matrizen homogene Datentypen erfordern. Der Umgang mit verschachtelten Strukturen (Listen in Data Frames oder Arrays als Spalten) erfordert besondere Aufmerksamkeit, da Standardfunktionen wie \lstinline|as.data.frame()| oder die Basis-Subsetting-Syntax hier an Grenzen stoßen oder sich unerwartet verhalten können.

\begin{lstlisting}
l <- list(a=1:2, b=list(1, 1:2))
data.frame(l)    # Wandelt b in 2 Vektorspalten um
as.data.frame(l) # Wandelt b in 2 Vektorspalten um
d <- list2DF(l)  # b bleibt als Liste erhalten

d$c <- matrix(1:4, 2)       # Matrix als Spalte
d$d <- array(1:8, c(2,2,2)) # Array als Spalte
d[1,]           # Funktioniert bei Array nicht wie erwartet
tibble::tibble(d)[1,]       # Hier wie erwartet

#as.matrix(d)         ## Error
as.matrix(d[c(1,2)])  # Geht
as.matrix(d[c(1,3)])  # Geht
#as.matrix(d[c(2,3)]) ## Error

ti <- tibble::as_tibble(d) # Verliert row.names
as.data.frame(ti)  # default Row.names (1, 2, 3, ...)
\end{lstlisting}

Der Hauptunterschied zwischen \lstinline|matrix()| und \lstinline|as.matrix()| liegt in ihrem Verwendungszweck:
\begin{itemize}
\item \lstinline|matrix()| ist ein \emph{Konstruktor}, der einen Datensatz nimmt und ihn anhand spezifischer Dimensionen (\lstinline|nrow|, \lstinline|ncol|) neu formt.
\item \lstinline|as.matrix()| ist eine \emph{Konvertierungsfunktion}, die versucht, ein bestehendes Objekt (wie einen Data Frame) in eine Matrix umzuwandeln, wobei sie die Dimensionen beibehält, aber die Daten zu einem einzigen, homogenen Typ (z.B. \lstinline|character|) konvertiert.
\end{itemize}

\begin{lstlisting}
d <- data.frame(a = 1:2, b = c("x", "y"))
as.matrix(d)  #      a   b  ; alles wird character
              # [1,] "1" "x"
              # [2,] "2" "y"
m <- matrix(d) # integer,2 character,2; Listenmatrix
m[[1]]        # 1 2
m[[2]]        # "x" "y"
\end{lstlisting}


\subsection{Sprach- bzw.\ Codeobjekte}

Sprachobjekte (\emph{language objects}) repräsentieren Programmcode als Datenstruktur, ohne ihn auszuwerten. Dadurch kann Code inspiziert, analysiert und ggf. verändert werden, bevor er ausgeführt wird.

Bevor man die Objekttypen betrachtet, muss man verstehen, wie die Auswertung verzögert und erzwungen wird.

\begin{itemize}
    \item \lstinline|quote()|: Verhindert die Auswertung eines Ausdrucks und gibt ihn als Sprachobjekt zurück.
    \item \lstinline|eval()|: Wertet ein Sprachobjekt in einer angegebenen Umgebung (\emph{environment}) aus.
    \item \lstinline|evalq()|: Eine Kurzform, die das Argument intern zitiert, bevor es ausgewertet wird.
\end{itemize}

\begin{lstlisting}
u <- quote(1 + 1)
u                 # 1 + 1
eval(u)           # 2

u <- quote(x + 1)
x <- 1
eval(u)           # 2
l <- list(x = 2)
eval(u, l)        # 3

l <- list(x = 2)
eval(x + 1, l)    # 2; Wertet x + 1 gleich zu 1 + 1 => 2 aus
eval(quote(x + 1), l) # 3
evalq(x + 1, l)   # 3; Kurzform

l <- list(x=0, `+` = \(l, r) l - r)
eval(u, l)        # -1; + von eigener Funktion verdeckt

u <- quote(x <- 2)
x                 # 1
eval(u)
x                 # 2
e <- new.env()
e$x <- 0
eval(u, e)
e$x               # 2
l <- list(x = 0)
eval(u, l)
l$x               # 0; ! Liste nur lesend
e2 <- list2env(l)
eval(u, e2)
e2$x              # 2

typeof(u)          # "language"
is.language(u)     # TRUE
\end{lstlisting}

Wenn Ausdrücke als Text vorliegen kann dieser mit \lstinline|str2lang()| in ein Sprachobjekt verwandelt werden. Dies ermöglicht Code aus externen Quellen (z.\,B.\ Benutzereingaben, Textdateien) auszuführen.

\begin{lstlisting}
s <- "1 + 1" 
u <- str2lang(s)
u                 # 1 + 1
eval(u)           # 2
\end{lstlisting}

Die Verwendung von \lstinline|str2lang()| oder \lstinline|parse()| in Verbindung mit Benutzereingaben ist riskant. Da beliebiger Code ausgeführt werden kann, besteht die Gefahr einer \emph{Code Injection}.

In R gibt es drei grundlegende Typen von Sprachobjekten, die den Code repräsentieren:

\begin{description}
\item[Namen oder Symbole:] Ein Verweis auf ein Objekt (z.\,B.\ ein Variablenname).
\item[Calls:] Repräsentieren einen noch nicht ausgeführten Funktionsaufruf. Sie bestehen aus dem Funktionsnamen und den dazugehörigen Argumenten.
\item[Konstanten:] Einfache Werte wie \lstinline|10| oder \lstinline|"Licht"| sind Blätter im Ausdruckbaum. Sie evaluieren zu sich selbst und haben nicht den Typ \lstinline|language|, gehören aber zur vollständigen Repräsentation von Code.
\end{description}

Weiters gibt es noch:

\begin{description}
\item[Expressions:] Ein spezieller Vektortyp, der als Container für mehrere Sprachobjekte fungiert und diese zusammenfasst.
\item[alist:] Eine spezialisierte Liste, die ihre Argumente nicht auswertet. Sie erlaubt im Gegensatz zu \lstinline|list()| leere Argumente.
\item[Formula:] Beschreibt die Beziehung zwischen Variablen. Sie ist ein \lstinline|call| der Funktion \lstinline|~|, der zusätzlich seine Entstehungsumgebung (\emph{environment}) speichert.
\item[Function:] Repräsentiert den ausführbaren Programmcode selbst, bestehend aus Argumentliste (\emph{formals}), Funktionskörper (\emph{body}) und Umgebung (\emph{environment}).
\end{description}

\subsubsection{Namen bzw.\ Symbole}

\emph{Namen} (= \emph{Symbol}) zeigen auf Objekte (z.\,B.\  Variablen oder Funktionen), ohne diese selbst zu sein.

\lstinline|is.name()| prüft, ob ein Objekt ein Name (Symbol) ist, während \lstinline|as.name()| einen Namen aus einem Zeichenstring erzeugt. \lstinline|is.symbol()| und \lstinline|as.symbol()| sind äquivalente Synonyme.

\begin{lstlisting}
is.name(1)         # FALSE; 1 ist kein Name
is.language(1)     # FALSE
x <- 1
is.name(x)         # FALSE; x wird zu 1 ausgewertet
is.name(quote(x))  # TRUE
is.language(quote(x)) # TRUE
s <- "x"
n <- as.name(s)
n                  # x
eval(n)            # 1
mode(n)            # "name"
typeof(n)          # "symbol"
\end{lstlisting}

\subsubsection{Call}

Ein Call-Objekt repräsentiert einen noch nicht ausgeführten Funktionsaufruf. Sein erstes Element ist der Name (Symbol) der aufzurufenden Funktion, die weiteren Elemente sind die Argumente.

\lstinline|call()| erzeugt einen Call, \lstinline|is.call()| testet ob das Objekt ein Call ist und \lstinline|as.call()| wandelt eine Liste in einen Call um.

\begin{lstlisting}
cl <- call("round", 10.5) # Erzeugt round(10.5)
cl                        # round(10.5)
is.call(cl)               # TRUE
cl[[1]]                   # round; Name der Funktion
is.name(cl[[1]])          # TRUE
cl[[2]]                   # 10.5; Argument
eval(cl)                  # 10; Auswertung des Calls
cl[[3]] <- 1              # Weiteres Argument
cl                        # round(10.5, 1)
eval(cl)                  # 10.5

cl <- call("round", 10.5)
cl$digits <- 1            # Weiteres Argument
eval(cl)                  # 10.5

cl <- quote(round(10.5))  # Erzeugt hier Call-Objekt
cl                        # round(10.5)

l <- list(quote(round), 10.5)
cl <- as.call(l)          # Wandelt list in call
cl                        # round(10.5)

cl <- quote(1 + 2)        # Ebenfalls Call-Objekt
is.call(cl)               # TRUE
cl[[1]]                   # `+`

mode(cl)                  # call
\end{lstlisting}

\subsubsection{Expressions}

Eine \emph{expression} ist ein spezieller Vektortyp, der Sprachobjekte (Calls, Symbole oder Konstanten) in unevaluierter Form speichert. Im Gegensatz zu \lstinline|quote()|, das nur ein einzelnes Objekt zurückgibt, kann eine Expression mehrere Ausdrücke zusammenfassen und ähnlich wie eine Liste indiziert oder erweitert werden.

\lstinline|eval()| führt die enthaltenen Ausdrücke innerhalb der Expression nacheinander aus und gibt das Ergebnis des letzten Ausdrucks zurück.

\begin{lstlisting}
ex <- expression(x <- 1, x + 1)
length(ex)           # 2
ex[[1]]              # x <- 1
is.call(ex[[1]])     # TRUE

#x                   ## Error, x nicht gefunden
eval(ex)             # 2
x                    # 1

ex[[1]] <- quote(x <- 2) # Ändern
eval(ex)             # 3

ex <- c(ex, quote(x * x)) # Anfügen
eval(ex)             # 4

mode(ex)             # expression
\end{lstlisting}

Liegen die Ausdrücke in Textform vor, können sie mit \lstinline|parse(text = ...)| oder \lstinline|str2expression()| in Sprachobjekte umgewandelt werden.
\lstinline|deparse()| wandelt eine Expression in die Textform.

\begin{lstlisting}
s <- c("x <- 1", "x + 1")

ex <- parse(text = s)
eval(ex)             # 2

ex <- str2expression(s)
eval(ex)             # 2
deparse(ex)          # "expression(x <- 1, x + 1)"
deparse(ex[[1]])     # "x <- 1"
\end{lstlisting}


\subsubsection{alist}

Die Funktion \lstinline|alist()| (argument list) erzeugt eine Liste von Argumenten, bei der die Auswertung verzögert wird. Das bedeutet, dass Argumente nicht sofort ausgewertet werden, sondern als Symbole oder Ausdrücke gespeichert bleiben, bis sie tatsächlich benötigt werden.

Intern erzeugt \lstinline|alist()| ein Objekt vom Typ \emph{pairlist}, der exakt die Struktur ist, die R für die formalen Argumente einer Funktion (\lstinline|formals()|) verwendet. Pairlists sind eine spezielle Datenstruktur, die für symbolische Auswertung und zur Handhabung von Funktionsargumenten verwendet wird. Im Unterschied zu normalen Listen erlauben sie es, dass Argumente fehlen (missing), ohne sofort einen Fehler zu werfen.

\begin{lstlisting}
l <- list(1 + 1)
l[[1]]                    # 2; Wurde ausgewertet
al <- alist(1 + 1)
al[[1]]                   # 1 + 1

#l <- list(x = , y = 1)   ## Error, Argument 1 ist leer
al <- alist(x = , y = 1)
al$x                      # Ein missing Symbol
is.symbol(al$x)           # TRUE


args <- alist(a = , b = 1)
body <- quote(a + b)
f <- as.function(c(args, body))
f                         # function (a, b = 1) a + b
f(1)                      # 2
f(1, 2)                   # 3
\end{lstlisting}


\subsubsection{Substitution}

Die Funktion \lstinline|substitute()| führt eine symbolische Ersetzung in einem Ausdruck durch, ohne diesen auszuwerten. Dies ist nützlich, um Code-Strukturen dynamisch zu verändern, bevor sie mit \lstinline|eval()| ausgewertet werden.

\begin{lstlisting}
u <- substitute(x + 1, list(x = 1))
u                     # 1 + 1
eval(u)               # 2

u <- quote(x + 1)
substitute(u, list(x = 1))      # u; sieht nur u
v <- do.call(substitute, list(u, list(x = 1)))
v                     # 1 + 1
eval(v)               # 2
\end{lstlisting}

Mit \lstinline|bquote()| werden Ausdrücke innerhalb von \lstinline|.( )| ausgewertet und in den umgebenden Ausdruck eingesetzt.

\begin{lstlisting}
u <- bquote(.(x) + 1, list(x = 1))
u                     # 1 + 1
eval(u)               # 2
\end{lstlisting}


\subsubsection{Formeln}

Formeln (\lstinline|formula|) beschreiben Beziehungen zwischen Variablen, die Modellierungsfunktionen wie \lstinline|lm()| interpretieren können. Die Interpretation einer Formel hängt von der Funktion ab, die sie verwendet. Formeln sind intern Calls mit dem Operator \lstinline|~|.

\paragraph{Syntax und Operatoren}

Eine Formel wird mit dem Tilde-Operator \lstinline|~| definiert. Die linke Seite steht meist für die abhängige Variable (Response), die rechte für die unabhängigen Variablen (Prädiktoren).

\begin{itemize}
\item \lstinline|y ~ x + z|: \lstinline|y| hängt von \lstinline|x| und \lstinline|z| ab.
\item \lstinline|y ~ x * z|: \lstinline|y| hängt von \lstinline|x|, \lstinline|z| und deren Interaktion \lstinline|x:z| ab (äquivalent zu \lstinline|y ~ x + z + x:z|).
\item \lstinline|y ~ .|: \lstinline|y| hängt von \emph{allen anderen} Variablen im verwendeten Datensatz ab.
\item \lstinline|y ~ x - 1| oder \lstinline|y ~ x + 0|: Unterdrückt den standardmäßig enthaltenen Intercept.
\item \lstinline|~ x + y|: Einseitige Formeln (ohne Response) können für Visualisierungen oder statistische Tests genutzt werden.
\end{itemize}

\paragraph{Technische Eigenschaften}

Formeln sind reguläre Objekte mit einer festen internen Struktur. Formeln speichern nicht nur den Ausdruck, sondern auch das Environment (Umgebung), in der sie erstellt wurden. Variablennamen werden erst zur Modellierungszeit im Kontext eines Datensatzes (\lstinline|data|-Argument) oder der gespeicherten Umgebung aufgelöst.

\begin{lstlisting}
f <- y ~ x + z
class(f)             # "formula"
environment(f)       # R_GlobalEnv

# Interner Aufbau als Sprachelement:
f[[1]]               # Der Operator: `~`
f[[2]]               # Die linke Seite: y
f[[3]]               # Die rechte Seite: x + z

class(f)             # formula
\end{lstlisting}

Bei einer einseitigen Formel (\lstinline|~ x|) verschieben sich die Indizes jedoch (Index 2 ist dann bereits die rechte Seite). \lstinline|attr(terms(f), "response")| ergibt \lstinline|0| bei \lstinline|~ x| und \lstinline|1| bei \lstinline|y ~ x|. Die strukturierte Interpretation einer Formel erfolgt über das \lstinline|terms()|-Objekt, das die standardisierte Repräsentation der Modellterme enthält.

\paragraph{Operatoren und Transformationen}

Operatoren innerhalb von Formeln werden von Modellfunktionen speziell interpretiert:
\begin{itemize}
\item \lstinline|+| fügt Terme hinzu (keine numerische Addition)
\item \lstinline|*| fügt Terme und deren Interaktion hinzu
\item \lstinline|:| für Interaktionen allein (z.\,B.\ lstinline|y ~ x:z|)
\item \lstinline|I()|: Identity schützt arithmetische Ausdrücke vor der speziellen Formel-Interpretation, z.\,B.\ \lstinline|y ~ I(x1 + x2)| (Summe der Werte) oder \lstinline|I(x^2)|
\item \lstinline|factor()|: Erzwingt kategoriale Behandlung und entsprechende Kontrastkodierung (Dummy-Kodierung)
\item \lstinline|poly()| für Polynome (z.\,B.\ lstinline|y ~ poly(x, 2)|)
\item \lstinline|offset()| addiert zum Intercept (z.\,B.\ lstinline|y ~ offset(o)|)
\item \lstinline|^n|: Erstellt alle Interaktionen bis zum Grad $n$, z.\,B. \lstinline|(a + b + c)^2|
\item \lstinline{|}, \lstinline|/| oder \lstinline|%in%| für geschachtelte Effekte (z. B. in gemischten oder hierarchischen Modellen)
\end{itemize}

Funktionen können direkt in der Formel genutzt werden (z.\,B.\ \lstinline|y ~ log(x) + factor(z)|).

\paragraph{Verändern}

Die Funktion \lstinline|update()| nutzt den Punkt \lstinline|.| als Platzhalter für den aktuellen Inhalt der Formelseite.

\begin{lstlisting}
f <- y ~ x + z
update(f, log(y) ~ .)            # log(y) ~ x + z
update(f, . ~ log(x) + z)        # y ~ log(x) + z
update(f, . ~ . + log(x))        # y ~ x + z + log(x)
update(f, . ~ . - x)             # y ~ z
update(f, . ~ . - x + log(x))    # y ~ z + log(x)
s <- "x"
a <- "log(x)"
update(f, paste(". ~ . -",s,"+",a)) # y ~ z + log(x)
update(f, as.formula(paste(". ~ . -", s, "+", a)))
\end{lstlisting}


\paragraph{Anwendungsbeispiel}

Formeln können direkt in Modellfunktionen wie \lstinline|lm()| (lineare Modelle) verwendet werden. Dabei werden die Variablennamen im Kontext eines \lstinline|data.frame| aufgelöst.

Es wird der Verbrauch (\lstinline|mpg|) durch Gewicht (\lstinline|wt|) und Zylinder (\lstinline|cyl|) beschrieben (\lstinline|mpg ~ wt + cyl|). Verwendet wird der mit R mitgelieferte Datensatz \lstinline|mtcars|.

\begin{lstlisting}
m <- lm(mpg ~ wt + cyl, data = mtcars)

f <- mpg ~ wt + cyl
m <- lm(f, mtcars)
\end{lstlisting}

Intern werden Formeln von Modellfunktionen in eine Modell- oder Designmatrix übersetzt (\lstinline|model.matrix()|). Diese Matrix enthält für jeden Term eine oder mehrere Spalten und bildet die Grundlage der Schätzung. \lstinline|model.frame()| liefert die gefilterten Rohdaten, die nur die in der Formel vorkommenden Variablen enthält, eventuelle Transformationen (wie \lstinline|log()|) bereits ausgeführt und (standardmäßig) Zeilen mit NA entfernt hat.

\begin{lstlisting}
model.matrix(mpg ~ wt * cyl, mtcars)
 #                     (Intercept)    wt cyl wt:cyl
 # Mazda RX4                     1 2.620   6 15.720
 # Mazda RX4 Wag                 1 2.875   6 17.250

model.frame(mpg ~ wt * cyl, mtcars)
 #                      mpg    wt cyl
 # Mazda RX4           21.0 2.620   6
 # Mazda RX4 Wag       21.0 2.875   6
\end{lstlisting}


\section{Programmierung}

Programmierung basiert auf folgenden Konzepten:

\begin{description}
\item[Kontrollstrukturen:] Sie steuern den \emph{Programmfluss}. Man unterscheidet im Wesentlichen zwischen der bedingten Ausführung (Selektion) und der Wiederholung von Anweisungen (Iteration/Schleifen).
\item[Bedingte Ausführung (Selektion):] Ermöglichen es, basierend auf logischen Bedingungen selektiv zwischen verschiedenen Codeabschnitten zu verzweigen und diese auszuführen (\lstinline|if|, \lstinline|switch|).
\item[Schleifen (Iteration):] Sie dienen dazu, Anweisungsblöcke zu wiederholen (\lstinline|for|, \lstinline|while|), wobei in der Regel Laufvariablen oder Datenstrukturen verändert werden.
\item[Funktionen:] Sie ermöglichen es, Programmcode modular zu strukturieren und wiederverwendbare Codeabschnitte zu erstellen.
\end{description}

Zusätzlich sind Werkzeuge zur Fehlersuche und -behandlung während der Programmausführung hilfreich.

In R wird gegenüber Schleifen meist die \emph{Vektorisierung} bevorzugt. Operationen werden auf ganze Vektoren oder Datenstrukturen angewendet, anstatt elementweise über Schleifen zu iterieren. Das kann zu kürzerem, lesbarerem und schnellerem Code führen. Explizite Schleifen sollten nur verwendet werden, wenn Vektorisierung nicht möglich oder weniger intuitiv ist. Für Aufgaben, die klassischerweise in Schleifen gelöst werden, gibt es verschiedene Funktionen. Diese Funktionen und deren Arbeitsweise muss man jedoch erst erlernen, um effizient mit ihnen arbeiten zu können.


\subsection{Kommentar}

Ein Kommentar wird mit \lstinline|#| eingeleitet und gilt bis zum Zeilenende. 

Echte mehrzeilige Kommentare sind in R nicht vorgesehen. Eine Umgehungslösung besteht darin, einen Textbereich als String zu definieren, ohne ihn einer Variablen zuzuweisen. Hierfür eignet sich insbesondere der Raw-String \lstinline|r"( ... )"|. Zu beachten ist jedoch, dass diese Methode bei der Codeauswertung minimal Arbeitsspeicher alloziert, da der String technisch gesehen ein Objekt ist.

\begin{lstlisting}
1 + 1         # Ergibt 2
# 1 + 1       # Diese Zeile wird ignoriert

"Ein String als 'Kommentar'
über mehrere Zeilen"

r"( Ein Raw-String erlaubt auch
Anführungszeichen " '
direkt im Text )"
\end{lstlisting}


\subsection{Statement Terminator (Anweisungsabschluss)}

Der Statement Terminator ist wichtig, um in Anweisungen korrekt zu trennen.
Anweisungen werden in R standardmäßig durch einen \emph{Zeilenumbruch} (Newline) abgeschlossen. Alternativ kann das Semikolon (\lstinline|;|) verwendet werden, um mehrere Befehle in einer einzigen Zeile zu trennen.

Ein Zeilenumbruch führt jedoch nur dann zu einem Abschluss, wenn der bisherige Code syntaktisch vollständig ist. Ist dies nicht der Fall (z.\,B.\ nach einem mathematischen Operator oder einer offenen Klammer), setzt R die Anweisung in der nächsten Zeile fort.

\begin{lstlisting}
x <- 1             # Abschluss mit Newline
x + 1              # 2

x <- 2;            # Abschluss mit Semikolon und Newline
x + 1;             # 3

#x <- 3 x + 1      ## Error: unerwartetes Symbol

x <- 4; x + 1      #5; Mehrere Befehle in einer Zeile

1 +                # Ausdruck unvollständig
2                  # 3

1                  # 1; Ausdruck vollständig
+ 2                # 2

(1                 # Durch Klammer ist Ausdruck vollständig
+ 2)               # 3

{1                 # Sind zwei separate Befehle
+ 2}               # 2

{x <- 3            # Erste Anweisung
  x + 1}           # 4; Zweite Anweisung

#(x <- 3
#  x + 1)          # Error: unerwartetes Symbol
\end{lstlisting}


\subsection{Operatoren und Mengenoperationen}

Dieses Kapitel behandelt die Werkzeuge zur arithmetischen und logischen Datenmanipulation sowie zur Arbeit mit Mengen.


\subsubsection{Arithmetische Operatoren}

Arithmetische Operatoren führen mathematische Berechnungen durch. In R werden diese Operationen standardmäßig elementweise auf Vektoren angewendet.

\paragraph{Grundrechenarten}

Die klassischen Grundrechenarten folgen den üblichen mathematischen Regeln. Bei der Verwendung von Vektoren wird das Element an Position von Vektor \lstinline|x| mit dem Element an Position von Vektor \lstinline|y| verarbeitet.

\begin{lstlisting}
x <- 1:3
y <- c(2, 4, 6)
x + y     # 3 6 9   ; Elementweise Addition
x - y     # -1 -2 -3; Subtraktion
x * y     # 2 8 18  ; Multiplikation
y / x     # 2 2 2   ; Division
x^2       # 1 4 9   ; Potenzierung
\end{lstlisting}

\paragraph{Ganzzahlige Division und Modulo}

Für spezialisierte Berechnungen bietet R Operatoren an, die nur den Rest einer Division oder nur den ganzzahligen Anteil zurückgeben.

\begin{lstlisting}
x <- 1:3
x %/% 2   # 0 1 1; Ganzzahldivision
x %% 2    # 1 0 1; Rest der Division (Modulo)
\end{lstlisting}

\paragraph{Reihenfolge der Auswertung}

R folgt der Standard-Mathematik (Punkt- vor Strichrechnung). Um die Priorität zu ändern, werden runde Klammern verwendet.

\begin{lstlisting}
1 + 2 * 3    # 7; Multiplikation vor Addition
(1 + 2) * 3  # 9; Klammer erzwingt Addition zuerst
\end{lstlisting}

\subsubsection{Vergleichsoperatoren}

Vergleichsoperatoren prüfen Bedingungen und geben einen logischen Vektor (\lstinline|TRUE| oder \lstinline|FALSE|) zurück.

\begin{lstlisting}
x <- 1:3
x < 2   # TRUE  FALSE FALSE; Kleiner als
x > 2   # FALSE FALSE TRUE ; Groesser als
x <= 2  # TRUE  TRUE  FALSE; Kleiner oder gleich
x >= 2  # FALSE TRUE  TRUE ; Groesser oder gleich
x == 2  # FALSE TRUE  FALSE; Gleichheit
x != 2  # TRUE  FALSE TRUE ; Ungleichheit
\end{lstlisting}

\subsubsection{Logische Operatoren}

Logische Operatoren werden genutzt, um mehrere Bedingungen miteinander zu verknüpfen oder Wahrheitswerte zu invertieren.

\paragraph{Elementweise Verknüpfung}

Die Operatoren \lstinline|&| (UND) und \lstinline||| (ODER) vergleichen Vektoren Element für Element.

\begin{lstlisting}
x <- 1:3
x > 1 & x < 3   # FALSE TRUE  FALSE; UND (elementweise)
x > 1 | x < 3   # TRUE  TRUE  TRUE ; ODER (elementweise)
xor(x>1, x<3)   # TRUE  FALSE TRUE ; Exklusives ODER
!(x > 1)        # TRUE  FALSE FALSE; Negation (NICHT)
\end{lstlisting}

\paragraph{Kurzschluss-Auswertung}

Die verdoppelten Operatoren \lstinline|&&| und \lstinline{||} sind für Skalare (Vektoren der Länge 1) konzipiert und werden vorrangig in \lstinline|if|-Bedingungen eingesetzt. Sie brechen die Auswertung ab, sobald das Gesamtergebnis bereits feststeht (Short-circuiting).

\begin{lstlisting}
FALSE && TRUE          # FALSE
TRUE  || FALSE         # TRUE
l <- TRUE
FALSE && (l <- FALSE)  # Auswertung bis Ergebnis klar
l                      # TRUE
TRUE && (l <- FALSE)
l                      # FALSE
\end{lstlisting}

\subsubsection{Hilfsfunktionen für Logik}

Zusätzlich zu den Operatoren bietet R Funktionen an, um logische Vektoren zusammenzufassen oder zu untersuchen.

\begin{lstlisting}
x <- 1:3
sum(x > 1)        # 2   ; Anzahl der Elemente > 1
any(x > 2)        # TRUE; Mindestens ein TRUE?
all(x > 0)        # TRUE; Alle TRUE?
which(x > 1)      # 2 3 ; Indizes der TRUE-Werte
\end{lstlisting}

\subsubsection{Prüfung von Gleichheit}

Während der Operator \lstinline|==| lediglich Werte vergleicht und dabei eine automatische Typanpassung vornimmt, prüft die Funktion \lstinline|identical(x, y)| auf exakte Gleichheit. Dies umfasst neben dem Wert auch den Datentyp, Attribute (wie Namen) und die Länge der Objekte.

\begin{lstlisting}
1 == 1L           # TRUE ; Wert ist gleich
identical(1, 1L)  # FALSE; Typ unterschiedlich
\end{lstlisting}


\subsubsection{Mengenoperationen}

Mengenoperationen vergleichen die Elemente von Vektoren. Dabei spielen weder Häufigkeit noch Reihenfolge der Elemente eine Rolle.

\paragraph{union(x, y)}

Die Funktion \lstinline|union(x, y)| bildet die Vereinigungsmenge. Sie kombiniert alle Elemente aus beiden Vektoren zu einem einzigen Vektor, wobei jedes Element nur einmal aufgeführt wird.

\begin{lstlisting}
a <- c(3, 2, 1)
b <- c(3, 4, 5, 5)
union(a, b)         # 3 2 1 4 5
\end{lstlisting}

\paragraph{intersect(x, y)}

Mit \lstinline|intersect(x, y)| wird die Schnittmenge ermittelt. Das Ergebnis enthält nur die Elemente, die sowohl in \lstinline|x| als auch in \lstinline|y| vorhanden sind.

\begin{lstlisting}
a <- c(3, 2, 1)
b <- c(3, 4, 5, 3)
intersect(a, b)     # 3
\end{lstlisting}

\paragraph{setdiff(x, y)}

Die Funktion \lstinline|setdiff(x, y)| berechnet die Differenzmenge (Komplement). Sie gibt alle Elemente zurück, die in \lstinline|x| enthalten sind, aber nicht in \lstinline|y|. Die Funktion ist nicht symmetrisch; \lstinline|setdiff(x, y)| liefert ein anderes Ergebnis als \lstinline|setdiff(y, x)|.

\begin{lstlisting}
a <- c(1, 2, 3)
b <- c(3, 4, 5)
setdiff(a, b)       # 1 2
setdiff(b, a)       # 4 5
\end{lstlisting}

\paragraph{setequal(x, y)}

\lstinline|setequal(x, y)| prüft, ob zwei Vektoren als Mengen identisch sind. Sie gibt \lstinline|TRUE| zurück, wenn beide Vektoren dieselben Elemente enthalten, ungeachtet ihrer Anordnung oder Häufigkeit.

\begin{lstlisting}
setequal(c(1, 2, 2), c(2, 1)) # TRUE
setequal(c(2, 2), c(2, 1))    # FALSE
\end{lstlisting}


\subsubsection{Duplikate}

Ein Vektor wird hinsichtlich mehrfach vorkommender Werte analysiert oder bereinigt.

\paragraph{unique(x)}

Die Funktion \lstinline|unique(x)| entfernt alle redundanten Werte aus einem Vektor. Es bleibt jeweils nur das erste Vorkommen eines Elements erhalten, wodurch die ursprüngliche Reihenfolge (der ersten Vorkommen) gewahrt bleibt.

Schnelle Alternativen wären beispielsweise \lstinline|kit::funique()| oder \lstinline|collapse::funique()| wobei bei collapse auch eine integrierte Sortiermöglichkeit bietet.


\begin{lstlisting}
x <- c(3, 1, 2, 3, 1)
unique(x)                  # 3 1 2
kit::funique(x)            # 3 1 2
collapse::funique(x)       # 3 1 2
collapse::funique(x, TRUE) # 1 2 3; Sortiert
sort(unique(x))            # 1 2 3
\end{lstlisting}

\paragraph{duplicated(x)}

\lstinline|duplicated(x)| ermittelt Duplikate innerhalb eines Vektors. Sie gibt einen logischen Vektor zurück, bei dem jedes Element, das zu einem früheren Zeitpunkt im Vektor bereits aufgetreten ist, als \lstinline|TRUE| markiert wird. Das erste Auftreten eines Wertes wird stets als \lstinline|FALSE| gewertet.

\begin{lstlisting}
x <- c("A", "B", "A", "C")
duplicated(x)    # FALSE FALSE TRUE FALSE
x[duplicated(x)] # "A"; Zeigt Duplikate
\end{lstlisting}


\subsection{Klammern}

Klammern dienen zur Gruppierung von Ausdrücken, Steuerung der Auswertungsreihenfolge und zum Aufruf von Funktionen. Geöffnete runde Klammern verhindern den automatischen Anweisungsabschluss durch einen Zeilenumbruch.

\begin{itemize}
\item \textbf{()} : Funktionsaufruf und Reihenfolge (Mathematik/Logik).
\item \textbf{{}} : Gruppierung von Befehlen zu einem Block.
\item \textbf{[]} : Auswahl von Daten (Position/Name).
\end{itemize}

\subsubsection{Runde Klammern ()}

Runde Klammern werden verwendet für:
\begin{itemize}
\item den Aufruf von Funktionen (Argumentliste),
\item die Steuerung der Auswertungsreihenfolge (Präzedenz).
\end{itemize}

Ein Ausdruck, der in Klammern gesetzt wird, erzeugt in der Konsole eine Ausgabe.

\begin{lstlisting}
3 * 2 + 1         # 7; 3 * 2 => 6, 6 + 1 => 7
3 * (2 + 1)       # 9; 2 + 1 => 3, 3 * 3 => 9
3 * {2 + 1}       # 9; unüblich

Sys.Date          # Zeigt Funktionscode
Sys.Date()        # "2026-01-04"; Ruft Funktion auf
Sys.Date  ()      # "2026-01-04"; Abstand erlaubt
#Sys.Date{}       ## Error, geschweifte Klammern

x <- 42           # Zuweisung ohne direkte Ausgabe
(x <- 42)         # 42; Zuweisung UND Ausgabe des Wertes

#x <- ()          ## Error

(1
+ 2)               # 3
\end{lstlisting}

\subsubsection{Geschweifte Klammern \{\}}

Geschweifte Klammern fassen einen oder mehrere Befehle zu einer logischen Einheit, einem \emph{Codeblock}, zusammen. Sie dienen jedoch nicht zur Kapselung von Variablen. Variablen, die innerhalb der Klammern definiert oder verändert werden, sind sofort im aktuellen Environment (Gültigkeitsbereich) wirksam. Eine Kapselung in einer neuen Umgebung kann z.\,B.\ mit \lstinline|local()| realisiert werden.

Ein Block gibt immer den Wert des \emph{letzten} evaluierten Ausdrucks zurück.  Sie können damit auch zur Steuerung der Reihenfolge von Auswertungen verwendet werden.

Codeblocks werden bei Kontrollstrukturen (z.\,B.\ \lstinline|if|) oder Funktionsdefinitionen notwendig, die mehr als einen Befehl ausführen. Ein einzelner Ausdruck benötigt keine geschweiften Klammern.

\begin{lstlisting}
x <- 0
y <- 0
if (FALSE) x <- 1; y <- 1  # Nur erster Ausdruck ist Teil von if
x                 # 0
y                 # 1
if (FALSE) {x <- 2; y <- 2} # Ganzer Block ist Teil von if
x                 # 0
y                 # 1
#if (FALSE) (x <- 2; y <- 2) ## Error, Runde Klammern

x <- {a <- 1
      b <- 2
      a + b}      # Letzter Ausdruck bestimmt Rückgabewert
x                 # 3

x <- {}           # Ein leerer Block gibt NULL zurück
x                 # NULL

3 * {2 + 1}       # 9; unüblich

{x <- 42}         # Zuweisung im Block ohne automatische Ausgabe
x                 # 42
local(x <- 7)     # Kapselung
x                 # 42

{1
+ 2}               # 2
\end{lstlisting}

\subsubsection{Eckige Klammern []}

Eckige Klammern dienen dem \emph{Indexing} (Indizierung) und \emph{Slicing} (Ausschneiden) von Datenstrukturen.

\begin{itemize}
\item \lstinline|[ ]|: Zugriff auf ein oder mehrere Elemente einer Datenstruktur zu, wobei die Struktur selbst unverändert bleibt.
\item \lstinline|[[ ]]|: Zugriff auf ein einzelnes Element (extrahiert den Inhalt, oft bei Listen oder Data Frames).
\end{itemize}

\begin{lstlisting}
v <- c(10, 20, 30) # Ein Vektor
v[1]               # 10; Zugriff auf das erste Element
v[c(1, 3)]         # 10 30; Zugriff auf mehrere Elemente
v[
2
]                  # 20; Zeilenumbruch Erlaubt
v[] <- 0           # Alle Werte im Vektor werden 0

l <- list(a = 1, b = 2)
l[1]         # Gibt eine Liste mit dem Element 'a' zurück
l[[1]]       # 1; Extrahiert den reinen Wert des ersten Elements
\end{lstlisting}

\subsection{Anführungszeichen}

Anführungszeichen werden verwendet, um Text (Zeichenketten/Strings) zu definieren oder um Namen bzw.\ Symbole anzusprechen, die nicht den Standard-Namensregeln entsprechen.

\begin{itemize}
\item \lstinline|" "| \lstinline|' '| : Erzeugen von Textdaten (Character).
\item \lstinline|` `| : Maskierung von ungültigen oder speziellen Variablennamen.
\end{itemize}

\subsubsection{Einfache und doppelte Anführungszeichen}

In R sind einfache und doppelte Anführungszeichen funktional identisch. Sie markieren den Anfang und das Ende einer Zeichenkette. Möchte man ein Anführungszeichen innerhalb eines Textes verwenden, nutzt man den jeweils anderen Typ als Begrenzung, alternativ kann es mit \lstinline|\| maskiert werden.

R verwendet \lstinline|"| bei der Standardausgabe und maskiert dabei im String enthaltene \lstinline|"|. Die Funktion \lstinline|cat()| gibt den String ohne begrenzende Anführungszeichen und ohne Maskierung aus.

\begin{lstlisting}
s1 <- "Mehr Licht"     # Standard
s2 <- 'Mehr Licht'     # Gleichwertig

s1 <- "Mehr 'Licht'"
s2 <- 'Mehr "Licht"'

s1 <- "Mehr \"Licht\""
s2 <- 'Mehr \'Licht\''

s1                     # "Mehr \"Licht\""
cat(s1)                # Mehr "Licht"
\end{lstlisting}

Es gibt Steuerungszeichen wie \lstinline|\n| (neue Zeile), die interpretiert werden. Um einen tatsächlichen Backslash \lstinline|\| zu schreiben, muss dieser verdoppelt werden (\lstinline|\\|).

\begin{lstlisting}
cat("Mehr\nLicht")
 # Mehr
 # Licht
cat("Mehr \\ Licht")   # Mehr \ Licht
\end{lstlisting}

%\subsubsection{Raw-String r"(...)"}
%\subsubsection{Raw-String \texttt{r\dq(...)\dq}}
\subsubsection{Raw-String r\textquotedbl(...)\textquotedbl}

Ein \emph{Raw-String} wird mit \lstinline|r"(| eingeleitet und mit \lstinline|)"| beendet. Das Startsignal kann durch weitere Zeichen zwischen \lstinline|"| und \lstinline|(| ergänzt werden (z.\,B.\ \lstinline|r"---(| und \lstinline|r"---)|) oder die runde Klammer wird durch eine geschweifte ersetzt (\lstinline|r"{| und \lstinline|r"}|). Dadurch kann \lstinline|")| im String verwendet werden, ohne es zu maskieren. Der String-Inhalt wird zudem nicht interpretiert (Backslashes bleiben erhalten).

\begin{lstlisting}
s <-  r"(Mehr Licht)"
s <-  r"('Mehr' "Licht")"
s <-  r"{'Mehr' "Licht"}"
s <-  r"---('Mehr' )"Licht")---"
cat(r"(Mehr\nLicht)")      # Mehr\nLicht
\end{lstlisting}


\subsubsection{Backticks}

Backticks (Gravis) dienen dazu, \emph{Bezeichner} (Namen, Symbole) anzusprechen, die nicht den Standard-Namensregeln entsprechen. Dies umfasst Namen mit Sonderzeichen, Leerzeichen oder reservierte Wörter (z.\,B.\ \lstinline|if|, \lstinline|TRUE|).

\begin{lstlisting}
"a b" <- 1         # Zuweisung via String möglich
`c d` <- 2
`a b` + `c d`      # 3
#"a b" + `c d`     ## Error: Nicht numerisch

#TRUE <- "x"      ## Error: Zuweisung an TRUE
`TRUE` <- "x"
TRUE              # TRUE;  Original-Konstante
`TRUE`            # x; Variable

`+`(2, 3)          # 5; Operator als Funktion (2 + 3)
outer(1:2, 1:2, `-`)
\end{lstlisting}


\subsubsection{Backticks vs.\ Anführungszeichen}

Der grundlegende Unterschied liegt darin, was der Ausdruck repräsentiert: Anführungszeichen erzeugen ein Datenobjekt vom Typ \emph{Character} (Text), während Backticks einen \emph{Namen} (ein Symbol) referenzieren, der auf ein Objekt zeigt.

\begin{tabular}{lll}
  \hline
  & Anführungszeichen \lstinline|"| & Backticks \lstinline|`| \\
  \hline
  Typ    & String            & Symbol          \\
  Zweck  & Textdaten         & Referenz        \\
  Zeigt  & Zeichenkette      & Objekt/Inhalt   \\
  Aufruf & Nicht ausführbar  & Ausführbar      \\
  \hline
\end{tabular}

Obwohl R bei Zuweisungen historisch bedingt kulant ist und Strings teilweise wie Namen behandelt, sollte beim Schreiben von Programmen deutlich gemacht werden, ob man einen Namen (\lstinline|`|) oder einen String (\lstinline|"|) meint:

\begin{lstlisting}
`x` <- 1      # Zuweisung an x
y <- `x`      # y erhält den Wert von x
x             # 1
y             # 1

"x" <- 2      # Zuweisung an Name "x"
y <- "x"      # y erhält nur den Text "x"
x             # 2
y             # "x"

`+`(2, 3)     # 5
"+"(2, 3)     # 5

f <- `+`      # f zeigt direkt auf die Additions-Funktion
f(2, 3)       # 5

f <- "+"      # f ist jetzt lediglich ein Text-String ("+")
# f(2, 3)     # FEHLER: f ist keine Funktion sondern Text
\end{lstlisting}

\paragraph{Spezialfall: Primitive Funktionen}

Ein markantes Beispiel, bei dem der Unterschied technisch erzwungen wird, ist die Funktion \lstinline|.Primitive|. Sie dient dazu, intern in C implementierte Kernfunktionen von R aufzurufen. Während R an vielen Stellen Namen und Strings austauschbar behandelt, akzeptiert \lstinline|.Primitive| ausschließlich eine Zeichenkette.

\begin{lstlisting}
.Primitive("c")  # function (...) .Primitive("c")
 # OK: String wird als Suchschluessel verwendet
#.Primitive(`c`) ## Error: Zeichenkettenargument benötigt
 # Backticks referenzieren das Objekt (die Funktion selbst) 
#.Primitive(c)   ## Error: Zeichenkettenargument benötigt
 # Name wird zum Objekt evaluiert. Text erwartet
\end{lstlisting}


\subsection{Bedingte Ausführung}

Bedingte Ausführung, auch Selektion genannt, steuern den \emph{Programmfluss} basierend auf logischen Bedingungen. Sie ermöglichen es, Entscheidungen im Code zu treffen und bestimmte Codeabschnitte nur unter bestimmten Umständen auszuführen.

\subsubsection{if}

\lstinline|if ()| erwartet einen einzelnen Wahrheitswert (\lstinline|TRUE| oder \lstinline|FALSE|) und führt den nachfolgenden Befehl nur aus, wenn die Bedingung \lstinline|TRUE| ergibt. Wenn der Ausdruck mehr als einen oder keinen logischen Wert zurückgibt, führt dies zu einem Fehler. \lstinline|if ()| ist ein Ausdruck und gibt den Wert letzten ausgeführten Befehls zurück.

\begin{lstlisting}
x <- 0
if (FALSE) x <- 1   # Einfache Anwendung
x                   # 0
if (TRUE) x <- 2
x                   # 2

x <- if (FALSE) 3   # als Ausdruck mit Zuweisung
x                   # NULL
x <- if (TRUE) 4
x                   # 4

x <- 1:2
#if (x > 0) 1       ## Error: Bedingung hat Länge > 1
x <- NA
#if (x > 0) 1       ## Error: Bedingung ist NA
x <- NULL
#if (x > 0) 1       ## Error: Argument hat Länge 0
x <- numeric()
#if (x > 0) 1       ## Error: Argument hat Länge 0
\end{lstlisting}

Mit \lstinline|isFALSE()| und \lstinline|isTRUE()| kann man auch \lstinline|NA| sinnvoll in einer \lstinline|if ()| Abfrage verarbeiten.

\begin{lstlisting}
x <- 0
if (TRUE) x <- 1
x                              # 1
#if (NA) x <- 2                # Error: NA, wo TRUE/FALSE nötig
if (isTRUE(NA)) x <- 3
x                              # 1
if (isFALSE(NA)) x <- 4
x                              # 1
if (isTRUE(NULL)) x <- 5
x                              # 1
if (isTRUE(numeric())) x <- 6
x                              # 1
\end{lstlisting}

Komplexe Bedingungen können mit logischen Operatoren wie \lstinline|&&| (und), \lstinline{||} (oder) und \lstinline|!| (nicht) kombiniert werden.

\begin{lstlisting}
x <- 2
if (x > 0 && x < 5) 1   # 1

x <- NA
if (!is.na(x) && x > 0) 1 else 0  # 0
\end{lstlisting}


\subsubsection{else}

Das \lstinline|else|-Statement definiert den Alternativpfad bei \lstinline|if|. \lstinline|else| muss direkt hinter dem bei \lstinline|TRUE| ausgeführten Befehl bzw.\ der schließenden Klammer \lstinline|}| des Codeblocks stehen, damit der Interpreter erkennt, dass die Anweisung fortgesetzt wird. \lstinline|else| kann in ein weiteres \lstinline|if ()| verzweigen. Ein \lstinline|if ()| ohne ein \lstinline|else| führt zu keiner Aktion und gibt \lstinline|NULL| zurück. \lstinline|else| sollte nur verwendet werden, wenn es eine alternative Aktion gibt, die ausgeführt werden soll, falls die Bedingung im \lstinline|if ()| nicht erfüllt wird.

\begin{lstlisting}
if (TRUE) 1 else 2     # 1
if (FALSE) 1 else 2    # 2

if (FALSE) 1
# else 2               ## Error: Unerwartetes 'else'

if (FALSE) {
  1
} else {2}           # 2

x <- 0L
if (x > 0L) {
  1
} else if (x < 0L) {
  2
} else {3}           # 3

x <- -1
y <- if(x > 0) x else -x
y                    # 1
\end{lstlisting}


\subsubsection{ifelse}

Die Funktion \lstinline|ifelse(test, yes, no)| ist die vektorisierte Variante der \lstinline|if|-Anweisung. Sie erlaubt es, Bedingungen auf ganze Vektoren anzuwenden, anstatt nur auf einzelne Wahrheitswerte. Trotz ihrer Kompaktheit weist sie wichtige Besonderheiten auf:

\begin{description}
\item[Vollständige Evaluation:] Beide Alternativen (\lstinline|yes| und \lstinline|no|) werden immer vollständig ausgewertet, unabhängig vom Ergebnis des Tests. Dies kann zu unnötigen Berechnungen oder Warnmeldungen führen.
\item[Attributverlust:] \lstinline|ifelse()| ist nicht typsicher für S3-Objekte. Metadaten und Klassen (z.\,B.\ \lstinline|Date| oder \lstinline|factor|) gehen verloren und das Ergebnis wird auf einen Basisdatentyp (meist \lstinline|numeric| oder \lstinline|character|) zurückgeführt.
\item[Umgang mit NA:] Ein \lstinline|NA| im \lstinline|test|-Vektor führt zu einem \lstinline|NA| im Ergebnisvektor.
\end{description}

\begin{lstlisting}
x <- c(1, 42, NA, 3)
y <- ifelse(x > 10, "Gross", "Klein")
y          # "Klein" "Gross" NA "Klein"

x <- c(-1:1)
sqrt(x)                      # NaN 0 1; Warnung
sqrt(ifelse(x >= 0, x, NaN)) # NaN 0 1; Ohne Warnung
ifelse(x >= 0, sqrt(x), NaN) # NaN 0 1; Warnung
sqrt(`[<-`(x, x<0, NaN))     # NaN 0 1; sqrt gibt bei NaN NaN

y <- rep(NaN, length(x))
i <- x >= 0
#i <- which(x >= 0)          # Variante bei wenig TRUE
y[i] <- sqrt(x[i])
y                            # NaN 0 1

x <- seq(as.Date("2000-02-29"), as.Date("2004-10-04"),
         by = "2 years")
x           # "2000-02-29" "2002-03-01" "2004-02-29"
class(x)    # "Date"

y <- ifelse(format(x, "%d") == "29", x, NA)
y           # 11016 NA 12477; Verliert Attribute
class(y)    # "numeric"
class(y) <- class(x)
y           # "2000-02-29" NA "2004-02-29"

y2 <- x
y2[format(x, "%d") != "29"] <- NA # Effizienter
y2          # "2000-02-29" NA "2004-02-29"
\end{lstlisting}

\paragraph{Alternativen zu ifelse}

Da \lstinline|ifelse()| oft unnötig Rechenleistung verbraucht und Metadaten zerstört, könnten folgenden Alternative erwogen werden:

\begin{description}
\item[Funktionale Ersetzung:] Funktionen, die selbst robust mit \lstinline|NA| oder \lstinline|NaN| umgehen können, erlauben es, die Bedingung direkt in den Funktionsaufruf zu integrieren. Der Ausdruck \lstinline|sqrt(`[<-`(x, x < 0, NaN))| ersetzt die Werte im Vektor direkt vor der Berechnung, was die Warnung verhindert.
\item[Indizierte Zuweisung (Subsetting):] Anstatt einen neuen Vektor zu erstellen, wird ein Zielvektor vorinitialisiert (z.\,B.\ mit \lstinline|NaN|) und nur die relevanten Elemente werden überschrieben (\lstinline|y[i] <- ...|).
\item[Typsicheres Ersetzen:] Bei Objekten mit Klassen (z.\,B.\ \lstinline|Date|) bleibt die Struktur durch indizierte Zuweisung (\lstinline|y2[test] <- NA|) erhalten
\end{description}


\subsubsection{switch}

Die Funktion \lstinline|switch()| bietet eine kompakte Möglichkeit, basierend auf dem Wert eines einzelnen Ausdrucks (\emph{Selektor}) verschiedene Aktionen auszuführen. Sie dient als Alternative zu verschachtelten \lstinline|if() ... else|-Konstrukten.

\lstinline|switch(EXPRESSION, ...)| erwartet als erstes Argument einen Selektor, der eine Zeichenkette oder eine Zahl sein muss.

\paragraph{Verwendung mit Zeichenketten}

Ist der Selektor eine Zeichenkette, sucht \lstinline|switch()| nach einem passenden benannten Argument.

\begin{description}
\item[Fall-through:] Ein leeres Argument (z. B. \lstinline|Mittel =,|) bewirkt, dass der Wert des nächsten Arguments verwendet wird.
\item[Default-Wert:] Ein einzelnes unbenanntes Argument am Ende dient als Standardwert. Ohne dieses wird bei fehlender Übereinstimmung \lstinline|NULL| zurückgegeben.
\end{description}

\begin{lstlisting}
x <- c(9,0,2,1,3)
s <- "Mittel"
y <- switch (s,
        Median = median(x),
        Mittel =,            # Geht zur nächsten Zeile
        avg    = mean(x),
        NA)                  # Default-Wert
y                            # 3

x <- switch("b", a = 1, b = 2)  # 2
x                               # 2
x <- switch("z", a = 1, b = 2)
x                               # NULL; Kein Treffer
x <- switch("z", a = 1, b = 2, 7) # Defaultwert
x                               # 7
\end{lstlisting}

\paragraph{Verwendung mit Zahlen}

Ist der Selektor numerisch, wird das Argument basierend auf seiner Position ausgewählt (beginnend bei 1). Ein numerischer Selektor wird abgeschnitten (truncated), nicht gerundet (aus \lstinline|2.9| wird \lstinline|2|).

Da diese Form eine direkter Listen-Zugriff ermöglicht, bietet sie einen Performance-Vorteil. Im Gegenzug ist sie weniger flexibel. Es gibt hier weder Fall-through noch einen Default-Eintrag. Ein Index außerhalb des Bereichs resultiert immer in \lstinline|NULL|.

\begin{lstlisting}
monatNr <- 2
monatName <- switch(
  monatNr,
  "Jan" = "Januar",   # Position 1
  "Feb" = "Februar",  # Position 2
  "Mär" = "März",     # Position 3
  "Unbekannt"         # Position 4
)
monatName # "Februar"

switch(3, 3, 2, 1)        # 1
switch(3.9, 3, 2, 1)      # 1
x <- switch(4, 3, 2, 1)
x                         # NULL
x <- switch(3, 3, , 1)    # 1
#switch(2, 3, , 1)        ## Error, empty alternative
#switch (1:2, a = 0)      ## Fehler, Länge muss 1 sein
\end{lstlisting}


\subsubsection{Logische Indizierung}

Die logische Indizierung nutzt eckige Klammern \lstinline|[]|, um Elemente basierend auf booleschen Vektoren auszuwählen oder zu modifizieren. Sie ist eine effiziente Methode, um Daten ohne explizite Schleifen zu verändern.

\paragraph{Filtern von Vektoren}

Ein Vektor wird mit einem logischen Vektor derselben Länge indiziert. Dabei werden jene Elemente ausgewählt, bei denen im logischen Vektor \lstinline|TRUE| steht.

Indizes mit \lstinline|NA| geben im Ergebnisvektor ebenfalls \lstinline|NA| zurück. Um dies zu verhindern, können \lstinline|NA|-Werte mit \lstinline|is.na()| ausgeschlossen oder der logische Vektor mittels \lstinline|which()| in einen ganzzahligen Index-Vektor umgewandelt werden.

\begin{lstlisting}
x <- 1:5
i <- c(TRUE, FALSE, NA, FALSE, TRUE)

x[i]                  # 1 NA 5
x[!is.na(i) & i]      # 1 5
x[which(i)]           # 1 5
\end{lstlisting}

\paragraph{Bedingte Zuweisung}

Bei der bedingten Zuweisung (Sub-Assignment) werden ausschließlich jene Elemente \emph{in-place} modifiziert, die durch die Bedingung ausgewählt wurden. Alle anderen Elemente bleiben unverändert.

\begin{lstlisting}
x <- c(1, 7, 3, 9, 8)
x[x > 5] <- 5      # Werte begrenzen (In-place)

x <- c(1, 3, NA)
x[x > 2]           # 3 NA
x[x > 2] <- 2
x                  # 1 2 NA; NA bleibt erhalten
\end{lstlisting}

Ein fortgeschrittener Anwendungsfall ist die selektive Anwendung von Funktionen. Im Gegensatz zu \lstinline|ifelse()|, das oft beide Zweige vollständig berechnet, erlauben benutzerdefinierte Funktionen eine effizientere Steuerung, indem Funktionen nur auf die relevanten Teilmengen angewendet werden. Die Beispiele mit Funktionsaufruf arbeiten nicht in-place, was jedoch z.\,B. durch Abarbeitung außerhalb eine Funktion realisiert werden kann.

\begin{lstlisting}
f <- \(x, i, ft, ff) {
  y <- x
  is.na(y) <- TRUE
  j <- !(is.na(x) | is.na(i))
  x <- x[j]
  i <- i[j]
  y[j][i] <- ft(x[i])
  y[j][!i] <- ff(x[!i])
  y
}

f2 <- \(x, i, ft, ff) {
  y <- x
  is.na(y) <- TRUE
  j <- which(!i)
  i <- which(i)
  y[i] <- ft(x[i])
  y[j] <- ff(x[j])
  y
}

x <- c(NA, 0:8 * pi/16)

y1 <- f(x, x < pi/4, sin, cos)
y2 <- f2(x, x < pi/4, sin, cos)
y3 <- ifelse(x < pi/4, sin(x), cos(x))
identical(y1, y2)    # TRUE
identical(y1, y3)    # TRUE
\end{lstlisting}

\paragraph{Vorsicht bei Typumwandlungen}

R erzwingt einen einheitlichen Datentyp pro Vektor. Wenn eine Zuweisung in einen allgemeineren Typ (z.\,B. \lstinline|character|) umwandelt, wird der gesamte Vektor transformiert. Dies kann spätere logische Vergleiche verfälschen. Hier kann nicht in-place sonder muss auf einer Kopie gearbeitet werden.

\begin{lstlisting}
x <- c(1, 3, 10, 8)
x[x < 2] <- "zu klein"
x[x > 7] <- "zu groß"   # Alphabetischer Vergleich!
x     # "zu groß" "3" "10" "zu groß"; 10!

x <- c(1, 3, 10, 8)
y <- x
y[x < 2] <- "zu klein"
y[x > 7] <- "zu groß"
y     # "zu klein" "3" "zu groß" "zu groß"
\end{lstlisting}


\subsubsection{Vectorize}

In der R-Programmierung wird zwischen \emph{natürlicher Vektorisierung} (Funktionen, die intern optimierte C-Schleifen nutzen) und \emph{konzeptioneller Vektorisierung} unterschieden. Während Standardfunktionen wie \lstinline|+|, \lstinline|*| oder \lstinline|sqrt()| hocheffizient sind, erzwingen selbst geschriebene Funktionen mit logischen Verzweigungen (\lstinline|if|, \lstinline|switch|) oft eine manuelle Iteration über die Elemente, da \lstinline|if| nur mit \emph{skalaren} Bedingungen (Länge 1) arbeitet.

\lstinline|Vectorize()| dient hierbei als \emph{Wrapper}. Es automatisiert den Prozess der manuellen Iteration und erzeugt aus einer Funktion, die für einzelne Werte geschrieben wurde, eine Version, die auf Vektoren anwendbar ist.

\begin{description}
\item[Abstraktion:] \lstinline|Vectorize()| ist ein Interface für \lstinline|mapply()|. Es erlaubt die Nutzung einer skalaren Funktion im funktionalen Stil, ohne explizit Schleifen schreiben zu müssen, was besonders nützlich ist, wenn bereits eine skalare Funktion existiert und man diese ohne viel Aufwand auf Vektoren anwenden möchte.
\item[Performance:] Da intern weiterhin eine Schleife über Vektorelemente läuft, ergibt sich \emph{kein} Geschwindigkeitsvorteil gegenüber einer manuellen Schleife. \lstinline|Vectorize()| ist praktisch für schnelle Prototypen oder seltene Anwendungen, sollte jedoch in performancekritischen Szenarien vermieden werden, da zusätzlich noch ein Overhead durch \lstinline|Vectorize()| entsteht.
\item[Parametersteuerung:] Über \lstinline|vectorize.args| wird festgelegt, welche Argumente der Funktion als Vektoren (über die iteriert wird) und welche als feste Parameter (Konstanten) behandelt werden sollen.
\item[Typstabilität:] Durch das Standardargument \lstinline|SIMPLIFY = TRUE| werden komplexe Klassen (wie \lstinline|Date| oder \lstinline|POSIXct|) oft in einfache Atomar-Vektoren umgewandelt, was in vielen Fällen zu einem Verlust der ursprünglichen Struktur führt. \lstinline|SIMPLIFY = FALSE| bewahrt die ursprünglichen Objekte und gibt eine Liste zurück, was vor allem bei der Arbeit mit komplexen Objekten nützlich sein kann.
\end{description}

\begin{lstlisting}
f <- \(x, y) if (x < y) x else y

tx <- as.Date("2025-7-15")
tr <- as.Date("2025-7-1")
f(tx, tr)         # "2025-07-01"

tx <- as.Date(c("2025-06-15", "2025-07-15"))
# f(tx, tr) # Error: if Bedingung hat Länge > 1

fv <- Vectorize(f, vectorize.args = "x")
fv(tx, tr)        # 20254 20270; Verliert Datumsklasse

fv <- Vectorize(f, vectorize.args = "x", SIMPLIFY = FALSE)
x <- fv(tx, tr)   # [[1]] "2025-06-15"  [[2]] "2025-07-01"; Liste
do.call(c, x)     # "2025-06-15" "2025-07-01"; Vektor
\end{lstlisting}


%\subsection{Suchen, Finden und Abgleichen}
\subsection{Suche}

Hier sind Methoden zusammengefasst die von der Existenzprüfung von Werten über deren Positionsbestimmung bis zu zum Vergleich von Mengen reichen.


\subsubsection{\%in\% und is.element}

\lstinline|%in%| prüft für jedes Element des linken Operanden, ob es in der Menge des rechten Operanden enthalten ist. Das Ergebnis ist ein logischer Vektor von der Länge des linken Operanden. Eine schneller Variante ist \lstinline|fastmatch::%fin%|.

Die Funktion \lstinline|is.element(el, set)| ist die funktionale Schreibweise des Operators \lstinline|%in%|.

\begin{description}
\item[Mengenlogik:] \lstinline|%in%| führt einen exakten Abgleich durch. Duplikate im rechten Operanden spielen keine Rolle. Für Teilstring-Suchen ist der Operator nicht geeignet. Hierfür sind \lstinline|grep()| oder \lstinline|grepl()| zu nutzen.
\item[NA-Resilienz:] Er liefert niemals \lstinline|NA| zurück. Ein \lstinline|NA| links wird als \lstinline|FALSE| gewertet, außer \lstinline|NA| ist rechts explizit enthalten).
\item[Einseitigkeit:] Der Operator arbeitet asymmetrisch (\lstinline|x %in% y| ist nicht gleich \lstinline|y %in% x|). Es wird stets nur die Zugehörigkeit der linken Elemente zur rechten Menge bestimmt.
\item[Faktoren:] Der Operator erkennt Übereinstimmungen auch bei \lstinline|factor|-Objekten korrekt, unabhängig davon, ob gegen den Faktor selbst oder dessen \lstinline|levels()| geprüft wird.
\end{description}

\begin{lstlisting}
c(1, 2) %in% c(1, 2, 3)     # TRUE TRUE
c(1, 2, 3) %in% c(1, 2)     # TRUE TRUE FALSE
c(1, 2) %in% c(1, 1, 1, 2)  # TRUE TRUE; 1 1 1 => 1

z <- c(1, 3, 10)
d <- data.frame(a = 1:4, b = 4:1)
d[d$a %in% z,]     #   a b; 1 und 3 in z
                   # 1 1 4
                   # 3 3 2

x <- c(1, 2, NA)
x == 2          # FALSE TRUE NA   ; NA bleibt NA
x %in% 2        # FALSE TRUE FALSE; NA wird zu FALSE
x %in% c(1, 10) # TRUE FALSE FALSE
!x %in% c(1, 10)# FALSE TRUE  TRUE
`%!in%` <- Negate(`%in%`) # eigener Operator
x %!in% c(1, 10)# FALSE TRUE  TRUE
x %in% c(2, NA) # FALSE TRUE  TRUE

l <- list(c("A", "B"), "C", c("B", "D"))
Filter(\(x) "B" %in% x, l) # Listen-Elemente, die B enthalten
 # [[1]] "A" "B"  [[2]] "B" "D"

f <- factor(c("a", "b"))
"a" %in% f          # TRUE
"a" %in% levels(f)  # TRUE
"c" %in% f          # FALSE

is.element(c(1, 10), c(1, 2, 3)) # TRUE FALSE
\end{lstlisting}


\subsubsection{Positionssuche mit match}

Während der Operator \lstinline|%in%| lediglich prüft, \emph{ob} ein Element vorhanden ist (Boolean), geben diese Funktionen die exakte Position (\emph{Index}) des \textbf{ersten} Treffers zurück.

\begin{description}
\item[match(x, table):] Sucht jedes Element von \lstinline|x| in \lstinline|table|. Der Rückgabevektor hat immer die gleiche Länge wie \lstinline|x|.
\item[Argument nomatch:] Bestimmt den Rückgabewert für nicht gefundene Elemente (Standard ist \lstinline|NA|).
\item[fmatch:] Benötigt das Paket \lstinline|fastmatch|. Nutzt \emph{Hashing}, was bei wiederholten Suchvorgängen schneller sein kann als die standardmäßige lineare Suche.
\end{description}

\begin{lstlisting}
x <- c("G", "K", "I")
y <- c("A", "I", "G")
i <- match(x, y)        # 3 NA 2     ; Positionen
y[i]                    # "G" NA "I" ; Inhalte
i <- match(x, y, 0)     # 3 0 2      ; 0 statt NA
y[i]                    # "G" "I"
fastmatch::fmatch(x, y) # 3 NA 2

x <- c(1, 2, 1)
match(1, x)             # 1  ; Erster Treffer
which(x == 1)           # 1 3; Alle Treffer
\begin{lstlisting}


\subsubsection{which(), which.max() und which.min()}

Diese Funktionen transformieren logische Bedingungen oder Extremwertsuche in Index-Vektoren. Sie werden genutzt, um von der \emph{Bedingung} zur exakten \emph{Position} zu gelangen. Ein wesentlicher Vorteil ist, dass \lstinline|NA|-Werte automatisch gefiltert bzw.\ ignoriert werden.

\begin{lstlisting}[language=R]
x <- c(10, 20, NA, 40, 40)
which(x > 15)    # 2 4 5; NA wird ignoriert
which(x > 100)   # integer(0); kein Treffer
which.max(x)     # 4; Position von 40
which.min(x)     # 1; Position von 10
\end{lstlisting}


\subsubsection{max.col(m)}

\lstinline|max.col()| findet die Position des Maximums für jede \textbf{Zeile einer Matrix}.

\begin{description}
\item[Rückgabe:] Ein Vektor mit den Spaltenindizes der Maxima pro Zeile.
\item[Gleichstand (Ties):] Über das Argument \lstinline|ties.method| kann gesteuert werden, welcher Index bei identischen Maxima gewählt wird (\lstinline|"random"| (Standard), \lstinline|"first"| oder \lstinline|"last"|).
\end{description}

\begin{lstlisting}[language=R]
m <- matrix(c(1, 5, 5,
              3, 2, 3), nrow = 2, byrow = TRUE)
max.col(m, "first")  # 2 1
\end{lstlisting}


\subsubsection{Partielle Suche: charmatch und pmatch}

Während die Standardfunktion \lstinline|match| nur exakte Treffer findet, erlauben diese Funktionen Teilübereinstimmungen (\emph{Partial Matching}) am Anfang einer Zeichenkette.

\begin{description}
\item[charmatch(x, table):] Sucht nach exakten oder eindeutigen Teil-Anfängen.
  \begin{itemize}
  \item Liefert den Index bei einem eindeutigen Treffer.
  \item Liefert \lstinline|0|, wenn mehrere partielle Treffer möglich sind (Mehrdeutigkeit).
  \item Liefert \lstinline|NA|, wenn überhaupt kein Treffer gefunden wurde.
  \end{itemize}
\item[pmatch(x, table):] Verhält sich ähnlich, ist aber strenger bei Mehrdeutigkeit (liefert \lstinline|NA| statt \lstinline|0| bei partiellen Treffern) und liefert bei leeren Strings \lstinline|""| immer \lstinline|NA|.
  \begin{itemize}
  \item \lstinline|duplicates.ok = FALSE| (Standard): Ein Element der Tabelle kann nur einmal als Treffer dienen (verbraucht sich).
  \item Interne Verwendung: R nutzt dies primär für die Zuordnung von Funktionsargumenten.
  \end{itemize}
\end{description}

\begin{lstlisting}
s <- c("mean", "median", "mode", "mean")
charmatch("", "")     # 1
charmatch("m", s)     # 0; Mehrdeutig
charmatch("med", s)   # 2
charmatch("mean", s)  # 0; Exakt aber Mehrdeutig
charmatch("x", s)     # NA

pmatch("", "")        # NA
pmatch("m", s)        # NA
pmatch("med", s)      # 2
pmatch("mean", s)     # 1
pmatch("x", s)        # NA

a <- c("", "ab", "ab")
b <- c("abc", "ab")
charmatch(a, b)                    # 0 2 2
pmatch(a, b)                       # NA 2 1
pmatch(a, b, duplicates.ok = TRUE) # NA 2 2
\end{lstlisting}


\subsubsection{Funktionale Suche: Find und Position}

Sie wenden zur Suche eine frei wählbare Test-Funktion (Prädikat) auf jedes Element an und brechen die Suche beim ersten Treffer (\lstinline|TRUE|) ab.

\begin{description}
\item[\lstinline|Find(f, x)|:] Gibt das erste (oder letzte) Element zurück, für das die Funktion \lstinline|f| den Wert \lstinline|TRUE| liefert.
\item[\lstinline|Position(f, x)|:] Gibt den Index dieses Elements zurück.
\item[Wichtige Argumente:] 
  \begin{itemize}
  \item \lstinline|right = TRUE|: Sucht vom Ende des Vektors oder der Liste her.
  \item \lstinline|nomatch|: Bestimmt den Rückgabewert, wenn kein Treffer erzielt wurde (Standard: \lstinline|NULL| für \lstinline|Find|, \lstinline|NA| für \lstinline|Position|).
  \end{itemize}
\end{description}

\begin{lstlisting}
l <- list(a = 7, b = "a", c = "bc", d = "ef")
f <- \(x) is.character(x) && nchar(x) > 1 # char mit >1 Zeichen
Find(f, l)              # "bc"; Das Objekt selbst
Position(f, l)          # 3   ; Der Index des Objekts
Find(f, l, TRUE)        # "ef"; Vom Ende starten
Find(is.integer, l)     # NULL; Kein Treffer
Position(is.integer, l) # NA  ; Kein Treffer
\end{lstlisting}


\subsection{Diskretisierung}

Diese Funktionen teilen kontinuierliche numerische Werte in Intervalle (Bins) ein.

\subsubsection{findInterval(x, vec)}

\lstinline|findInterval(x, vec)| ermittelt mittels binärem Suchalgorithmus, in welches Intervall ein Wert fällt.

\begin{description}
\item[Sortierung:] \lstinline|vec| \emph{muss} aufsteigend sortiert sein.
\item[Rückgabe:] Ein Index \lstinline|i|
\item[Randbereiche:] Werte außerhalb der Grenzen führen nicht zu Fehlern: 
  \begin{itemize}
  \item Werte kleiner als der erste Grenzpunkt geben \lstinline|0| zurück.
  \item Werte größer oder gleich dem letzten Grenzpunkt geben \lstinline|N| (Länge von \lstinline|vec|) zurück.
  \end{itemize}
\end{description}

\begin{lstlisting}[language=R]
x <- c(-1, 0, 1, 15, 19, 20, 21)
vec <- c(0, 10, 20)
findInterval(x, vec)                        # 0 1 1 2 2 3 3
findInterval(x, vec, left.open=TRUE)        # 0 0 1 2 2 2 3
findInterval(x, vec, rightmost.closed=TRUE) # 0 1 1 2 2 2 3

s <- c("A", "B", "C", "D", "E")
s[1 + findInterval(x, vec)]                 # A B B C C D D
\end{lstlisting}

\subsubsection{cut(x, breaks): Kategorisierung als Faktor}

\lstinline|cut(x, breaks)| wandelt stetige Variablen in diskrete Gruppen (Faktoren) um. \lstinline|breaks| ist ein numerischer Vektor von Grenzpunkten. Über das Argument \lstinline|labels| können den Intervallen Namen zugewiesen werden. Intern nutzt \lstinline|cut| ebenfalls einen binären Suchalgorithmus.

\begin{description}
\item[Sortierung:] Falls \lstinline|breaks| unsortiert übergeben wird, sortiert R diese intern automatisch aufsteigend.
\item[Randbereiche:] Werte, die außerhalb der durch \lstinline|breaks| definierten Grenzen liegen, werden als \lstinline|NA| (Not Available) markiert.
\end{description}

Die von \lstinline|cut()| erzeugten Standard-Labels verwenden die mathematische Notation für Intervalle:

\begin{description}
\item[Eckige Klammern:] \lstinline|[a, b]| signalisieren, dass der Randwert eingeschlossen ist (geschlossenes Intervall).
\item[Runde Klammern:] \lstinline|(a, b)| signalisieren, dass der Randwert ausgeschlossen ist (offenes Intervall).
\end{description}

\begin{lstlisting}[language=R]
x <- c(-1, 0, 1, 15, 19, 20, 21)
b <- c(0, 10, 20)
cut(x, b)  # <NA> <NA> (0,10] (10,20] (10,20] (10,20] <NA>
l <- c("A", "Z")
cut(x, b, l)                        # NA NA A Z Z  Z NA
cut(x, b, l, right = FALSE)         # NA  A A Z Z NA NA
cut(x, b, l, include.lowest = TRUE) # NA  A A Z Z  Z NA
\end{lstlisting}


\subsection{Filtern und Teilmengen}

Neben der Indizierung mit \lstinline|[]| bieten \lstinline|subset()| und \lstinline|Filter()| komfortablere Ansätze für spezifische Datenstrukturen.

\subsubsection{subset}

Die Funktion \lstinline|subset()| ist eine komfortable Hilfsfunktion, um Zeilen und Spalten eines Vektors, Data Frames oder einer Matrix basierend auf Bedingungen auszuwählen. Im Gegensatz zur Indexierung mit \lstinline|[]| muss innerhalb von \lstinline|subset()| der Name des Data Frames nicht wiederholt werden, was den Code übersichtlicher macht.

\begin{description}
\item[Vorteile:] ~
  \begin{description}
  \item[Direkter Zugriff:] Spaltennamen können ohne \lstinline|$| genutzt werden.
  \item[Spaltenauswahl:] Über das Argument \lstinline|select| lassen sich Spalten komfortabel ein- oder ausschließen (z.\,B. \lstinline|select = -c(ID, Val)|).
  \item[NA-Handling:] Bedingungen in \lstinline|subset()| behandeln \lstinline|NA|-Werte automatisch als \lstinline|FALSE| und filtern sie somit aus.
  \item[Typerhalt:] Standardmäßig gilt \lstinline|drop = FALSE|, wodurch die Data-Frame-Struktur auch bei der Auswahl einer einzelnen Spalte erhalten bleibt.
  \end{description}
\item[Nachteil:] ~
  \begin{description}
  \item[Namenskollision:] Aufgrund der Gefahr von Namenskollisionen zwischen Spaltennamen und Variablen der Umgebung (Scope-Problematik) sollte \lstinline|subset()| \emph{primär interaktiv} und mit Vorsicht in komplexen Funktionen verwendet werden.
  \end{description}
\end{description}

\begin{lstlisting}
d <- data.frame(ID = 1:4, Val = c(10, NA, 30, 40))
subset(d, Val > 20) #   ID Val;  Entfernt NA-Zeile automatisch
                    # 3  3  30
                    # 4  4  40

subset(d, Val > 20, select = -Val)  #   ID; ohne Val
                                  # 3  3
                                  # 4  4
subset(d, Val>20, select=ID, drop=TRUE) # 3 4
with(d, subset(ID, Val > 20))           # 3 4


d <- data.frame(a = 1:3, b = 3:1)
b <- 1
d[d$a > b,]       #   a b; Nutzt globales b
                  # 2 2 2
                  # 3 3 1
subset(d, a > b)  #   a b; Nutzt Spalte b
                  # 3 3 1
\end{lstlisting}


\subsubsection{Filter}

\lstinline|Filter()| wird primär eingesetzt, um Elemente aus \emph{Listen} oder Vektoren zu extrahieren, für die eine bestimmte Testfunktion (\emph{Prädikat}) den Wert \lstinline|TRUE| liefert. 

Während die logische Indizierung mit \lstinline|[]| bei Vektoren meist ausreicht, bietet \lstinline|Filter()| bei komplexen Listen eine deutlich sauberere Syntax, da sie die Iteration über die Listenelemente abstrahiert.

\begin{description}
\item[Funktionsweise:] \lstinline|Filter(f, x)| wendet die Funktion \lstinline|f| nacheinander auf jedes Element von \lstinline|x| an. Nur Elemente, die den Test bestehen, werden im Ergebnistyp (Liste oder Vektor) zurückgegeben.
\item[Kombination mit Negate:] Besonders mächtig ist die Kombination mit \lstinline|Negate()|, um eine Filterbedingung umzukehren, ohne die ursprüngliche Prädikatsfunktion umschreiben zu müssen.
\item[Typstabilität:] Das Ergebnis behält den Typ des Eingabeobjekts bei. Wird eine Liste gefiltert, ist das Ergebnis wieder eine Liste.
\end{description}

\begin{lstlisting}
x <- list(1:3, 5, "a", 10:12)
# Elemente, die numerisch sind UND deren Summe > 5 ist
Filter(\(i) is.numeric(i) && sum(i) > 5, x)

l <- list(c=1:3, b="x", a=4)
Filter(is.numeric, l)   # Nur numerische Elemente

f <- \(x) x %% 2 == 0
x <- 1:5
Filter(f, x)            # 2 4
Filter(Negate(f), x)    # 1 3 5
\end{lstlisting}


\subsection{Gruppenweise Bearbeitung (Split-Apply-Combine)}

Das \emph{Split-Apply-Combine}-Prinzip beschreibt einen dreistufigen Prozess: Daten werden nach Kriterien aufgeteilt (\emph{Split}), bearbeitet (\emph{Apply}) und die Ergebnisse wieder zusammengeführt (\emph{Combine}). In R gibt es zwei Herangehensweisen, um diesen Prozess umzusetzen:

\begin{description}
    \item[Modulare Bearbeitung:] Man nutzt explizite Einzelfunktionen für jeden Schritt (z.\,B. \lstinline|split()| für den Split, \lstinline|lapply()| für den Apply-Teil und \lstinline|do.call()| für das Combine). Dies bietet maximale Flexibilität bei komplexen Transformationen.
    \item[Integrierte Funktionen:] Funktionen wie \lstinline|tapply()|, \lstinline|aggregate()| oder \lstinline|ave()| führen alle drei Schritte intern in einem einzigen Aufruf aus. Dies ist effizienter und weniger fehleranfällig für Standardaufgaben wie Gruppen-Mittelwerte oder Summen.
\end{description}

Während man manuell mittels Indizierung (z.\,B. \lstinline|x[g == "A"]|) jede Gruppe einzeln filtern müsste, automatisieren die folgenden Funktionen diesen Prozess für alle Gruppen gleichzeitig.


\subsubsection{Split: Die Zerlegung von Datenstrukturen}

Der erste Schritt des modularen Workflows besteht darin, einen Datensatz anhand von Merkmalen physisch in eine Liste zu trennen. Während die manuelle Indizierung bei vielen Gruppen unübersichtlich wird, automatisieren die Funktionen \lstinline|split()| und \lstinline|asplit()| diesen Vorgang. Sie bilden das Fundament, um komplexe Datenstrukturen für die nachfolgende \emph{Apply}-Phase vorzubereiten.

\paragraph{split(x, f)}

Die Funktion \lstinline|split()| zerlegt einen Vektor oder Data Frame basierend auf einem Faktor \lstinline|f| in eine Liste von Teilmengen. Ist \lstinline|f| kein Faktor, wird er intern mit \lstinline|as.factor()| umgewandelt.

Die Länge von \lstinline|f| sollte der Länge von \lstinline|x| entsprechen. Ist \lstinline|f| kürzer, wird es gemäß der \emph{Recycling-Regel} wiederholt. Geht die Länge von \lstinline|x| nicht glatt durch die Länge von \lstinline|f|, erscheint eine Warnung.

\begin{lstlisting}
x <- c(10, 20, 100, 200)
g <- factor(c("A", "A", "B", "B"))
split(x, g)       # [[A]] 10 20  [[B]] 100 200

levels(g) <- c(levels(g), "C")  # leerer Faktor-Level => drop
split(x, g)       # [[A]] 10 20  [[B]] 100 200  [[C]] numeric(0)
split(x, g, TRUE) # [[A]] 10 20  [[B]] 100 200

d <- data.frame(x=1:3, y=4:6)
split(d, c(1,2,1))  # $`1`  x y
                    #     1 1 4
                    #     3 3 6
                    # $`2`  x y
                    #     2 2 5

split(1:4, 1:2)     # [[1]] 1 3  [[2]] 2 4; Recycling
split(1:4, 1:3)     # [[1]] 1 4  [[2]] 2  [[3]] 3; Warnung
\end{lstlisting}


\paragraph{asplit(x, MARGIN)}

\lstinline|asplit()| zerlegt Matrizen oder Arrays entlang ihrer Dimensionen. Das Argument \lstinline|MARGIN| gibt an, entlang welcher Dimension(en) das Objekt „zerschnitten“ wird (1 für Zeilen, 2 für Spalten, 3 für Schichten, c(1,3) für Zeilen und Schichten, \dots). Das Ergebnis ist eine Liste, deren Elemente die verbleibenden Dimensionen des ursprünglichen Objekts beibehalten.

\begin{lstlisting}
m <- matrix(1:4, 2) # 1 3
                    # 2 4
asplit(m, 2)        # [[1]] 1 2  [[2]] 3 4
split(m, col(m))    # [[1]] 1 2  [[2]] 3 4
asplit(m, 1)        # [[1]] 1 3  [[2]] 2 4
split(m, row(m))    # [[1]] 1 3  [[2]] 2 4

a <- array(1:8, dim = c(2, 2, 2))
asplit(a, 3)   # Liste mit zwei (2x2) Matrizen
asplit(a, c(1,3)) # Liste mit 4 Vektoren der Länge 2
\end{lstlisting}


\subsubsection{Integrierte Split-Apply-Combine Funktionen}

Während die modulare Arbeitsweise maximale Kontrolle bietet, kombinieren integrierte Funktionen die Schritte Zerlegung, Berechnung und Zusammenführung in einem effizienten Einzeiler. Je nach gewünschtem Rückgabeformat (Matrix, Data Frame oder Vektor gleicher Länge) stellt R spezialisierte Werkzeuge zur Verfügung, die den Code kompakter und weniger fehleranfällig machen.

\paragraph{table()}

Die Funktion \lstinline|table()| berechnet Häufigkeitstabellen (Kontingenztafeln). Sie zählt, wie oft jede Merkmalskombination in den übergebenen Faktoren vorkommt. Das Ergebnis ist ein Objekt der Klasse \lstinline|table|, das intern als Array gespeichert wird.

\begin{lstlisting}
g <- c("A", "A", "A", "B")
table(g)                   # A: 3, B: 1
h <- c("C", "D", "D", "D")
table(g, h)                #   C D
                           # A 1 2
                           # B 0 1
z <- c("A", "A", NA, "B")
table(z)                   # A: 2, B: 1; NA wird ignoriert
table(z, useNA = "ifany")  # A: 2, B: 1, <NA>: 1
\end{lstlisting}


\paragraph{xtabs(formula, data)}

\lstinline|xtabs()| (Cross Tabs) ist eine Schnittstelle zu \lstinline|table()|, die mit Formeln arbeitet. Mit der Formel-Syntax \lstinline|~ A + B| werden Kreuztabellen erstellt. Steht links vom Tilde-Symbol eine Variable (\lstinline|y ~ A + B|), werden deren Werte je Gruppe summiert.

\begin{lstlisting}
d <- data.frame(x = c(.5, 1, 2, 4),
  g = c("A", "A", "A", "B"), h = c("C", "D", "D", "D"))
xtabs(~ g, data = d)      # A: 3, B: 1
xtabs(x ~ g, d)           # A: 3.5, B: 1
x <- xtabs(x ~ g + h, d)  #     C   D
                          # A 0.5 3.0
                          # B 0.0 4.0
as.data.frame(x)          # g h Freq; Als data.frame
                          # A C  0.5
                          # B C  0.0
                          # A D  3.0
                          # B D  4.0
\end{lstlisting}


\paragraph{tapply(X, INDEX, FUN)}

\lstinline|tapply()| (abgeleitet von \emph{Table Apply}) wendet eine Funktion auf Teilmengen eines Vektors an. Sie stellt die verallgemeinerte Form von \lstinline|table()| dar, welche lediglich die Häufigkeiten je Gruppe bestimmt. Sie ist das Standardwerkzeug für Gruppenstatistiken (z.\,B.\ Mittelwerte pro Kategorie). Ein Vektor wird anhand von Kategorien unterteilt, auf jede Gruppe wird eine Funktion angewendet und die Einzelergebnisse werden in einer Struktur zusammengefasst.

\begin{itemize}
\item \lstinline|X|: Ein atomares Objekt (meist ein Vektor), das die auszuwertenden Daten enthält.
\item \lstinline|INDEX|: Ein Faktor oder eine Liste von Faktoren (gleicher Länge wie \lstinline|X|), die die Gruppierung definieren.
\item \lstinline|FUN|: Die anzuwendende Funktion (z.\,B.\ \lstinline|mean|). Bleibt \lstinline|FUN| leer (\lstinline|NULL|), gibt die Funktion einen Index-Vektor zurück, der zeigt, welche Elemente zusammengehören.
\item \lstinline|...|: Optionale Argumente für \lstinline|FUN| (z.\,B.\ \lstinline|na.rm = TRUE|).
\item \lstinline|default|: Der Wert, der für leere Zellen (Kombinationen von Faktoren, die in den Daten nicht vorkommen) eingesetzt wird.
\item \lstinline|simplify|: Ein logischer Wert. Bei \lstinline|TRUE| (Standard) wird versucht, das Ergebnis in ein Array oder einen Vektor zu vereinfachen. Bei \lstinline|FALSE| wird eine Liste zurückgegeben.
\end{itemize}

Bei \lstinline|simplify = TRUE| hängt das Ergebnis von der Rückgabe der Funktion \lstinline|FUN| ab:
\begin{enumerate}
\item Liefert \lstinline|FUN| immer einen einzelnen Wert (Skalar), ist das Ergebnis ein \textbf{Vektor} oder ein \textbf{Array} (bei mehreren Indizes eine Matrix), wobei die Dimensionen den Leveln der Faktoren entsprechen.
\item Liefert \lstinline|FUN| komplexe Objekte (z.\,B.\ Vektoren unterschiedlicher Länge), wird das Ergebnis wie bei einer Liste behandelt.
\end{enumerate}

\begin{lstlisting}
x <- 1:5
g <- factor(rep_len(1:2, 5), levels = 1:3)
tapply(x, g, sum)               # 1 2 3; Summe pro Gruppe
                                # 9 6 NA
tapply(x, g, sum, default = 0)  # 1 2 3
                                # 9 6 0
sapply(split(x, g), sum)        # 1 2 3; Variante
                                # 9 6 0
tapply(x, g, sum, simplify = FALSE)    # Gibt eine Liste
tapply(x, g)         # 1 2 1 2 1; split vector

g <- list(c("A", "A", "A", "B"), c("C", "D", "D", "D"))
tapply(1:4, g)       # 1 3 3 4; split vector
tapply(1:4, g, sum)  #    C D  # 2 Gruppen => Ergebnis Matrix
                     # A  1 5
                     # B NA 4
tapply(1:4, g, c)    #   C    D     ; Ergebnis verschieden Lang
                     # A 1    integer,2 ; => Array vom Typ list
                     # B NULL 4        

tapply(c(1,NA), c(1,1), sum)               # NA
tapply(c(1,NA), c(1,1), sum, na.rm = TRUE) # 1
\end{lstlisting}


\paragraph{aggregate()}

\lstinline|aggregate()| wendet frei wählbare Funktionen auf Untergruppen eines Data Frames an. Das Ergebnis ist ein \emph{Data Frame}. Kombinationen ohne Beobachtungen (leere Gruppen) werden standardmäßig aus dem Ergebnis-Data-Frame entfernt (entspricht \lstinline|drop = TRUE|).

Schnittstellen:
\begin{description}
\item[Formel-Interface:] \lstinline|aggregate(y ~ x1 + x2, data, FUN)| \\
  Links steht die zu berechnende Variable, rechts die Gruppierungsvariablen.
\item[Klassische Schnittstelle:] \lstinline|aggregate(x, by, FUN)| \\
  Hier ist \lstinline|x| der Datenvektor und \lstinline|by| eine Liste von Gruppierungsfaktoren.
\end{description}

Wichtige Argumente:
\begin{itemize}
\item \lstinline|formula|: Formel wie \lstinline|Wert ~ Kat1 + Kat2|.
\item \lstinline|data|: Der Data Frame, auf den sich die Formel bezieht.
\item \lstinline|x| Ein Vektor oder Data Frame, der Gruppiert werden soll
\item \lstinline|by|: Gruppierung als \lstinline|list(Name = Faktor)|. Die Benennung in der Liste bestimmt den Spaltennamen im Ergebnis.
\item \lstinline|FUN|: Aggregationsfunktion (z.\,B.\ \lstinline|mean|). Gibt diese mehr als einen Wert zurück, entstehen Matrix-Spalten im Data Frame.
\end{itemize}

\begin{lstlisting}
d <- data.frame(x = c(.5, 1, 2, 4), y = c(5, 3, 2, 0),
  g = c("A", "A", "A", "B"), h = c("C", "D", "D", "D"))

aggregate(x ~ g, d, sum)  #   g   x; Über Formel
                          # 1 A 3.5
                          # 2 B 4.0

aggregate(d$x, d["g"], sum)  #   g   x; Über by
                             # 1 A 3.5
                             # 2 B 4.0

aggregate(x ~ g, d, c)  #   g             x; x List-Vektor
                        # 1 A 0.5, 1.0, 2.0
                        # 2 B             4

aggregate(x ~ g + h, d, sum)  #   g h   x; Mehrere Gruppen
                              # 1 A C 0.5
                              # 2 A D 3.0
                              # 3 B D 4.0

aggregate(x ~ g + h, d, sum, drop=FALSE) #   g h   x
                                         # 1 A C 0.5
                                         # 2 B C  NA
                                         # 3 A D 3.0
                                         # 4 B D 4.0

aggregate(cbind(x, y) ~ g, d, sum) #   g   x  y
 # Mehrere Variablen gleichzeitig  # 1 A 3.5 10
                                   # 2 B 4.0  0

x<-aggregate(x~g,d,\(x)c(s=sum(x),m=mean(x))) # g x.s  x.m
 # Mehrere Statistiken gleichzeitig           # A 3.5 1.17
 #  Ergebnis: eine Matrix-Spalte              # B 4.0 4.00
do.call(data.frame, x) # Matrix-Spalte => data.frame Spalten
\end{lstlisting}


\paragraph{ave(x, ..., FUN = mean)}

\lstinline|ave()|  (abgeleitet von \emph{Averages}) wendet Funktionen für Gruppen an, gibt das Ergebnis aber in der \emph{gleichen Länge} des Eingabevektors \lstinline|x| zurück und kann z.\,B.\ direkt als neue Spalte eines \lstinline|data.frame| hinzugefügt werden.

\begin{itemize}
\item \lstinline|x| Der Datenvektor, auf den die Funktion angewendet wird.
\item \lstinline|...| Ein oder mehrere Gruppierungsvariablen (meist Faktoren), die die gleiche Länge wie \lstinline|x| haben müssen.
\item \lstinline|FUN| Die Funktion, die auf die Gruppen angewendet wird (Standard: \lstinline|mean|).
\end{itemize}

\begin{lstlisting}
x <- c(4, 2, 0, 6)
g <- c("A", "A", "A", "B")

ave(x)                # 3 3 3 3; Mittel über alle
ave(x, g)             # 2 2 2 6; Mittelwert je Gruppe
ave(x, g, FUN=order)  # 3 2 1 1; Reihenfolge je Gruppe

h <- c("C", "D", "D", "D")
ave(x, g, h)          # 4 1 1 6; Zwei Gruppen

y <- c(4, 2, NA, 6)
ave(y, g)                                   # NA NA NA 6
ave(y, g, FUN = \(x) mean(x, na.rm = TRUE)) # 3 3 3 6
\end{lstlisting}


\paragraph{by(data, INDICES, FUN, ...)}

\lstinline|by()| zerlegt Daten in Teil-Einheiten und wendet auf diese eine Funktion an. Sie eignet sich insbesondere für Funktionen, die mehrere Spalten gleichzeitig benötigen (z.\,B.\ statistische Modelle).

Das Ergebnis ist ein Objekt der Klasse \lstinline|by|, eine Liste, die für jede Gruppe das Ergebnis des Funktionsaufrufs enthält.

\begin{itemize}
\item \lstinline|data|: Ein Data Frame, eine Matrix oder ein Vektor.
\item \lstinline|INDICES|: Ein Faktor, eine Liste von Faktoren oder (bei Data Frames) eine Formula zur Gruppierung.
\item \lstinline|FUN|: Die Funktion, die auf die Teil-Daten angewendet wird.
\item \lstinline|...|: Weitere Argumente, die an \lstinline|FUN| durchgereicht werden.
\end{itemize}

\begin{lstlisting}
d <- data.frame(x = c(.5, 1, 2, 4), y = c(5, 3, 2, 0),
  g = c("A", "A", "A", "B"), h = c("C", "D", "D", "D"))

by(d$x, d$g, FUN = sum)  # A: 3.5  B: 4
by(d, ~ g, FUN = identity)  # Liste mit zwei Data Frames
by(d, ~ g + h, FUN = identity)  # 4 Data Frames
by(d$x, d[c("g", "h")], FUN = sum)  # AC:.5 BC:NA AD:3 BD:4
by(d[c("x", "y")], d$g, FUN = colSums)  # A: x:3.5 y:10
                                        # B: x:4   y:0

by(d, ~ g, FUN = \(d) lm(x ~ y, d))   # Regression je Gruppe
by(d, ~ g, FUN = lm, formula = x ~ y) # Variante
\end{lstlisting}


\subsubsection{Combine: Die manuelle Zusammenführung}

Nachdem Daten mit Funktionen wie \lstinline|split()| oder \lstinline|by()| in Gruppen zerlegt und bearbeitet wurden, liegen die Ergebnisse häufig als Listen vor. In der \emph{Split-Apply-Combine}-Strategie stellt Combine den finalen Schritt dar: Die Rückführung dieser Einzelresultate in eine geschlossene Datenstruktur.

Während automatisierte Funktionen diesen Schritt intern erledigen, erfordern komplexere Workflows oft eine manuelle Zusammenführung. Die Wahl der Funktion hängt dabei entscheidend davon ab, ob die ursprüngliche Struktur (die Reihenfolge der Zeilen) wiederhergestellt werden soll oder ob die Ergebnisse zu einer neuen Matrix oder einem Vektor vereint werden sollen.


\paragraph{unsplit(value, f)}

\lstinline|unsplit()| ist das direkte Gegenstück zu \lstinline|split()|. Sie macht die Zerlegung rückgängig und setzt die Elemente einer Liste wieder in der \emph{ursprünglichen} Reihenfolge zusammen, die durch den Faktor \lstinline|f| definiert wurde.

Falls die Listenelemente kürzer sind als die ursprünglichen Gruppen (z.,B. bei aggregierten Werten), werden diese automatisch auf die volle Gruppengröße \emph{recycelt}.

\begin{itemize}
\item \textbf{value:} Eine Liste von Vektoren oder Data Frames.
\item \textbf{f:} Der Faktor oder die Liste von Faktoren, die für die ursprüngliche Zerlegung genutzt wurde.
\end{itemize} 

Während \lstinline|unsplit()| ein neues Objekt aus einer Liste erzeugt, ermöglicht die Zuweisungsform \lstinline|split(x, f) <- value| die gezielte Modifikation einzelner Gruppen innerhalb eines bestehenden Objekts, wobei die ursprüngliche Datenstruktur (z.\,B.\ Datentypen oder Attribute) sicher erhalten bleibt.

\begin{lstlisting}
x <- c(10, 20, 100, 30)
g <- factor(c("A", "A", "B", "A"))

s <- split(x, g)    # Zerlegung in Liste
unsplit(s, g)       # 10 20 100 30
y <- lapply(s, `+`, 1)
unsplit(y, g)       # 11 21 101 31

z <- x
split(z, g) <- y
z                   # 11 21 101 31
split(z, g)$A <- 30
z                   # 30 30 101 30

y <- lapply(s, mean)
unsplit(y, g)       # 20 20 100 20
\end{lstlisting}


\paragraph{rbind, cbind, do.call}

Die Funktion \lstinline|do.call(what, args)| ermöglicht es, eine Funktion \lstinline|what| aufzurufen und ihr die Argumente gesammelt als Liste \lstinline|args| zu übergeben.

Häufige Anwendungsfälle beim Zusammenfügen von Listen-Ergebnissen:

\begin{description}
    \item[untereinander:] \lstinline|rbind|
    \item[nebeneinander:] \lstinline|cbind| oder \lstinline|data.frame|
\end{description}

Beim Zusammenfügen von Dataframes ist zu beachten, dass \lstinline|rbind| die Spalten über ihre \emph{Namen} verknüpft, nicht über ihre Position.

\begin{lstlisting}
l <- list(data.frame(a=1), data.frame(a=2))

do.call(rbind, l)       #   a; Untereinander
                        # 1 1
                        # 2 2

do.call(cbind, l)       #   a a; Nebeneinander
                        # 1 1 2

do.call(data.frame, l)  #   a a.1; Nebeneinander
                        # 1 1   2

l <- list(data.frame(a=1,b=2), data.frame(b=3, a=4))
do.call(rbind, l)       #   a b; Verknüpfung über Namen
                        # 1 1 2
                        # 2 4 3

l <- list(data.frame(a=1), data.frame(b=2))
#do.call(rbind, l)      ## Error: Namen passen nicht
l2<-lapply(l,setNames,nm=names(l[[1]])) # Namen vereinheitlichen
do.call(rbind, l2)      #   a
                        # 1 1
                        # 2 2

l <- list(matrix(1, dimnames=list(1, "A")), 
          matrix(2, dimnames=list(1, "B")))
do.call(rbind, l)       #   A; Name egal bei Matrix
                        # 1 1
                        # 1 2
\end{lstlisting}


\paragraph{simplify2array(x)}

\lstinline|simplify2array()| versucht eine Liste \lstinline|x| in eine simplere Struktur (Vektor, Matrix oder Array) umzuwandeln, sofern die Dimensionen der Listenelemente dies zulassen.

\begin{description}
\item[Vektor:] Alle Elemente sind Skalare (Einzelelemente).
\item[Matrix:] Alle Elemente sind Vektoren gleicher Länge. Die Vektoren werden dabei als \emph{Spalten} nebeneinander angeordnet.
\item[Array:] Alle Elemente sind Matrizen oder Arrays gleicher Dimension. Die Elemente werden entlang einer neuen, zusätzlichen Dimension gestapelt.
\end{description}

Standardmäßig versucht die Funktion, so viele Dimensionen wie möglich zu erhalten. Bei \lstinline|higher = FALSE| hört die Funktion bei Matrizen auf und führt diese in eine zweidimensionale Matrix (Spalte für Spalte) über.

\begin{lstlisting}
l <- list(1, 2, 3)
simplify2array(l)         # 1 2 3; Vektor

l <- list(1, c(2, 0), 3)  # Unterschiedliche Längen
simplify2array(l)         # Bleibt Liste

l <- list(1:2, 3:4)
simplify2array(l)         # 1 3; Matrix
                          # 2 4

l <- list(matrix(1:4, 2), matrix(5:8, 2))
simplify2array(l)               # 3D-Array
simplify2array(l, higher=FALSE) # Matrix

l <- list(array(1:8, c(2,2,2)), array(8:1, c(2,2,2)))
simplify2array(l)               # 4D-Array
simplify2array(l, higher=FALSE) # Matrix
\end{lstlisting}


\paragraph{unlist(x)}

Die Funktion \lstinline|unlist()| wandelt eine Liste (auch verschachtelte Listen) in einen einfachen (atomaren) Vektor um. Dabei arbeitet die Funktion standardmäßig rekursiv und bricht alle Ebenen auf. 

Eigenschaften:
\begin{description}
\item[Strukturverlust:] \lstinline|NULL|-Elemente werden entfernt, und die hierarchische Struktur geht verloren.
\item[Typ-Konvertierung:] Es wird zum allgemeinsten Datentyp konvertiert (z.\,B.\ werden Zahlen zu Text, wenn die Liste ein Zeichen enthält).
\end{description}

Die Option \lstinline|use.names = FALSE| unterbindet die Ausgabe von Namen und ist performanter.

\begin{lstlisting}
l <- list(a = list(1:2), b = NULL, c = c("x", "y"))
unlist(l)         # "1" "2" "x" "y"; kein NULL, alles Char
unlist(l, FALSE)  # [1 2], x, y; Nur oberste Ebene aufgelöst
unlist(l, use.names = FALSE)  # Ohne Namen
\end{lstlisting}


\subsubsection{Daten in Data Frames verwandeln}

R bietet einige Möglichkeiten verschiedenen Datenstrukturen in ein \lstinline|data.frame| umzuwandeln.


\paragraph{as.data.frame(x)}

Die Funktion \lstinline|as.data.frame()| ist eine generische Funktion, die verschiedenste Datenstrukturen in ein Data Frame umwandelt.

\begin{description}
\item[Vektoren und Listen:] Ein Vektor wird zu einer einspaltigen Tabelle. Bei Listen wird jedes Element zu einer eigenen Spalte (vorausgesetzt, alle Elemente haben die gleiche Länge).
\item[Matrizen und Arrays:] Die rechteckige Struktur bleibt erhalten. Spaltennamen werden übernommen oder automatisch generiert.
\item[Tabellen:] (\lstinline|table|) Hier erfolgt eine Konvertierung in das \emph{Long-Format}. Jede Dimension der Tabelle wird zu einer eigenen Faktor-Spalte, während die Werte in der Spalte \lstinline|Freq| stehen.
\end{description}

Enthält ein Data Frame eine Spalte, die selbst eine Matrix ist, wird diese durch \lstinline|as.data.frame()| nicht automatisch aufgeteilt. In solchen Fällen kann der Befehl \lstinline|do.call(data.frame, d)| genutzt werden, um die eingebettete Matrix in separate Spalten zu expandieren. Dies funktioniert jedoch nur, wenn die Spalte nicht explizit mit der Funktion \lstinline|I()| (\emph{Inhibit Interpretation/Conversion}) als geschützt markiert wurde.

Ein entscheidender Unterschied besteht zudem darin, ob eine Matrix als rechteckige Struktur erhalten bleiben soll oder in ein flaches Format umgewandelt wird. Während \lstinline|as.data.frame()| die Zeilen- und Spaltenstruktur beibehält, erzwingt \lstinline|as.data.frame.table()| die Auflösung der Dimensionen in einzelne Spalten (Indizes).

\begin{lstlisting}
x <- c(3, 1, 2)    # Vektor
as.data.frame(x)   #   x; einspaltige Tabelle
                   # 1 3
                   # 2 1
                   # 3 2

l <- list(x = 1:2, s = c("A", "B")) # List
as.data.frame(l)  #   x s; Element => Spalte
                  # 1 1 A
                  # 2 2 B
l <- list(x = 1, s = c("A", "B"))
as.data.frame(l)  #   x s; Auto Recycling
                  # 1 1 A
                  # 2 1 B

m <- matrix(1:4, 2, dimnames = list(x=8:7, y=c("A", "B")))
as.data.frame(m)  #   A B
                  # 8 1 3
                  # 7 2 4
as.data.frame.table(m) #   x y Freq
                       # 1 8 A    1
                       # 2 7 A    2
                       # 3 8 B    3
                       # 4 7 B    4

obs <- c("A", "B", "A")
x <- table(obs)
as.data.frame(x)  #   obs Freq
                  # 1   A    2
                  # 2   B    1

a <- array(1:8, dim = c(2, 2, 2),
dimnames = list(X=c("A","B"), Y=c("C","D"), Z=c("E","F")))
as.data.frame(a)  #   C.E D.E C.F D.F
                  # A   1   3   5   7
                  # B   2   4   6   8

d <- data.frame(id = 1:2)
d$x <- matrix(1:4, 2)
str(d)                      # $ x: 'AsIs' int [1:2, 1:2] 1 2 3 4
str(do.call(data.frame, d)) # $ x.1: int  1 2
 # eigene Spalten           # $ x.2: int  3 4
d$x <- I(matrix(1:4, 2))    # I() verhindert die Expansion
str(do.call(data.frame, d)) # $ x: 'AsIs' int [1:2, 1:2] 1 2 3 4
\end{lstlisting}


\paragraph{list2DF(x)}

\lstinline|list2DF()| ist eine spezialisierte und performante Alternative zu \lstinline|as.data.frame()|. Sie ist darauf optimiert, eine Liste direkt in ein Data Frame zu konvertieren.

\begin{description}
\item[Effizienz:] Da keine Spaltennamen auf Gültigkeit geprüft oder Typen automatisch konvertiert werden, ist sie schnell.
\item[Striktheit:] Alle Listenelemente müssen bereits die exakt gleiche Länge haben. Ein automatisches Auffüllen (Recycling) kürzerer Elemente findet nicht statt.
\item[Flexibilität:] Über das Argument \lstinline|nrow| können Data Frames mit null Spalten, aber einer definierten Zeilenanzahl erstellt werden.
\end{description}

\begin{lstlisting}
l <- list(x = 1:2, s = c("A", "B"))
list2DF(l)  #   x s
            # 1 1 A
            # 2 2 B
l <- list(x = 1, s = c("A", "B"))
#list2DF(l) ## Error: ungleich lang

l <- list(x = list(1, 2:3), s = c("A", "B"))
list2DF(l)       #      x s; Spalte x ist Liste
                 # 1    1 A
                 # 2 2, 3 B
as.data.frame(l) #   x.1 x.2.3 s; Aufteilung in Spalten
                 # 1   1     2 A
                 # 2   1     3 B

list2DF(nrow = 2) # 0 Spalten 2 Zeilen
\end{lstlisting}


\paragraph{array2DF(x)}

\lstinline|array2DF()| wandelt Arrays in Data Frames um, wobei die Dimensionsnamen zu Spalten werden. Es ist eine flexiblere Alternative zu \lstinline|as.data.frame.table()|.

Argumente:
\begin{itemize}
\item \lstinline|responseName|: Benennt die Wertespalte (Standard: \lstinline|"Value"|).
\item \lstinline|simplify|: Relevant für List-Arrays. Versucht, die Inhalte der Listen-Elemente zu vereinfachen (z.\,B.\ Vektoren zu atomaren Spalten zu reduzieren). Bei atomaren Arrays hat es keine Auswirkung.
\item \lstinline|allowLong|: Erlaubt, dass das Ergebnis mehr Zeilen hat als das ursprüngliche Array (Unnesting von Listen-Elementen).
\end{itemize}

Während \lstinline|as.data.frame.table()| die Dimensionsspalten in \lstinline|Faktoren| umwandelt, behält \lstinline|array2DF()| den ursprünglichen Typ der \lstinline|dimnames| (\lstinline|character|) bei.

\begin{lstlisting}
m <- matrix(1:4, 2, dimnames = list(x=8:7, y=c("A", "B")))
m                      #     y
                       # x   A B
                       #   8 1 3
                       #   7 2 4

array2DF(m, "Gewicht") #   x y Gewicht
                       # 1 8 A       1
                       # 2 7 A       2
                       # 3 8 B       3
                       # 4 7 B       4

as.data.frame.table(m) #   x y Freq
                       # 1 8 A    1
                       # 2 7 A    2
                       # 3 8 B    3
                       # 4 7 B    4

a <- array(list(1, 2:3), dim = c(2, 1),
   dimnames = list(g = c("G", "H"), l = "L"))

array2DF(a)            #     g l Value; Vektorspalte
                       # 1   G L     1
                       # 2   H L     2
                       # 2.1 H L     3

array2DF(a, allowLong = FALSE) #   g l Value; Listenspalte
                               # 1 G L     1
                               # 2 H L  2, 3

a <- array(list(1, 2), dim = c(2, 1),
   dimnames = list(g = c("G", "H"), l = "L"))

str(array2DF(a,))                   # Value: num  1 2
str(array2DF(a, simplify = FALSE))  # Value:List of 2
\end{lstlisting}


\paragraph{stack(x) und unstack(x)}

\lstinline|stack()| fasst mehrere Vektoren (aus einer Liste oder einem Data Frame) zu einem einzigen Vektor zusammen (stapelt sie hintereinander) und erzeugt einen zusätzlichen Faktor-Vektor (\lstinline|ind|), der angibt, von welchem ursprünglichen Vektor der Wert stammt. \lstinline|unstack()| kehrt diesen Vorgang um.

Methoden:
\begin{itemize}
\item \lstinline|stack(x, select)|: Erwartet eine Liste oder einen Data Frame \lstinline|x|. Mit \lstinline|select| (optional) können Spalten ausgewählt oder ausgeschlossen werden.
\item \lstinline|unstack(x, form)|: Erwartet einen Data Frame im Long-Format \lstinline|x|. Das optionale Argument \lstinline|form| verwendet eine Formel der Art \lstinline|Werte ~ Gruppen|, um die Entstapelung zu steuern.
\end{itemize}

\begin{lstlisting}
l <- list(A = 1, B = 2:3)
s <- stack(l) #   values ind
              # 1      1   A
              # 2      2   B
              # 3      3   B
unstack(s)   # [[A]] 1  [[B]] 2 3; Liste

d <- data.frame(A = 1:2, B= 3:4)
s <- stack(d) #   values ind
              # 1      1   A
              # 2      2   A
              # 3      3   B
              # 4      4   B
unstack(s)    #   A B; Data.frame
              # 1 1 3
              # 2 2 4
stack(d, -A)  #   values ind; ohne Spalte A
              # 1      3   B
              # 2      4   B

d <- data.frame(x=1:4, a=c(0,0,1,1))
unstack(d, x ~ a) #   X0 X1
                  # 1  1  3
                  # 2  2  4

d <- data.frame(x=1:8, a=rep(0:1, each=4), b=0:1)
unstack(d, x ~ interaction(a, b)) #   X0.0 X1.0 X0.1 X1.1
  # Mehrere Spalten               # 1    1    5    2    6
                                  # 2    3    7    4    8
\end{lstlisting}


\subsection{Schleifen}

Schleifen ermöglichen es, denselben Codeblock mehrfach auszuführen, ohne ihn manuell duplizieren zu müssen. Dabei wird in der Regel bei jedem Durchlauf eine Variable (die sogenannte Laufvariable, oft ein Index oder ein Element eines Objekts) verändert, sodass die Anweisungen innerhalb der Schleife mit jeweils unterschiedlichen Werten arbeiten. Je nach Schleifentyp erfolgt die Wiederholung basierend auf einer logischen Bedingung oder für eine festgelegte Anzahl von Durchläufen.

Innerhalb jeder Schleife (\lstinline|for|, \lstinline|while|, \lstinline|repeat|) können zwei spezielle Befehle den Kontrollfluss steuern:

\begin{itemize}
\item \lstinline|next|: Bricht den aktuellen Durchlauf ab und springt sofort zur nächsten Iteration. Dies ist nützlich, um bestimmte Werte zu überspringen.
\item \lstinline|break|: Beendet die gesamte Schleife sofort. Dies wird oft genutzt, um eine Suche abzubrechen, sobald das gewünschte Ergebnis gefunden wurde.
\end{itemize}

\lstinline|break| beendet immer nur die aktuell innerste Schleife. Um mehrere verschachtelte Ebenen gleichzeitig zu verlassen, sollte eine logische Hilfsvariable oder ein \lstinline|return()| innerhalb einer Funktion genutzt werden.

Obwohl Schleifen ein grundlegendes Konzept der Programmierung darstellen, sollten sie in R mit Bedacht eingesetzt werden. Da R eine interpretierte Sprache ist, sind klassische Schleifen oft langsamer als \emph{vektorisierte Operationen} oder die \lstinline|apply|-Funktionsfamilie.


\subsubsection{for-Schleife}

Die \lstinline|for|-Schleife ist die gebräuchlichste Schleife. Sie iteriert über die Elemente eines Vektors, einer Liste oder einer Sequenz und führt den Codeblock für jedes Element einmal aus.

\paragraph{Syntax und Steuerung}

Die grundlegende Syntax lautet \lstinline|for (VARIABLE in SEQUENZ) CODE|. Der \lstinline|CODE| wird meist als Codeblock in geschweiften Klammern \lstinline|{}| geschrieben, was die Ausführung mehrerer Befehle ermöglicht.

Die Laufvariable (\lstinline|i| im Beispiel) existiert nach der Schleife mit dem Wert des letzten Durchlaufs weiter. Sie kann innerhalb des Codeblocks zwar verändert werden, dies beeinflusst jedoch nicht die vordefinierte Abfolge der Schleifendurchläufe, da R die Variable zu Beginn jedes Durchlaufs auf den nächsten Wert der Sequenz setzt.

\begin{lstlisting}
for (i in 1:5) cat(i)  # 12345
i                      # 5; i ist nicht lokal begrenzt
for (i in 1:5) {cat(i); i<-i*2} # 12345
i                               # 10
for (i in 1:5) {if (i==3) next; cat(i)} # 1245; Überspringen
for (i in 1:5) {if (i>2) break; cat(i)} # 12; Abbruch
\end{lstlisting}


\paragraph{Direkte vs. Index-Iteration}

In R kann man entweder direkt über die Elemente eines Objekts iterieren oder über deren Indizes. Die direkte Iteration ist oft lesbarer und performanter.

\begin{lstlisting}
x <- c(3,5,1)
for (y in x) cat(y)               # 351; Über Element
for (i in seq_along(x)) cat(x[i]) # 351; Über Index
cat(x, sep="")                    # 351; Ohne Schleife
\end{lstlisting}


\paragraph{Performance}

Zeitintensiv sind insbesondere folgende Vorgänge:

\begin{itemize}
\item Das Extrahieren von Subdaten über einen Index innerhalb der Schleife.
\item Das schrittweise Vergrößern von Objekten (z.\,B.\ mit \lstinline|c()| oder \lstinline|rbind()|), da bei jeder Iteration der Speicher neu zugewiesen und das gesamte Objekt kopiert werden muss.
\end{itemize}

Lösungsmöglichkeiten für eine bessere Performance:

\begin{itemize}
\item Bevorzugt direkt über die Elemente iterieren.
\item Den Speicherplatz für das Endergebnis vor der Schleife in der benötigten Größe reservieren (\emph{Präallokation}).
\item Nach Möglichkeit vollständig auf vektorisierte Funktionen zurückgreifen.
\end{itemize}

\begin{lstlisting}
x <- 1:1e6
system.time(for (y in x) cat(y))               # ca. 2.7 Sek.
system.time(for (i in seq_along(x)) cat(x[i])) # ca. 3.0 Sek.
system.time(cat(x, sep=""))                    # ca. 0.6 Sek.

n <- 100000L # Anzahl der Durchläufe
system.time({    # Objekt wächst laufend
  res <- NULL
  for (i in 1:n) res <- c(res, i^2)
})                                             # ca. 8.5 Sek.
system.time({   #  Speicherplatz wird vorab reserviert
  res <- numeric(n)
  for (i in 1:n) res[i] <- i^2
})                                             # ca. 0.005 Sek
\end{lstlisting}


\subsubsection{while-Schleife}

Die \lstinline|while|-Schleife wiederholt einen Codeblock, solange eine spezifische logische Bedingung (\lstinline|TRUE|) erfüllt ist. Da die Bedingung bereits \emph{vor} jeder Iteration geprüft wird, kann es vorkommen, dass der Codeblock gar nicht ausgeführt wird, falls die Bedingung von Beginn an \lstinline|FALSE| ist.

\paragraph{Syntax und Steuerung}

Die korrekte Funktionsweise einer \lstinline|while|-Schleife erfordert eine manuelle Steuerung. Da sie nicht automatisch über eine Sequenz iteriert, muss die Bedingungsvariable vor dem Start der Schleife definiert sein (Initialisierung). Zudem muss der Wert dieser Variable innerhalb des Blocks verändert werden (Aktualisierung), da die Schleife andernfalls als Endlosschleife weiterläuft.

\begin{lstlisting}
i <- 1         # Initialisierung notwendig
while (i <= 5) {
  cat(i)
  i <- i + 1  # Manuelle Inkrementierung
}             # 12345

set.seed(42)
wert <- 0
while (wert < 10) {   # Läuft bis 10 erreicht ist
  wert <- wert + runif(1)
  cat(wert, "\n")
}

#while (TRUE) cat(".")  # Endlosschleife (STRG+c)
\end{lstlisting}

\paragraph{Anwendungsfall: Unbekannte Iterationszahl}

Im Gegensatz zur \lstinline|for|-Schleife wird \lstinline|while| primär dann eingesetzt, wenn die Anzahl der Wiederholungen vorab nicht bekannt ist:

\begin{itemize}
\item Iterative Näherungsverfahren, bis eine gewünschte Präzision erreicht ist.
\item Simulationen, die bis zum Eintritt eines Ereignisses laufen sollen.
\item Warten auf externe Ressourcen oder Benutzereingaben.
\end{itemize}


\subsubsection{repeat-Schleife}

Die \lstinline|repeat|-Schleife erstellt eine Endlosschleife ohne eingebaute Abbruchbedingung. Sie wird so lange wiederholt, bis sie durch ein explizites \lstinline|break|-Statement innerhalb des Codeblocks abgebrochen wird. 

Im Gegensatz zur \lstinline|while|-Schleife kann die Prüfung auch am Ende des Blocks erfolgen, wodurch sichergestellt wird, dass die Anweisungen \emph{mindestens einmal} ausgeführt werden.

\paragraph{Syntax und Steuerung}

Da die Schleife niemals von selbst endet, ist die Platzierung des \lstinline|break|-Befehls essenziell.

\begin{lstlisting}
i <- 1
repeat {
  cat(i)
  i <- i + 1
  if (i > 5) break # Abbruchbedingung
}                  # Ausgabe: 12345

set.seed(42)
w <- 0
repeat {
  w <- w + runif(1)
  cat(w, "\n")
  if (w >= 10) break
}
\end{lstlisting}

\paragraph{Anwendungsfall}

\lstinline|repeat| ist dann eine elegante Wahl, wenn:

\begin{itemize}
\item Der Codeblock zwingend einmal durchlaufen werden muss (z.\,B.\ bei Initialisierungen innerhalb der Schleife).
\item Die Abbruchbedingung sehr komplex ist oder an mehreren Stellen geprüft werden muss.
\item Ein Algorithmus mit mehreren Austrittspunkten implementiert wird.
\end{itemize}


\subsection{Iteration über Datenreihen}

In der Programmierung ist es eine alltägliche Aufgabe, dieselbe Operation auf eine Vielzahl von Datenelementen anzuwenden. Während R auch die klassische Möglichkeit expliziter \lstinline|for|- oder \lstinline|while|-Schleifen bietet, existiert eine Gruppe von Funktionen, die eine andere Funktion entgegennehmen und diese entweder \emph{sukzessive} über eine Datenreihe aufrufen oder die gesamte Datenreihe als Argumentliste \emph{auf einmal} übergeben (\emph{funktionale Programmierung}, \emph{Hide the loop}). Dies kann zu kompakterem, lesbarerem und effizienterem Code führen.

\subsubsection{do.call(what, args) -- Listen als Funktionsargumente}

Mit \lstinline|do.call(what, args)| wird eine Funktion (\lstinline|what|) mit Argumenten aus einer Liste (\lstinline|args|) genau \emph{einmal} aufgerufen. Dabei werden die Elemente der Liste als einzelne Argumente in die Funktionsklammer geschrieben. 

Den resultierenden (internen) Befehl kann man mit \lstinline|as.call(c(quote(rbind), l))| anzeigen.

\lstinline|do.call| ist hilfreich, wenn:
\begin{itemize}
\item die Anzahl der Argumente vorab unbekannt ist,
\item Argumente dynamisch in einer Liste verändert werden,
\item eine Liste von Objekten, die als Argumente übergeben werden, sehr umfangreich ist (z.\,B. Hunderte von Data Frames für \lstinline|rbind|).
\item die Evaluierung von Argumenten erzwungen werden muss, bevor sie an Funktionen übergeben werden.    
\end{itemize}

\begin{lstlisting}
l <- list(1, 2:3)
do.call(paste, l)             # "1 2" "1 3"
as.call(c(quote(paste), l))   # paste(1, 2:3)
paste(1, 2:3)                 # "1 2" "1 3"

do.call(paste, c(l, sep="-")) # "1-2" "1-3"
l <- list(1, 2:3, sep="-")
do.call(paste, l)             # "1-2" "1-3"
as.call(c(quote(paste), l))   # paste(1, 2:3, sep = "-")
paste(1, 2:3, sep="-")        # "1-2" "1-3"
\end{lstlisting}

Ein spezieller Anwendungsfall tritt auf, wenn Funktionen wie \lstinline|substitute(expr, env)| verwendet werden. Diese greifen direkt auf das übergebene Symbol (das Versprechen) zu, anstatt dessen Inhalt zu evaluieren.

Bim Aufruf von \lstinline|substitute(u, list(x = 1))| verwendet die Funktion nur das Symbol \lstinline|u| und findet darin kein \lstinline|x|, das ersetzt werden könnte. Das Ergebnis bleibt \lstinline|u|.

Mit \lstinline|do.call| hingegen wird die Liste der Argumente \emph{zuerst} evaluiert. Das Symbol \lstinline|u| wird durch seinen Inhalt (\lstinline|x + 1|) ersetzt, bevor es an \lstinline|substitute| übergeben wird.

\begin{lstlisting}
u <- quote(x + 1)
substitute(u, list(x = 1))      # u; sieht nur u
do.call(substitute, list(u, list(x = 1))) # 1 + 1
as.call(c(substitute, list(u, list(x = 1))))
  # .Primitive("substitute")(x + 1, list(x = 1))
\end{lstlisting}


\subsubsection{Anonyme Funktionen}

\emph{Anonyme Funktionen} (auch Lambda-Funktionen genannt) sind Funktionen ohne Namen, die ad-hoc definiert und direkt als Argument an eine andere Funktion übergeben werden. Dies ist besonders nützlich für kurze Operationen, die nur an einer einzigen Stelle im Code benötigt werden.

\begin{lstlisting}
l <- list(1, 2, 3)
f <- \(x) x^2       # Benannte Funktion
sapply(l, f)        # 1 4 9; Verwendung benannten Funktion
sapply(l, \(x) x^2) # 1 4 9; Verwendung anonymer Funktion
\end{lstlisting}


\subsubsection{apply -- Array}

Die Funktion \lstinline|apply| wird verwendet, um eine Operation auf die Zeilen oder Spalten einer Matrix oder eines Arrays anzuwenden. Das Argument \lstinline|MARGIN| beschreibt, welche Dimensionen \emph{erhalten} bleiben sollen, während die anderen durch die Funktion reduziert werden. Dabei steht \lstinline|1| für die Zeilen und \lstinline|2| für die Spalten. Die Angabe \lstinline|c(1, 3)| bedeutet beispielsweise, dass die Funktion auf jede Kombination der ersten und dritten Dimension angewendet wird.

Das Argument \lstinline|simplify = TRUE| (Standard) sorgt bei \lstinline|apply| dafür, dass das Ergebnis nach Möglichkeit wieder in ein Array oder einen Vektor umgewandelt wird.

Die Stärke von \lstinline|apply| liegt in der Abstraktion von Koordinaten. Anstatt in verschachtelten Schleifen Indizes wie \lstinline|m[i, j]| zu verwalten, beschreiben Sie mit \lstinline|MARGIN| lediglich, welche Achsen der Datenstruktur beobachten soll. R kümmert sich intern um die Adressierung der Speicherbereiche, was den Code kompakter und weniger anfällig für Fehler macht.

\begin{lstlisting}
m <- matrix(1:4, 2)   # 1 3
                      # 2 4 
apply(m, 1, sum)      # 4 6; Zeilensumme
apply(m, 2, sum)      # 3 7; Spaltensumme
apply(m, 1:2, sum)    # 1 3; Identisch zu m
                      # 2 4
apply(m, 2:1, sum)    # 1 2; Transponiert m
                      # 3 4
a <- array(1:8, c(2,2,2))
apply(a, c(1,3), sum) # 4 12
                      # 6 14
\end{lstlisting}

Für häufige Operationen wie Summen oder Mittelwerte bietet R Funktionen wie \lstinline|rowSums()|, \lstinline|colSums()|, \lstinline|rowMeans()| und \lstinline|colMeans()| an.


\subsubsection{Einfache Listeniteration}

Diese Funktionen wenden eine Operation auf jedes Element einer Liste oder eines Vektors an und sammeln die Ergebnisse in einer neuen Struktur.

\paragraph{lapply(X, FUN, ...)}

\lstinline|lapply()| (\emph{list apply}) ist die Basis-Funktion. Sie gibt grundsätzlich eine \emph{Liste} zurück. Dies ist die sicherste Methode, da sie unabhängig vom Ergebnis der Funktion \lstinline|FUN| immer dieselbe Struktur liefert.

\begin{lstlisting}
l <- list(a=2, b=3:5, c=5:9)
x <- lapply(l, mean) # [[1]] 2 [[2]] 4 [[3]] 7; Liste
simplify2array(x)    # 2 4 7; Vereinfacht Liste
l <- list("a", 1)
lapply(l, identity)  # [[1]] "a" [[2]] 1
\end{lstlisting}

\paragraph{sapply(X, FUN, ...)}

\lstinline|sapply()| (\emph{simplified apply}) ist ein Wrapper für \lstinline|lapply|, der versucht, das Ergebnis zu einem Vektor oder einer Matrix zu vereinfachen. Das ist bequem für die interaktive Arbeit, kann aber in Skripten riskant sein, da der Rückgabetyp instabil sein kann, wenn die Eingabe leer ist oder unerwartete Längen liefert.

\begin{lstlisting}
l <- list(a=2, b=3:5, c=5:9)
sapply(l, mean)      # 2 4 7
l <- list("a", 1)
sapply(l, identity)  # "a" "1"; alles Char
sapply(list(), sum)  # list()
\end{lstlisting}

\paragraph{vapply(X, FUN, FUN.VALUE, ...)}

\lstinline|vapply()| (\emph{verified apply}) ist die robuste Alternative. Hier muss über \lstinline|FUN.VALUE| eine Vorlage des erwarteten Ergebnisses angegeben werden. Passt ein Ergebnis nicht zur Vorlage, bricht R mit einer Fehlermeldung ab. Dies verhindert schwer zu findende Folgefehler in komplexen Programmen.

\begin{description}
\item[Leere Eingaben:] \lstinline|vapply| liefert einen leeren Vektor des korrekten Typs, während \lstinline|sapply| eine leere Liste zurückgibt.
\item[Typ-Sicherheit:] Es verhindert, dass Zahlen schleichend in Text umgewandelt werden (keine ungewollte Coercion).
\item[Struktur-Garantie:] Es stellt sicher, dass jedes Element exakt die erwartete Länge hat (verhindert Listen-Fallbacks).
\end{description}

\begin{lstlisting}
l <- list(a=2, b=3:5, c=5:9)
vapply(l, mean, numeric(1))    # 2 4 7
#vapply(l, mean, character(1)) ## Error: Ergebnis nicht Char
l <- list("a", 1)
#vapply(l, identity, numeric(1))   ## Error: Typ
#vapply(l, identity, character(1)) ## Error: Typ
vapply(list(), sum, numeric(1))    # numeric(0)
\end{lstlisting}


\subsubsection{mapply und Map -- Parallele Iteration}

Während \lstinline|lapply| nur über ein Objekt iteriert, erlauben \lstinline|mapply()| (multivariate apply) und \lstinline|Map()| das gleichzeitige Durchlaufen mehrerer Vektoren oder Listen. Das erste Element von Objekt A wird mit dem ersten Element von Objekt B verarbeitet, dann die zweiten, und so weiter.

\paragraph{mapply(FUN, ...)}

Das erste Argument ist die Funktion \lstinline|FUN|. Die Argumente in \lstinline|...| sind die Datenreihen, über die parallel iteriert wird. Sind die Argumente unterschiedlich lang, nutzt R die üblichen Recycling-Regeln.

\begin{itemize}
\item \lstinline|MoreArgs|: Eine \emph{benannte} Liste von weiteren Argumenten, die \emph{konstant} an jeden Funktionsaufruf übergeben werden.
\item \lstinline|SIMPLIFY|: Ein logischer Wert. Wenn \lstinline|TRUE| (Standard), wird das Ergebnis vereinfacht (analog zu \lstinline|sapply|). Bei \lstinline|FALSE| bleibt es eine Liste.
\end{itemize}

\begin{lstlisting}
x <- list(1, c(2, NA))
y <- list(10, c(20, 30))
mapply(sum, x, y)                                # 11 NA
mapply(sum, 1, y)                                # 11 51
mapply(sum, x, y, MoreArgs = list(na.rm = TRUE)) # 11 52
mapply(sum, x, y, SIMPLIFY=FALSE)   # [[1]] 11  [[2]] NA
Map(sum, x, y)                      # [[1]] 11  [[2]] NA
\end{lstlisting}


\paragraph{Map(f, ...)}

\lstinline|Map| ist ein Wrapper für \lstinline|mapply| mit \lstinline|SIMPLIFY = FALSE|. Es gibt grundsätzlich eine \emph{Liste} zurück.


\subsubsection{rapply -- Rekursive Iteration}

\lstinline|rapply()| (\emph{recursive apply}) ist eine spezialisierte Version von \lstinline|lapply| für verschachtelte Listen. Sie wandert tief in die Struktur hinein und wendet die Funktion auf die Blätter (die untersten Elemente) des Listenbaums an. Dies erspart das Schreiben von manuellen rekursiven Funktionen oder tief verschachtelten Schleifen.

Wichtige Argumente:

\begin{itemize}
\item \lstinline|classes|: Definiert, auf welche Datentypen die Funktion angewendet wird. Alle anderen Elemente werden ignoriert oder unverändert gelassen. R unterscheidet hier strikt: Um sowohl \lstinline|1:3| (Integer) als auch \lstinline|1.5| (Double) zu erfassen, muss \lstinline|c("numeric", "integer")| angegeben werden.
\item \lstinline|how|: Steuert das Format der Rückgabe:
  \begin{itemize}
  \item \lstinline|"unlist"| (Standard): Resultat wird zu einem flachen Vektor zusammengefasst.
  \item \lstinline|"replace"|: Die ursprüngliche Listenstruktur bleibt erhalten; nur die passenden Elemente werden ersetzt.
  \item \lstinline|"list"|: Die Struktur bleibt erhalten, aber Elemente, die nicht den \lstinline|classes| entsprechen, werden auf \lstinline|NULL| gesetzt.
  \end{itemize}
\item \lstinline|deflt|: Das Standard-Ergebnis für Elemente, die nicht den \lstinline|classes| entsprechen (nur relevant bei \lstinline|how = "list"|).
\end{itemize}

\begin{lstlisting}
l <- list(a = 1.5, b = list(c = 1:4, d = "Text"))
rapply(l, mean)     # 1.5 2.5 NA; Warnung: nicht Numerisch
rapply(l, mean, "numeric")               # a: 1.5
rapply(l, mean, "integer")               # b.c: 2.5
rapply(l, mean, c("numeric", "integer")) # a: 1.5  b.c: 2.5
rapply(l, mean, "integer", how = "replace")
 # [[a]] 1.5  [[b]] c: 2.5  d: "Text"
rapply(l, mean, "integer", how = "list")
 # [[a]] NULL [[b]] c: 2.5  d: NULL
rapply(l, mean, "integer", how = "list", deflt = 0)
 # [[a]] 0    [[b]] c: 2.5  d: 0
\end{lstlisting}


\subsubsection{Reduce -- Kumulative Iteration}

\lstinline|Reduce()| wendet eine Funktion mit zwei Argumenten sukzessive auf die Elemente einer Liste an. Dabei wird das Ergebnis des ersten Schritts als erstes Argument für den nächsten Schritt verwendet.

\begin{description}
\item[Prinzip:] \lstinline|f(f(f(x1, x2), x3), x4) ...|
\item[Nutzung:] Zusammenführen einer unbekannten Anzahl von Objekten (z.\,B.\ \lstinline|merge| von Data Frames oder Mengenvergleiche per \lstinline|intersect|).
\item[Argumente:] ~
  \begin{itemize}
  \item \lstinline|init|: Ein optionaler Startwert für die Operation.
  \item \lstinline|accumulate|: Bei \lstinline|TRUE| werden alle Zwischenschritte statt nur des Endergebnisses ausgegeben.
  \end{itemize}
\end{description}

\begin{lstlisting}
Reduce(`+`, list(1, 2, 3))   # 6; ((1 + 2) + 3)

l <- list(a=2, b=3:5, c=5:9)
f <- \(x, y) x * sum(y)
Reduce(f, l)       # 840; (2 * sum(3:5)) * sum(5:9)
Reduce(f, l, 2)    # 1680; Mit Startwert ((2 * 2) * 12) * 35
Reduce(f, l, 2, accumulate = TRUE)  # 2 4 48 1680

# Schnittmenge über mehrere Vektoren
x <- 1:4; y <- 2:5; z <- 3:6
Reduce(intersect, list(x, y, z))  # 3 4

# merge mehrerer Data Frames
df1 <- data.frame(id=1:2, a=10:11)
df2 <- data.frame(id=1:2, b=20:21)
df3 <- data.frame(id=1:2, c=30:31)
Reduce(\(x, y) merge(x, y, by="id"), list(df1, df2, df3))
\end{lstlisting}





%%%
\iffalse


\subsection{Speicherverwaltung und Garbage Collection}

Das \lstinline|bench|-Paket liefert zwar die Menge des \emph{alloziierten} Speichers (`mem\_alloc`), aber nicht den maximalen Speicherverbrauch (Peak-Verbrauch) während der Ausführung. R verwendet ein automatisches Speichermanagement namens "Garbage Collection" (GC), um nicht mehr benötigte Objekte aufzuräumen.

\subsubsection{\lstinline|gc()|: Garbage Collection Manuell ausführen}

Die Funktion \lstinline|gc()| fordert das System auf, den Speicher sofort aufzuräumen und einen Bericht über die Speichernutzung zu liefern. Normalerweise läuft dies automatisch im Hintergrund, aber für Benchmarking-Zwecke kann eine manuelle Ausführung hilfreich sein, um den tatsächlichen Speicherbedarf vor und nach einer Operation zu messen.

Die Ausgabe zeigt die Nutzung von \emph{Vektorspeicher} (`Vcells`) und \emph{Konsenspeicher} (`Ncells`).

\begin{lstlisting}
library(bench)

# Aktuellen Speicherstatus vor der Operation prüfen
gc() 
#      used (Mb) gc trigger (Mb) limit (Mb) max used (Mb)
# Ncells  371.4     648.5         NA    376.1
# Vcells  159.2     168.1         NA    160.5

# Eine Operation, die viel Speicher alloziiert
m <- matrix(0, nrow = 10000, ncol = 10000)

# Speicherstatus nach der Operation (Peak 'max used' steigt)
gc()
#      used (Mb) gc trigger (Mb) limit (Mb) max used (Mb)
# Ncells  371.7     649.0         NA    376.1
# Vcells  920.1     960.1         NA    920.1 

# Nach dem Aufräumen des Objekts 'm'
rm(m)
gc() 
# 'max used' bleibt hoch, aber 'used' sinkt
\end{lstlisting}

\subsubsection{\lstinline|gctorture()|: Speicherdruck simulieren}

Die Funktion \lstinline|gctorture(TRUE)}| ist ein fortgeschrittenes Debugging-Tool. Sie zwingt R dazu, die Garbage Collection nach \emph{jeder einzelnen} Speicheranforderung auszuführen.

Dies verlangsamt den Code drastisch, ist aber nützlich, um Speicherprobleme aufzudecken, die zu Fehlern bei der Speicherzuweisung führen könnten, insbesondere wenn man C- oder C++-Code über \lstinline|Rcpp| verwendet, der den R-Speicher nicht korrekt verwaltet.

\begin{lstlisting}
# Aktiviert den Speicherdruck (ACHTUNG: Code wird langsam!)
gctorture(TRUE) 

# Führt Code aus, um Speicherfehler oder ineffiziente Zuweisungen zu finden
# bench::mark(...) oder system.time(...) können hier verwendet werden
# Man sucht nach Fehlern wie "cannot allocate vector of size..."

# Deaktiviert den Speicherdruck
gctorture(FALSE)
\end{lstlisting}




\subsection{Performance-Messung (Benchmarking)}

%%% https://fastverse.org/fastverse/
%%% future.apply
%%% https://www.futureverse.org/
%%% parallel::

Um die Effizienz verschiedener Code-Implementierungen (z.\,B. Schleifen vs. Vektorisierung vs. \lstinline|Rcpp|) objektiv vergleichen zu können, verwendet man Benchmarking-Tools. Das \lstinline|bench|-Paket bietet eine moderne und präzise Methode zur Messung der Ausführungszeit.

\subsubsection{Das \lstinline|bench|-Paket}

Die Hauptfunktion ist \lstinline|bench::mark()|. Sie führt die bereitgestellten Ausdrücke mehrmals aus, misst Zeit, Speicherverbrauch und verhindert, dass R Optimierungen vornimmt, die das Ergebnis verfälschen würden.

\begin{lstlisting}
# install.packages("bench")
library(bench)

# Beispiel: Vergleich von sum() (vektorisiert) und einer for-Schleife
n <- 1e6 # Eine Million Zahlen
input_data <- as.list(1:n)

benchmark_ergebnisse <- bench::mark(
  sum_func = sum(1:n),
  for_loop = {
    total <- 0
    for (i in 1:n) {
      total <- total + i
    }
    total
  },
  iterations = 10 # Anzahl der Wiederholungen für bessere Präzision
)

# Anzeige der Ergebnisse (Ausgabe zeigt typischerweise min/mean/median Zeiten)
print(benchmark_ergebnisse)
\end{lstlisting}

\subsubsection{Ergebnisse interpretieren}

Die Ausgabe von \lstinline|bench::mark()| zeigt Metriken wie `min`, `mean`, `median` Ausführungszeit sowie `mem\_alloc` (Speicherverbrauch).

*   **`median`:** Ist oft die robusteste Metrik, da sie weniger anfällig für kurzfristige Systemaktivitäten ist.
*   **`mem\_alloc`:** Zeigt, wie viel Speicher die Operation während der Ausführung zugewiesen hat. Effizienter Code verbraucht oft weniger Speicher.

Im obigen Beispiel wird die `sum\_func` (vektorisiert) signifikant schneller und speichereffizienter sein als die `for\_loop` (iterativ).

\subsubsection{Basismethoden in R}

Bevor das \lstinline|bench|-Paket populär wurde, verwendete man oft die Basis-R-Funktion \lstinline|system.time()|. Sie ist einfacher zu verwenden, aber weniger präzise als \lstinline|bench::mark()| für kurze Operationen, da sie keine Mehrfachmessungen durchführt und keine Speichermetriken liefert.

\begin{lstlisting}
# Basis R Methode: weniger detailliert
system.time(
  for (i in 1:1e6) {
    # do something fast
  }
)
# Ausgabe: user  system elapsed 
#          0.2   0.0     0.2 
\end{lstlisting}




\subsection{Integration von C++ mit \lstinline|Rcpp|}

Das Paket \lstinline|Rcpp| ermöglicht die nahtlose Integration von C++-Code in R. Der Hauptgrund für die Verwendung von \lstinline|Rcpp| ist die \emph{Leistungssteigerung} (Performance-Optimierung), da C++ in der Regel deutlich schneller als R-Code (insbesondere Schleifen) ausgeführt wird.

\subsubsection{Konzept und Zweck}

R ist eine interpretierte Sprache, während C++ eine kompilierte Sprache ist. \lstinline|Rcpp| fungiert als Brücke, die R-Objekte effizient in C++-Objekte umwandelt, die C++-Funktion ausführt und die Ergebnisse wieder als R-Objekte zurückgibt.

Es richtet sich an fortgeschrittene Anwender, die spezifische, rechenintensive Teile ihres Codes optimieren müssen.

\subsubsection{Einrichtung und Prozess}

Um \lstinline|Rcpp| zu nutzen, müssen das Paket installiert und ein C++-Compiler (z.\,B. Rtools unter Windows, Xcode unter macOS) eingerichtet sein. Der Workflow beinhaltet das Schreiben von C++-Funktionen, die mit speziellen Attributen versehen sind, und das anschließende Kompilieren und Laden in die R-Sitzung.

\paragraph{Beispiel: Eine einfache C++-Funktion in R}

Im R-Paket \lstinline|Rcpp| ist die Funktion \lstinline|cppFunction()| enthalten, die den Prozess demonstriert, indem sie C++-Code direkt aus einem R-Skript kompiliert und lädt.

\begin{lstlisting}
# Installation des Pakets
# install.packages("Rcpp")
library(Rcpp)

# Wir definieren und kompilieren eine C++ Funktion direkt in R
cppFunction('
  // [[Rcpp::export]] 
  int addiere_zwei_zahlen(int x, int y) {
    int summe = x + y;
    return summe;
  }
')

# Die Funktion kann nun wie jede normale R-Funktion aufgerufen werden
ergebnis <- addiere_zwei_zahlen(10, 20)
ergebnis # 30
\end{lstlisting}

\subsubsection{Hinweis zur Vektorisierung}

Bevor man zu \lstinline|Rcpp| greift, sollte man sicherstellen, dass der R-Code optimal \emph{vektorisiert} ist (wie im Kapitel zur Logischen Indizierung und Funktionalem Programmieren beschrieben). Vektorisierter R-Code ist oft schnell genug und wesentlich einfacher zu warten als C++-Code. \lstinline|Rcpp| ist das Werkzeug der letzten Wahl für Performance-Engpässe.



\fi
%%%


\subsection{Fehlerbehandlung: try, tryCatch, stop, warning, message}

Fehler können im Program mit \lstinline|try| oder \lstinline|tryCatch| behandelt werden.

\begin{lstlisting}
f1 <- \(x) {
  ret <- NA_real_
  ret <- log(x)
  ret
}
x <- f1("a")
#x                ## Fehler, x nicht gefunden
f1(-1)            # NaN

f2 <- \(x) {
  ret <- NA_real_
  try(ret <- log(x)) # Kein Abbruch
  ret
}
f2("a")           # NA
f2(-1)            # NaN

f3 <- \(x) {
  tryCatch(log(x),
    warning = \(s) {message("Warnung: ", s); NULL},
    error = \(s) {message("Fehler: ", s);  NA_real_},
    finally = {message("Ende")} )
}
x <- f3("a")      # Fehler, Ende
x                 # NA
x <- f3(-1)       # Warnung, Ende
x                 # NULL

f4 <- \(x) {
  tryCatch(log(x),
    error = \(s) {message("Fehler");  NA_real_} )
}
f4("a")           # NA, Fehler
f4(-1)            # NaN, Warnmeldung

f5 <- \(x) {
  tryCatch(withCallingHandlers(log(x),
    warning = \(s) {
      message("Warnung")
      invokeRestart("muffleWarning")} ),
    error = \(s) {message("Fehler");  NA_real_} )
}
f5("a")           # NA, Fehler
f5(-1)            # NaN, Warnung

f6 <- \() {
  stop("Abbruch") # erzeugt Fehler
  42
}
y <- f6()
#y                ## y nicht gefunden

f7 <- \() {
  warning("Achtung") # Warnung, Programm läuft weiter
  42
}
f7()              # 42, Warnmeldung

f8 <- \() {
  message("Info") # Informative Meldung
  42
}
f8()              # 42, Info

f9 <- \(x) { stopifnot(x >= 0); log(x) } # Beenden wenn nicht
f9(0)     # -Inf
f9(-1)    # Fehler in f9(-1) : x >= 0 ist nicht TRUE
\end{lstlisting}


\subsection{Fehlersuche und Debugging}

Mit \lstinline|traceback()| wird der Aufrufstack (die Kette von
Funktionen, die sich gegenseitig aufrufen) zum Zeitpunkt des Fehlers
angezeigt.

Mit \lstinline|debug(fun)| wird eine Funktion dauerhaft, mit
\lstinline|debugonce(fun)| nur beim nächsten Aufruf für interaktives
Debugging markiert.

Mit \lstinline|browser()| kann an beliebiger Stelle gezielt in den
Debugger gesprungen werden.

Im interaktiven Debugger stehen u.\,a. folgende Befehle zur Verfügung:

\begin{description}
  \item[\texttt{n\dots next}:] nächste Anweisung ausführen („step over“)
  \item[\texttt{s\dots step into}:] in den aufgerufenen Funktionsaufruf hineingehen
  \item[\texttt{f\dots finish}:] aktuelle Funktion bis zum Ende ausführen
  \item[\texttt{c\dots continue}:] weiterlaufen bis zum nächsten Breakpoint oder Ende
  \item[\texttt{Q\dots Quit}:] Debugger verlassen und Ausführung abbrechen
  \item[\texttt{where}:] aktuellen Call-Stack anzeigen (äquivalent zu \texttt{traceback()})
  \item[\texttt{beliebiger R-Ausdruck}:] wird direkt im aktuellen Environment ausgewertet, z.\,B. \lstinline|ls()|, \lstinline|x|, \lstinline|head(x)|
\end{description}

\begin{lstlisting}
f <- \(x) g(x)
g <- \(x) {
  h(x) }
h <- \(x) stop("Testfehler")
f(0)        # Fehler in h(x) : Testfehler
traceback() # 4: stop("Testfehler") at #1
            # 3: h(x) at #2; Callstack 3, h(x) in Zeile 2 von g
            # 2: g(x) at #1; Callstack 2, g(x) in Zeile 1 von f
            # 1: f(0)

trace("g", quote(browser()), at=2) # Fügt browser() in g ein
f(0)        # Geht jetzt in Debugging Modus => Interaktiv
body(g)     # Gibt funktion mit eingefügtem tracing code aus
untrace("g")

trace(sum)  # Zeigt an wenn Funktion sum aufgerufen wird
hist(rnorm(100)) # Wird 3-4 mal aufgerufen
untrace(sum)

debug(g)    # Debugging für Funktion g aktivieren
f(0)        # Interaktiv: Q, n, s, c, ... verwenden
undebug(g)  # Debugging wieder ausschalten

debugonce(g) # Debugging einmal aktivieren
f(0)

f <- \(x) {
  browser()   # Ausführung hier anhalten und in Debugger gehen
  x <- x + 1
  x * 2
}
f(0)        # Interaktiv: Q, n, s, c, ... verwenden
\end{lstlisting}










\iffalse
    

\section{Datenmanipulation}

1. Arithmetische und logische Operatoren (+, *, ==, &, |):

    Diese bilden das Fundament und werden meist unter Basics oder Operatoren geführt. Sie verarbeiten einzelne Werte oder Vektoren elementweise.

2. Aggregatfunktionen / Zusammenfassende Funktionen (sum, any, all, mean):

    Diese reduzieren einen Vektor auf einen einzigen Wert. In der Fachliteratur werden sie meist Aggregatfunktionen (Aggregate Functions) oder Summary Statistics genannt.

3. Gruppierte Aggregation (aggregate, rowMeans, colSums):

    Diese Funktionen wenden Aggregatfunktionen auf bestimmte Untergruppen oder Dimensionen (z. B. Zeilen/Spalten) an. Sie werden oft unter dem Begriff Datenaggregation oder Grouped Operations zusammengefasst. 



1.    Arithmetische und vektorielle Operatoren (+, -, *, /, ^ etc.):
    Diese sind infix-Operatoren, die elementweise auf Vektoren angewendet werden (vektorisiert). Sie bilden die Basis für viele Berechnungen in R.
    Gruppe: „Arithmetische Operatoren“ oder „Vektorisierte Operationen“.
2.    Zusammenfassende (summary) Funktionen (sum(), mean(), min(), max(), any(), all() etc.):
    Diese reduzieren einen Vektor auf einen einzelnen Wert (Skalar). Sie werden oft als Reduktionsfunktionen oder Zusammenfassungsfunktionen (summary functions) bezeichnet.
    any() und all() sind logische Reduktionen (ähnlich wie logisches OR/AND über einen Vektor).
    Gruppe: „Zusammenfassende Funktionen“ oder „Summary/Reduction Functions“.
3.    Spezialisierte Zusammenfassungen (rowMeans(), colMeans(), rowSums(), colSums()):
    Diese wenden mean() oder sum() zeilen- oder spaltenweise auf Matrizen/Dataframes an. Sie sind optimierte Varianten für 2D-Strukturen.
    Gruppe: „Zeilen-/Spaltenweise Zusammenfassungen“ (oft zusammen mit den obigen summary functions behandelt).
4.    Aggregationsfunktionen (aggregate(), oft kombiniert mit tapply(), by()):
    Diese gruppieren Daten (z. B. nach einer Faktorvariable) und wenden eine Zusammenfassungsfunktion (wie sum oder mean) auf Untergruppen an.
    Gruppe: „Gruppierte Aggregation“ oder „Split-Apply-Combine“ (ein Konzept, das in vielen Tutorials verwendet wird).

    
\fi


\subsection{Pipes}

Der native Pipe-Operator \lstinline!|>! ist reiner syntaktischer Zucker 
und \emph{keine} schrittweise Links-nach-Rechts-Ausführung. 

Ein Ausdruck wie \lstinline!x |> f() |> g() |> h()!
wird vor der Auswertung zu \lstinline|h(g(f(x)))| umgeschrieben 
und anschließend nach den üblichen R-Regeln ausgewertet
(insbesondere mit Lazy Evaluation der Funktionsargumente).

Jeder Pipe-Ausdruck lässt sich ersetzen durch:
\begin{itemize}
  \item verschachtelte Funktionsaufrufe: \lstinline!h(g(f(x)))! oder
  \item explizite Zwischenspeicherung:
\begin{lstlisting}
tmp <- f(x)
tmp <- g(tmp)
h(tmp)
\end{lstlisting}
\end{itemize}

Die Pipe ändert weder Semantik noch Auswertungsreihenfolge.
Sie bietet lediglich eine für manche
lesbarere Schreibweise verschachtelter Funktionsaufrufe.

\begin{lstlisting}
1:3 |> sum()           # 6
#1:3 |> sum            ## Error, braucht function call
sum(1:3)               # 6; Äquivalent
quote( 1:3 |> sum() )  # sum(1:3); Syntax transformation

. <- 1:3               # Zwischenwerte explizit speichern
sum(.)                 # 6

1:3 -> .               # Zwischenwerte explizit speichern
sum(.)                 # 6

1:3 ->.; sum(.)        # 6; Bizarro pipe

#1:3 |> `+`(4)         ## Error, nicht unterstützt
1:3 |> (`+`)(4)        # 5 6 7
1:3 |> base::`+`(4)    # 5 6 7
1:3 |>  `+`(4, e2 = _) # 5 6 7

1 |> seq(3)            # 1 2 3; Einfügen erster freier Platz
3 |> seq(from=1)       # 1 2 3
1 |> seq(to=3)         # 1 2 3

3 |> seq(1, to=_)      # 1 2 3; _ ... Platzhalter
#3 |> seq(1, _)        ## Error, _ braucht Namen
"b" |>  paste("a", . = _, "c") # "a b c"; Auch ... benötigt Name 
3 |> (\(.) seq(1, .))() # 1 2 3; Über Funktion
#3 |> rep(x=_, times=_)## Error, _ darf nur einmal vorkommen
3 |> (\(.) rep(., .))() # 3 3 3; Über Funktion

#1:3 |> sum(sqrt(x=_)) ## Error, _ nicht in nested calls
1:3 |> (\(.) sum(sqrt(x=.)))() # 4.146; Über Funktion
#1:3 |> sum(sqrt())    ## Error, kein Argument an sqrt
1:3  |> sum(sqrt(1))   # 7; sum(1:3, sqrt(1))

mtcars |> _$cyl        # 6 6 4 ...; Extraction call
mtcars |> _$cyl[3]     # 4

"x" |> assign(1)       # Kein zusätzliches Environment
x                      # 1
"x" |> (\(.) assign(., 2))() # Im Funktionsenvironment
x                      # 1

f1 <- \(x) { message("f1"); x }
f2 <- \(x) { message("f2"); x }
. <- 0
. <- f1(.)             # f1; Auswertung je Zeile
f2(.)                  # f2 0
0 |> f1() |> f2()      # f2 f1 0; Lazy evaluation
quote(0 |> f1() |> f2()) # f2(f1(0))
f2(f1(0))              # f2 f1 0
\end{lstlisting}










\iffalse

\begin{lstlisting}
q()                   # Beendet R (mit Rückfrage)
#                     # Kommentar bis Zeilenende
help()                # Hilfe starten
help(q)               # Hilfe zu Befehl q
?q                    # Hilfe zu Befehl q
#?for                 ## funktioniert nicht
?"for"                # Hilfe zur for-Schleife
#help(for)            ## erzeugt Fehler
help("for")           # Hilfe zur for-Schleife
??reg                 # Sucht nach "reg" in allen Hilfetexten
help.search("reg")    # Wie ??reg, aber als Funktion
help.start()          # Öffnet HTML-Hilfesystem
library(help = "stats")  # Hilfeübersicht zum Paket "stats"
args(lm)              # Argumente der Funktion lm
methods("plot")       # Methoden für generische Funktion plot
methods(class = "lm") # Methoden für Objekte der Klasse "lm"
getAnywhere("simpleLoess")#Zeigt auch nicht exportierte Funktion
example(lm)           # Führt Beispiele zu lm aus
demo()                # Zeigt verfügbare Demos
demo(lm)              # Demo zur linearen Regression

install.packages("lme4") # Installiert das Paket
update.packages()    # Aktualisiert Pakete
remove.packages()    # Entfernt Paket
installed.packages() # Zeigt alle installierten Pakete
library(lme4)        # Paket laden
require(lme4)        # Alternative, gibt bei Fehler FALSE zurück
search()             # Zeigt geladene Pakete und Umgebungen
vignette()           # Verfügbare Vignetten anzeigen
vignette("lmer")     # Einführung zu lmer öffnen

version              # R-Version anzeigen
sessionInfo()        # Infos zu Umgebung und geladenen Paketen
citation()           # Wie man R zitiert
x = 1                # Der Variablen x den Wert 1 zuweisen
x <- 1               # Der Variablen x den Wert 1 zuweisen
1 -> x               # Der Variablen x den Wert 1 zuweisen
assign("x", 1)       # Der Variablen x den Wert 1 zuweisen
x <<- 1              # Zuweisung in der Elternumgebung
str(x)               # Struktur von x
dput(x)              # Zeigt wie Objekt erzeugt werden kann
ls()                 # Liste Objekte im aktuellen Environment
rm(x)                # Objekt x entfernen
rm(list = ls())      # Alle Objekte entfernen (Workspace leeren)

getwd()              # Aktuelles Arbeitsverzeichnis anzeigen
setwd("D:/")         # Arbeitsverzeichnis setzen
source("file.R")     # R-Skript ausführen

x <- 1:3             # 1 2 3; Erzeugt eine Integer Sequenz
3:1                  # 3 2 1
seq(1, 3)            # 1 2 3; Erzeugt eine Integer Sequenz
seq(1, 6, 2)         # 1 3 5
seq(3, by=2, length.out=4) # 3 5 7 9
seq(0, by=3, along.with=x) # 0 3 6; so lange wie x
seq_along(x)         # 1 2 3
x <- integer(0)      # Vektor mit Länge 0
seq_along(x)         # integer(0)
n <- 3
seq_len(n)           # 1 2 3
n <- 0
seq_len(n)           # integer(0)
1:n                  # 1 0
rep(1:3, 2)          # 1 2 3 1 2 3; Objekt wiederholen
rep(1:3, each=2)     # 1 1 2 2 3 3
rep(1:3, 3:1)        # 1 1 1 2 2 3
1:4 + 1:2 + 1        # 3 5 5 7; Auto Wiederholung
1:4 + 1:3            # 2 4 6 5; Warnung Länge
1:3 + 1:4            # 2 4 6 5; Warnung Länge
\end{lstlisting}


\begin{lstlisting}
x <- c(2, 2, 1, 1, 3)
table(x)          # 1 2 3; Anzahlen
                  # 2 2 1
stem(x)           # stem-and-leaf plot
summary(x)        # Min. 1st Qu. Median Mean 3rd Qu. Max.
range(x)          # 1 3; kleinster und größter Wert
which.max(x)      # 5; Index des ersten größten Wertes
which.min(x)      # 3; Index des ersten kleinsten Wertes
rle(x)            # lengths: int [1:3] 2 2 1;Run Length Encoding
                  # values : num [1:3] 2 1 3
g <- c("A", "A", "C", "B", "B")
ave(x, g)         # Gruppenmittel für jedes Element
tapply(x, g, mean) # Mittel je Gruppe
s <- split(x, g)  # Teil x in Liste grupiert mit g
lapply(s, mean)   # Mittel je Gruppe
match(x, c(3,1,3))# NA NA  2  2  1; Position erster Treffer
x %in% 1:2        # TRUE  TRUE  TRUE  TRUE FALSE
findInterval(x, c(0,2)) # 2 2 1 1 2;
pmin(x, 2)        # 2 2 1 1 2
pmin(x, 0:4)      # 0 1 1 1 3
pmax(x, 0:4)      # 2 2 2 3 4

x <- c(1,2,3,4)
y <- c(3,4,5,6)
union(x, y)       # 1 2 3 4 5 6; Vereinigung
intersect(x, y)   # 3 4;         Schnittmenge
setdiff(x, y)     # 1 2; Elemente in x, aber nicht in y
setdiff(y, x)     # 5 6; Elemente in y, aber nicht in x
setequal(x, y)    # FALSE; # Mengen gleich?
setequal(x, 4:1)  # TRUE
\end{lstlisting}


\subsection{Vektor}

Das folgende Beispiel zeigt grundlegende Operationen mit Vektoren in
R, einschließlich Erstellen, Indexieren, Sortieren, Gruppieren und
Mengenoperationen.

\begin{lstlisting}
x <- 1:3          # 1 2 3; Integer
x[2] <- 4         # 1 4 3; zweites Element ändern, Int->Numeric
x[2:3] <- 5:6     # 1 5 6
x[x>1] <- 2       # 1 2 2; Alle >1 auf 2 ändern
x[5] <- 5         # 1 2 2 NA 5; Element hinterm Ende einfügen
x <- c(x, 6)      # 1 2 2 NA 5 6; Element anhängen
append(x, 7, 3)   # 1 2 2 7 NA 5 6; nach Position 3 einfügen
x <- tail(x, 4)   # 2 NA 5 6; Letzten 4 Elemente behalten
x <- head(x, 3)   # 2 NA 5; Ersten 3 Elemente behalten
x <- x[-2]        # 2 5; entfernt zweites Element
x <- rev(x)       # 5 2; Reihung umkehren
i <- order(x)     # 2 1; Index mit dem x sortiert ist
order(c(1,2,1))   # 1 3 2
rank(c(1,2,1))    # 1.5 3.0 1.5
x[i]              # 2 5
is.unsorted(x)    # TRUE
is.unsorted(x[i]) # FALSE
x <- sort(x)      # 2 5
x <- x + 1        # 3 6; Alle um 1 erhöhen
x[2] <- "a"       # "3" "a"; Umwandlung in Char
as.numeric(c("1", "2")) # 1 2; explizite Umwandlung

x <- c(2, 2, 1, 1, 3)
unique(x)         # 2 1 3
duplicated(x)     # FALSE TRUE FALSE TRUE FALSE
table(x)          # 1 2 3; Anzahlen
                  # 2 2 1
stem(x)           # stem-and-leaf plot
summary(x)        # Min. 1st Qu. Median Mean 3rd Qu. Max.
range(x)          # 1 3; kleinster und größter Wert
length(x)         # 5; Anzahl Elemente
which.max(x)      # 5; Index des ersten größten Wertes
which.min(x)      # 3; Index des ersten kleinsten Wertes
rle(x)            # lengths: int [1:3] 2 2 1;Run Length Encoding
                  # values : num [1:3] 2 1 3
g <- c("A", "A", "C", "B", "B")
ave(x, g)         # Gruppenmittel für jedes Element
tapply(x, g, mean) # Mittel je Gruppe
s <- split(x, g)  # Teil x in Liste grupiert mit g
lapply(s, mean)   # Mittel je Gruppe
match(x, c(3,1,3))# NA NA  2  2  1; Position erster Treffer
x %in% 1:2        # TRUE  TRUE  TRUE  TRUE FALSE
findInterval(x, c(0,2)) # 2 2 1 1 2;
pmin(x, 2)        # 2 2 1 1 2
pmin(x, 0:4)      # 0 1 1 1 3
pmax(x, 0:4)      # 2 2 2 3 4

x <- c(1,2,3,4)
y <- c(3,4,5,6)
union(x, y)       # 1 2 3 4 5 6; Vereinigung
intersect(x, y)   # 3 4;         Schnittmenge
setdiff(x, y)     # 1 2; Elemente in x, aber nicht in y
setdiff(y, x)     # 5 6; Elemente in y, aber nicht in x
setequal(x, y)    # FALSE; # Mengen gleich?
setequal(x, 4:1)  # TRUE
\end{lstlisting}



\section{Subsetting (Teilmengen)}

In R werden Elemente von Datenstrukturen mit Hilfe von Subsetting ausgewählt. Die gebräuchlichsten Subsetting-Operatoren sind \lstinline|[ ]|, \lstinline|[[ ]]| und \lstinline|$|. Subsetting kann mit numerischen Indizes, logischen Vektoren oder Namen erfolgen.

\lstinline|[ ]| gibt immer ein Objekt des gleichen Typs zurück (z.\,B. Liste, data.frame), sofern \lstinline|drop=FALSE| gesetzt ist, \lstinline|[[ ]]| extrahiert ein einzelnes Element.

\begin{lstlisting}[language=R]
v <- c(a=10, b=20, c=30, d=40, e=50)
v[2]             # 20; Element an Position 2
v[[2]]           # 20
v[1:3]           # 10 20 30; Element 1 bis 3
v[3:1]           # 30 20 10; Element 3 bis 1
v[c(1,3,5)]      # 10 30 50; Mehrere Elemente
v[c(1,1)]        # 10 10; Mehrfach gleiches Element
v[-c(2,4)]       # 10 30 50; Alle außer Position 2 und 4: 
v["c"]           # 30; Über Namen
#v$c             ## Fehler
v[6]             # NA
#v[[6]]          ## Fehler, Indizierung außerhalb
v[c(TRUE,FALSE,TRUE,FALSE,TRUE)] # 10 30 50; Logisch
v[c(TRUE,FALSE)] # 10 30 50; Wird automatisch wiederholt
v[v>30]          # 40 50; Logisch
v[!v>30]         # 10 20 30; ! (not)
v[which(v>30)]   # 40 50; Über Position
v[-which(v>30)]  # 10 20 30
v[-which(v>50)]  # Nichts!
v                # Ganzer Vektor
v[]              # Ganzer Vektor
v[0]             # Nichts
v[-0]            # Nichts
v[NULL]          # Nichts
v[integer(0)]    # Nichts


e <- new.env()
e$a <- 1
assign("b", 2, envir = e)
e$a                  # 1
e$b                  # 2
e[["a"]]             # 1
#e[[1]]              ## Fehler
#e["a"]              ## Fehler
e[["c"]]             # NULL
get("a", envir = e)  # 1; Sucht auch in Parrent
rm(b, envir = e)     # Löscht Element b
ls(e)                # "a"; Listet Elemente von e
\end{lstlisting}

%Ich habe in R ein data.frame d und möchte dort vom Spalte 2 die Elemente 2 und 1 abfragen, was mit "d[[2]][2:1]" geht. Warum geht "d[[2:1, 2]]" nicht?

%d <- data.frame(a=c("d","e"), b=2:1)
%d[[2]][2:1]
%d[[2:1, 2]]  # Fehler


Faktor
\paragraph{Häufigkeiten und Tabellen}

\begin{lstlisting}[language=R]
f <- factor(c("b","a","b","c","a"))
x <- table(f)            # a b c; Häufigkeiten pro Level
                         # 2 2 1
summary(f)               # 2 2 1
addmargins(x)            # 2 2 1 5
proportions(x)           # 0.4 0.4 0.2
\end{lstlisting}

Kombination mehrerer Faktoren. Mehrdimensionale Tabellen und Aggregation;

\begin{lstlisting}[language=R]
f1 <- factor(c("A","A","B","B"))
f2 <- factor(c("X","Y","X","X"))
f12 <- interaction(f1, f2) # Kombinieren
f12                      # A.X A.Y B.X B.X
levels(f12)              # "A.X" "B.X" "A.Y" "B.Y"
f12 <- interaction(f1, f2, drop=TRUE) # Nur vorhandene Kombis
levels(f12)              # "A.X" "B.X" "A.Y"

f3 <- factor(c("1","1","2","2"))
table(f1, f2, f3)        # 3D Tabelle
ftable(f1, f2, f3)       # 2D Tabelle
x <- c(1.3, 2.4, 0.2, 1.1)
xtabs(x ~ f1 + f2, data.frame(x, f1, f2)) # Summiert x je Gruppe
\end{lstlisting}


Elemente können gefiltert und sortiert werden:

\begin{lstlisting}
l <- list(c=1:3, b="x", a=4)
Filter(is.numeric, l)   # Nur numerische Elemente
l[order(names(l))]      # Nach Namen Sortieren
l[rev(seq_along(l))]    # Umkehren der Liste
names(l) <- toupper(names(l)) # Namen ändern
\end{lstlisting}


%%% Einarbeiten %%%

\fi


\end{document}


