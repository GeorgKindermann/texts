\documentclass[10pt,twocolumn]{scrartcl}

\usepackage{microtype}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

\usepackage{textcomp}
\usepackage{newpxtext}
\usepackage{newpxmath}
\usepackage[scaled=0.75]{beramono}

\usepackage{xpatch}
\usepackage{xcolor}
\usepackage{realboxes}
\definecolor{mygray}{rgb}{0.9,0.9,0.9}

\usepackage{listings}
%\lstdefinelanguage{commentonly}{
%  morecomment=[l]{\#},
%  sensitive=true,
%}
\lstset{literate=%
{Ö}{{\"O}}1
{Ä}{{\"A}}1
{Ü}{{\"U}}1
{ß}{{\ss}}1
{ü}{{\"u}}1
{ä}{{\"a}}1
{ö}{{\"o}}1
{²}{{$^2$}}1
{├}{{|}}1
{─}{{-}}1
{└}{{L}}1
{│}{{|}}1
,basicstyle=\ttfamily%\small
,backgroundcolor=\color{mygray}
,commentstyle=\emph
%,language=commentonly
,language=R
,stringstyle=\emph %\color{red!50!black}
,upquote=true
,aboveskip=0pt
,belowskip=0pt
}
\makeatletter
\xpretocmd\lstinline
  {%
   \bgroup\fboxsep=1.5pt
   \Colorbox{mygray}\bgroup\kern-\fboxsep\vphantom{\ttfamily\char`\\y}%
   \appto\lst@DeInit{\kern-\fboxsep\egroup\egroup}%
  }{}{}
\makeatother

\usepackage{enumitem}
\setlist{nosep}

\usepackage{adjustbox}
\usepackage[a4paper, margin=1mm, includefoot, footskip=15pt]{geometry}

\usepackage[pdftitle={Grundlagen der Statistiksprache R}
, pdfauthor={Georg Kindermann}
, pdfsubject={R}
, pdfkeywords={R, Lang, Progammiersprache, Tutorial, Einführung, German,
               Deutsch}
, pdflang={de-AT-1996}
, colorlinks=true
, linkcolor=blue
, urlcolor=blue
, pdfpagemode=UseNone]{hyperref}

\nonfrenchspacing
\sloppy

\title{Grundlagen der Statistiksprache R}
\author{Georg Kindermann}
%\date{19. Juni 2023}

\begin{document}

\maketitle

%\begin{abstract}
%  Eine kurze Beispielorientierte Einführung in die Statistiksprache R.
%\end{abstract}

\tableofcontents
\smallskip
%\hrule
\noindent
\href{https://www.r-project.org/}{R} kann vorkompiliert vom
\href{https://cran.r-project.org/}{CRAN} (The Comprehensive R Archive
Network) als \href{https://cran.r-project.org/bin/}{Binärdatei} für
das entsprechende Betriebssystem heruntergeladen werden.

Alternativ kann der
\href{https://cran.r-project.org/src/base/R-4/}{Quellcode}
heruntergeladen und lokal kompiliert werden. Unter Linux kann dies
z.B. so erfolgen, wobei die \lstinline|export|-Zeilen und
\lstinline|./configure|-Flags optional sind. Sie dienen der
Geschwindigkeit und besseren Debug-Möglichkeiten:

\begin{lstlisting}[language=sh]
wget https://cran.r-project.org/src/base/R-latest.tar.xz
mkdir R-latest
tar -xf R-latest.tar.xz -C R-latest --strip-components=1
cd R-latest
export CFLAGS="-O3 -march=native -mtune=native -pipe \
 -flto=auto -fwrapv"
export CXXFLAGS="$CFLAGS"
export FFLAGS="-O3 -march=native -mtune=native -pipe \
 -flto=auto -fallow-argument-mismatch"
export FCFLAGS="$FFLAGS"
export LDFLAGS="-flto=auto -Wl,-O2,--as-needed"
./configure --enable-R-shlib --with-blas --with-lapack \
 --enable-memory-profiling
# --disable-memory-profiling --disable-R-profiling # Schneller
make -j$(nproc)
sudo make install
cd ..
#rm R-latest.tar.xz
#rm -r R-latest/
\end{lstlisting}

Nach dem Start kann R interaktiv verwendet werden. Alternativ lässt
sich R auch über verschiedene IDEs (integrierte Entwicklungsumgebung)
oder Texteditoren nutzen. Die gezeigten Codeabschnitte wurden mit R
Version 4.5.2 (2025-10-31) getestet.

Wenn man R startet, kommt man in den interaktiven Modus.
Deren wichtigste Tastenkombinationen sind:
\begin{description}[style=multiline,leftmargin=2cm,nolistsep]
  \item[CTRL+d] Beendet R (EOF) (Linux/Mac)
  \item[CTRL+z] Beendet R (EOF) (Windows)
  \item[CTRL+c] Bricht laufende Berechnungen oder Eingaben ab
  \item[CTRL+l] Löscht die Konsole (nur in manchen Umgebungen)
  \item[Pfeil ↑ / ↓] Navigiert im Befehlverlauf (History)
  \item[CTRL+r] Rückwärtssuche im Befehlverlauf
  \item[Tab] Auto-Vervollständigung
\end{description}

Beim Beenden von R besteht die Möglichkeit, den Arbeitsbereich (Workspace-Image) zu speichern. Dabei werden ausschließlich die Objekte im globalen Environment, also die im Arbeitsspeicher befindlichen R-Objekte, gesichert, nicht jedoch geladene Pakete. Die vorhandenen Objekte kann man mit \lstinline|ls()| oder \lstinline|objects()| auflisten. Wird R in einem Verzeichnis gestartet, in dem eine gespeicherte Arbeitsumgebung (Datei \lstinline|.RData|) vorhanden ist, wird diese beim Start automatisch geladen. So kann man die Arbeit, nach erneutem Laden der benötigten Pakete, an dem Punkt fortsetzen, an dem man aufgehört hat.

Den Arbeitsbereich kann man jederzeit mit \lstinline|save.image()| speichern. Dabei wird standardmäßig die Datei \lstinline|.RData| erstellt, die beim nächsten Start von R im selben Verzeichnis wieder geladen wird. Alternativ kann man auch einen Dateinamen angeben, z.\,B.\ \lstinline|save.image("WSI.RData")| bzw.\ \lstinline|save.image(file = "WSI.RData")|. Diese Datei kann später mit \lstinline|load("WSI.RData")| bzw.\ \lstinline|load(file = "WSI.RData")| geladen werden. Dabei werden existierende Objekte mit gleichem Namen im aktuellen Environment überschrieben.

Für reproduzierbare Analysen empfiehlt sich der Start von R mit der Option \lstinline|--vanilla| (\lstinline|R --vanilla|). In diesem Fall werden weder Konfigurationsdateien (\lstinline|.Rprofile|, \lstinline|.Renviron| etc.) noch ein gespeichertes Workspace-Image geladen, und beim Beenden wird kein neues gespeichert.

Befehle, die in einer Datei gespeichert sind, lassen sich mit \lstinline|R -f FILE| ausführen. Ein einzelner Ausdruck kann mit \lstinline|R -e EXPR| ausgeführt werden, wobei R danach sofort beendet wird, z.,B.\ \lstinline|R -e "summary(iris)"|. In beiden Fällen wird der Arbeitsbereich beim Beenden standardmäßig nicht gespeichert. Möchte man ihn speichern, muss dies mit der Option \lstinline|--save| explizit angegeben werden, z.,B.\ \lstinline|R --save -f FILE| oder \lstinline|R --save -e "x=5"|.

Bei Verwendung von \lstinline|R -f FILE| oder \lstinline|R -e EXPR| werden standardmäßig ebenfalls Konfigurationsdateien sowie ein eventuell vorhandenes Workspace-Image geladen. Wie bereits beschrieben, kann dies durch \lstinline|--vanilla| unterdrückt werden (\lstinline|R --vanilla -f FILE|, \lstinline|R --vanilla -e EXPR|).

Einige Funktionen die teilweise beim Starten von R kurz vorgestellt werden:

\begin{lstlisting}
q()                   # Beendet R (mit Rückfrage)
help()                # Hilfe starten
help.start()          # Öffnet HTML-Hilfesystem
help(q)               # Hilfe zu Befehl q
?q                    # Hilfe zu Befehl q
demo()                # Zeigt verfügbare Demos
demo(lm)              # Demo zur linearen Regression
version               # R-Version anzeigen
sessionInfo()         # Infos zu Umgebung und geladenen Paketen
citation()            # Wie man R zitiert
\end{lstlisting}

\section{Grundlagen}

\subsection{Objekte und Namen}

In R gibt es:
\begin{description}
\item[Objekte] die eigentlichen Daten, die Platz im Arbeitsspeicher belegen.
\item[Namen] (auch \emph{Bindings}, \emph{Symbole} oder umgangssprachlich \emph{Variablen} genannt), die auf Objekte verweisen.
\end{description}
In R wird ein Name verwendet, um auf ein Objekt im Speicher zu verweisen. Diese Bindungen (Name–Objekt-Zuordnungen) werden in Umgebungen (\emph{Environments}) gespeichert. Ein Name ist nicht das Objekt selbst, sondern stellt lediglich die Verbindung zu ihm her und ermöglicht so dessen Verwendung. Mehrere Namen können gleichzeitig auf \emph{dasselbe} Objekt verweisen.

Wird ein durch mehrere Namen referenziertes Objekt über einen dieser Namen modifiziert, legt R in der Regel \emph{vor} der Modifikation eine Kopie an und lässt den modifizierenden Namen anschließend auf diese Kopie zeigen (\emph{Copy-on-Modify}-Semantik).
Sehr kleine Objekte wie \lstinline|1| werden von R intern als unveränderliche (immutable) Konstanten behandelt. Bei Bedarf wird einfach ein neues Objekt erzeugt, statt eine Kopie zu erstellen.

Ein Name kann jederzeit durch eine neue Zuweisung auf ein anderes Objekt umgebunden werden (\emph{Rebinding}).

Mit \lstinline|rm()| wird ein Name aus der aktuellen Umgebung entfernt. Objekte ohne verbleibende Referenzen werden automatisch vom \emph{Garbage Collector} gelöscht. Der Garbage Collector kann manuell mit \lstinline|gc()| aktiviert werden.

\begin{lstlisting}
1                     # Ein Objekt mit dem Wert 1
x <- 1                # Name x zeigt auf Objekt mit Inhalt 1
x                     # Zeigt den Inhalt des Objekts
get("x")              # 1; Standardweg für dynamische Namen
s <- "x"
get(s)                # 1
tracemem(x)           # Zeigt Speicher auf den x zeigt
y <- x                # y zeigt auf das gleiche Objekt wie x
tracemem(x) == tracemem(y) # TRUE
y <- 2                # y erhält ein neues Objekt mit Wert 2
tracemem(x) == tracemem(y) # FALSE

a <- 1:3                    # Zahlen 1, 2, 3
b <- a
tracemem(a) == tracemem(b)   # TRUE
b[1] <- 0L                   # jetzt wird eine Kopie angelegt
                             # Erstem Element 0 zuweisen
tracemem(a) == tracemem(b)   # FALSE
identical(a, b)              # FALSE; Inhalt unterschiedlich
a[1] <- 0L
identical(a, b)              # TRUE; Inhalte jetzt wieder gleich
tracemem(a) == tracemem(b)   # FALSE; aber verschiedene Objekte
b <- a                       # Zeigen wieder auf gleiches Objekt
tracemem(a) == tracemem(b)   # TRUE
 # Objekt auf das b zeigte wird automatisch gelöscht
\end{lstlisting}

\lstinline|tracemem()| zeigt die Speicheradresse an und meldet jedes Mal, wenn ein Objekt kopiert wird. Dies funktioniert nur, wenn R mit aktiviertem Memory-Profiling kompiliert wurde (überprüfbar mit \lstinline|capabilities("profmem")|). \lstinline|untracemem()| deaktiviert die Meldung bei Objektkopien.

Die interne Funktion \lstinline|.Internal(inspect(x))| zeigt ebenfalls die Speicheradresse sowie weitere interne Informationen, darunter die Anzahl der Namen (REF-Wert), die auf das Objekt zeigen. Sie benötigt kein Memory-Profiling.

\begin{lstlisting}
x <- 1
.Internal(inspect(x))
# @5577ec525cf8 14 REALSXP g0c1 [REF(2)] (len=1, tl=0) 1
y <- x
.Internal(inspect(x))
# @5577ec525cf8 14 REALSXP g0c1 [REF(3)] (len=1, tl=0) 1
rm(x)          # Löscht nur den Namen x, nicht das Objekt
.Internal(inspect(y))
# @5577ec525cf8 14 REALSXP g0c1 [REF(2)] (len=1, tl=0) 1
rm(y)          # Keine Referenz mehr auf Objekt
gc()           # Löst Garbage Collector per Hand aus
\end{lstlisting}

Reguläre Sequenzen (z.\,B.\ \lstinline|1:10000|) werden als \emph{Alternate Representation} (ALTREP) platzsparend gespeichert. Sie belegen erst dann den vollen Speicher, wenn sie verändert werden (Materialisierung).

\lstinline|object.size()| zeigt stets die Größe eines vollständig materialisierten Vektors, während \lstinline|lobstr::obj_size()| die tatsächliche, oft deutlich geringere Speicherbelegung ermittelt. Dazu muss jedoch erst das Paket \lstinline|lobstr| in R mit \lstinline|install.packages("lobstr")| installiert werden, wobei hier meist noch nach einem zu verwendenden Server gefragt wird.

\begin{lstlisting}
x <- 1:10000
object.size(x)       # 40048 bytes
lobstr::obj_size(x)  # 680 B
x[1] <- 0L           # Vector wird wirklich erzeugt
object.size(x)       # 40048 bytes
lobstr::obj_size(x)  # 40.05 kB
\end{lstlisting}

\lstinline|str()| zeigt einen kompakten Überblick über die Struktur eines Objekts.
\lstinline|dput()| erzeugt Code, mit dem man das Objekt rekonstruieren kann.

\begin{lstlisting}
x <- 1:3
str(x)     # int [1:3] 1 2 3
dput(x)    # 1:3
x[1] <- 0L
str(x)     # int [1:3] 0 2 3
dput(x)    # c(0L, 2L, 3L)
\end{lstlisting}

Namen werden aus Buchstaben, Ziffern, \lstinline|.| (Punkt) und \lstinline|_| (Unterstrich) gebildet. Sie sollten weder mit \_ noch mit einer Zahl anfangen und nicht zu den reservierten Wörtern gehören, die man mit \lstinline|?Reserved| ansehen kann. Namen, die nicht diesen Regeln folgen oder syntaktisch zweideutig sind, müssen mit Backticks geschrieben werden (z.\,B.\ \lstinline|`_`| oder \lstinline|`in`|).

\begin{lstlisting}
x <- 1
#_x <- 1   ## Error, unerwartetes Symbol
#1x <- 1   ## Error, unerwartetes Symbol
#in <- 1   ## Error, Unerwartete(s) 'in'
.x <- 1
#.1 <- 1   ## Error, ungültige linke Seite
`_` <- 1
`_`        # 1
"_" <- 2
`_`        # 2
'_' <- 3
`_`        # 3
`2` <- 1
`2`        # 1
`in` <- 1
`in`       # 1
`.1` <- 1
`.1`       # 1
\end{lstlisting}


\subsection{Zuweisungen}

Eine Zuweisung bindet einen Namen an ein Objekt oder ändert eine bestehende Bindung.

R kennt mehrere Syntaxvarianten:

\begin{lstlisting}
x <- 1          # Häufig verwendete Form
2 -> x          # Äquivalent zu <-
x = 3           # Ebenfalls möglich
`<-`(x, 4)      # Funktionale Form

assign("x", 5)  # Standardweg für dynamische Namen
s <- "x"
assign(s,   6)  # Bindet an Name der in s steht

eval(parse(text = paste(s, "<- 7"))) # Alternative
\end{lstlisting}

Der Operator \lstinline|=| wird außerdem verwendet, um Argumente oder Elemente zu benennen:

\begin{lstlisting}
c(x = 0)        # Erstes Element hat den Namen x
c(x <- 9)       # Zuweisung! Element hat KEINEN Namen
x               # 9
\end{lstlisting}

In R wird die Zuweisung eines Objekts zu einem Namen üblicherweise mit \lstinline|<-| vorgenommen, während für die Übergabe benannter Argumente an Funktionen immer \lstinline|=| verwendet werden muss. Der Name verweist dabei auf das Objekt, ist aber nicht das Objekt selbst. Durch die Verwendung von \lstinline|<-| wird  diese Bindung deutlich dargestellt.

Bei jedem Funktionsaufruf entsteht ein eigenes, temporäres Ausführungs-Environment, dessen Elternumgebung das Environment ist, in dem die Funktion definiert wurde.

Normale Zuweisungen mit \lstinline|<-| oder \lstinline|=| erzeugen Bindings ausschließlich im lokalen Ausführungs-Environment und verändern äußere Umgebungen nicht.

Der Super-Assignment-Operator \lstinline|<<-| (bzw.\ \lstinline|->>|) durchsucht die Elternumgebungen nach einem bestehenden Binding. 
Existiert der Name in einer dieser Umgebungen, wird das Binding dort geändert. 
Wird der Name nicht gefunden, wird er im \lstinline|.GlobalEnv| angelegt oder eine dort bereits bestehende Bindung aktualisiert, unabhängig davon, ob das \lstinline|.GlobalEnv| auf dem Suchpfad der aktuellen Umgebung liegt.
Im lokalen Ausführungs-Environment wird dabei nie eine vorhandene Bindung verändert und auch keine neue angelegt.

\begin{lstlisting}
i <- 1
j <- 2
f <- function() {    # Erzeugt eine Funktion
  i <-  30    # Neues lokales i (verdeckt in f globales)
  j <-  0
  j <<- 40    # Findet und überschreibt das globale
  cat(j)
  k <-  50    # Nur lokal
  l <<- 60 }  # Wird global angelegt
f()           # 0; Ruft Funktion auf
i   # 1
j   # 40
#k  ## Error, nicht gefunden
l   # 60
\end{lstlisting}

Bindungen können mit \lstinline|lockBinding()| gesperrt und mit \lstinline|unlockBinding()| wieder entsperrt werden.

\begin{lstlisting}
x <- 0
lockBinding("x", globalenv())  # Sperren
#x <- 1                        ## Error, gesperrt
unlockBinding("x", globalenv())
x <- 2
lockBinding("x", globalenv())
rm(x)                          # Geht
\end{lstlisting}


\subsection{Environment (Umgebung)}

Ein Environment kann man sich wie ein Blatt Papier vorstellen, auf dem Name--Adresse--Paare stehen.
Das Environment selbst ist ebenfalls ein Objekt und kann über einen Namen referenziert werden. Jedes Environment enthält (als Speicheradresse) einen Verweis auf das nächste Blatt (\emph{Parent Environment}), in dem weitergesucht wird, falls ein Name auf diesem Blatt nicht gefunden wird (\emph{Lexical Scoping}).
Jedes Environment hat genau ein Parent. R erzwingt strikt, dass diese Parent-Kette hierarchisch und nicht zyklisch ist. Es kann jedoch mehrere voneinander unabhängige Parent-Ketten geben.
Das Parent eines Environments kann, mit Ausnahme des leeren Environments, auf ein anderes Environment gesetzt werden, solange dadurch keine zyklische Struktur entsteht.
Jede Parent-Kette endet im leeren Environment (\lstinline|emptyenv()|).
\lstinline|environment()| gibt das aktuelle Environment zurück (in interaktiven Sitzungen meist das GlobalEnv, in Funktionen das Funktionsenvironment).
\lstinline|new.env()| erzeugt ein neues Environment,
\lstinline|parent.env()| zeigt das Elternenvironment.

\begin{lstlisting}
environment()     # <environment: R_GlobalEnv>
e <- new.env()    # Erzeugt neues Environment und bindet es an e
e                 # <environment: 0x55b8959188f8>; Adresse
parent.env(e)     # <environment: R_GlobalEnv>;Elternenvironment
#get("x", e)      ## Error, x nicht gefunden
exists("x", e)    # FALSE
x <- 0
get("x", e)       # 0; findet x im globalEnv
#get("x", e, inherits = FALSE) ## Error, x nicht gefunden
get0("x", e, inherits = FALSE) # NULL; NULL weil nicht gefunden
exists("x", e, inherits = FALSE) # FALSE
e[["x"]]          # NULL; Sucht x nur in e
e$x               # NULL; Sucht x nur in e
e$x <- 1          # e enthält nun x
#assign("x", 1, e) # Alternative
get("x", e)       # 1; findet x in e
e[["x"]]          # 1
e$x               # 1
y <- 0
get("y", e)       # 0; findet y im globalEnv
parent.env(e) <- emptyenv() # Neues Parent Environment
#get("y", e)      ## Error, y nicht gefunden
#parent.env(e) <- e  ## Error, zyklisch Kette
ls(e)             # "x"; Zeigt Namen in e

e <- new.env(parent = emptyenv()) # Parent angegeben
e$x               # NULL

e <- emptyenv()
e                 # <environment: R_EmptyEnv>
#parent.env(e)    ## Error, hat keinen Parent
#parent.env(e) <- emptyenv() ## Error, emptyEnv hat kein Parent
e$x               # NULL
e$x <- 2          # Error, leere Umgebung
\end{lstlisting}

Ein Environment kann Namen enthalten, die auf andere Environments zeigen.
Namen innerhalb eines Environments können auch wieder auf dasselbe Environment verweisen und dadurch zyklische Referenzen bilden.

\begin{lstlisting}
e <- new.env()
e$x <- 1          # e enthält nun x  
e$e <- e          # e zeigt auf sich selbst
e$e$x             # 1
e$e$e$x           # 1
e$e$e$e$x         # 1
e$eb <- e         # e zeigt mit weiteren Namen auf sich selbst
e$eb$x            # 1
e$eb$e$eb$x       # 1
e$x <- 2
e$eb$e$eb$x       # 2
\end{lstlisting}

Innerhalb eines Environments kann die Namenssuche mittels Hash-Lookup erfolgen, also über einen schnellen Schlüsselindex.

\begin{lstlisting}
e1 <- new.env()
e2 <- new.env(hash = FALSE) # Nicht mit Hash suchen
env.profile(e1)             # Info zur Hash Suche
env.profile(e2)             # NULL; keine Hash Suche
lobstr::obj_size(e1)        # 336 B
lobstr::obj_size(e2)        #  56 B
\end{lstlisting}

Funktionen suchen Namen weder entlang der Environment-Kette ihres Aufrufortes noch entlang der Environment-Kette, in der der Funktionsname gebunden ist, sondern entlang der Environment-Kette ihres \emph{Enclosing Environments}.

\begin{lstlisting}
e1 <- new.env()
e1$x <- 1
e2 <- new.env(parent = e1)
# Funktionen können mit function() oder \() erzeugt werden
e2$f1 <- \() x            # enclosing environment: GlobalEnv
environment(e2$f1)        # R_GlobalEnv
#e2$f1()                  ## Fehler, 'x' nicht gefunden
environment(e2$f1) <- e1  # setzt e1 als enclosing environment
e2$f1()                   # 1
e2$f2 <- with(e2, \() x)  # enclosing environment: e2
e2$f2()                   # 1
e2$x <- 2
e2$f1()                   # 1; Beginnt suche in e1
e2$f2()                   # 2; Beginnt suche in e2

x <- 1
f1 <- \() x <- 2
f1()          # f1 verändert sein lokales x
x             # 1
f2 <- \() x <<- 2
f2()          # f2 verändert Eltern x
x             # 2
#z            ## Fehler 'z' nicht gefunden
f3 <- \() z <<- 3
environment(f3) <- baseenv()
parent.env(environment(f3)) # <environment: R_EmptyEnv>
f3()          # f3 legt z im Global-Environment an
z             # 3

f <- \() x <- 0
environment(f) <- emptyenv()
#f()          ## Fehler Funkion "<-" nicht gefunden
\end{lstlisting}

Das Enclosing Environment einer Funktion aus einem Package ist ein \emph{Namespace-Environment}. Dieses Environment und seine Bindungen sind unveränderlich. Wenn man versucht, das Enclosing Environment einer Paketfunktion zu ändern, wird nicht das Original verändert, sondern es wird eine Kopie der Funktion im aufrufenden Environment angelegt, solange dieses modifizierbar ist.

\begin{lstlisting}
environment(sd)    # <environment: namespace:stats>
e1 <- new.env()
e2 <- new.env()
with(e1, environment(sd) <- e2)
environment(sd)    # <environment: namespace:stats>
environment(e1$sd) # <environment: 0x55a8d83c7308>
e2                 # <environment: 0x55a8d83c7308>
#with(baseenv(), environment(sd) <- baseenv()) ## Error
e1$sd(1:3)         # 1
environment(e1$sd) <- emptyenv()
#e1$sd(1:3)        ## Error, findet sqrt nicht
\end{lstlisting}

Bei Funktionen kann man folgende Environments unterscheiden:

\begin{description}
  \item[Binding Environment:] Das Environment, in dem der Funktionsname gebunden ist (wo der Name gefunden wird). Ein Funktionsobjekt kann unter mehreren Namen in verschiedenen Environments gebunden sein. Das Binding Environment spielt für die spätere Namenssuche innerhalb der Funktion keine Rolle.
  \item[Enclosing Environment:] Das Environment, in dem das Funktionsobjekt ursprünglich erzeugt wurde, welches jedoch nachträglich geändert werden kann. Dieses Environment bestimmt die Environment-Kette, entlang der die Funktion nach Namen sucht. 
  \item[Local Environment (Execution Environment):] Das bei jedem Funktionsaufruf neu erzeugte Environment, in dem lokale Variablen entstehen.
  \item[Calling Environment (Parent Frame):] Das Environment, aus dem die Funktion aufgerufen wurde. R sucht dort die Werte der Objekte, die als Argumente an die Funktion übergeben werden. Bevor die Ausführung der Funktion beginnt, werden die Argumente (sofern nicht lazy) im Calling Environment ausgewertet und die resultierenden Werte im Local Environment den formalen Parametern zugewiesen.
\end{description}

Abweichend von der standardmäßigen lexikalischen Namenssuche kann man auch im dynamischen Aufrufer-Environment (Call-Stack) nach Variablen suchen, z.\,B.\ mit \lstinline|dynGet|. 
Beim Einsatz von \lstinline|dynGet| in verschachtelten Funktionsaufrufen können jedoch Konflikte mit der Lazy Evaluation (Promises) auftreten. 
Alternativ empfiehlt es sich, Variablen explizit als Funktionsargumente zu übergeben, da dies robust, nachvollziehbar und klar ist.

\begin{lstlisting}
x <- -1
f1 <- \() {x <- 1; f3(x)}
f2 <- \() {x <- 2; f3(x)}
f3 <- \(y=3) f4(y)
f4 <- \(y=4) list(y,
  x,                     # Suche im enclosing environment
  dynGet("x", 0),        # Suche im Aufruf-Stack
# Suche im Aufruf-Stack mit Vererbung
  dynGet("x", 0, inherits = TRUE),
  get0("x", envir = parent.frame()), # Suche im Aufrufer-Frame
# Suche nur im Parent-Frame
  get0("x", envir = parent.frame(), inherits = FALSE)
)
f1()                     #  1, -1, 1, -1, -1, NULL
f2()                     #  2, -1, 2, -1, -1, NULL
f3()                     #  3, -1, 0, -1, -1, NULL
f4(x)                    # -1, -1, 0, -1, -1, -1
f4()                     #  4, -1, 0, -1, -1, -1
with(list(x = 5), f4(x)) #  5, -1, 5, -1,  5,  5
\end{lstlisting}

Im Gegensatz zu einer Liste ist ein Environment referenzbasiert (Environments werden gewöhnlich nicht kopiert), besitzt keine feste Reihenfolge seiner Elemente und verfügt stets über ein Parent-Environment. Mit \lstinline|rlang::env_clone()| kann man ein Environment kopieren.

\begin{lstlisting}[language=R]
e1 <- new.env()
e1$a <- 1
e2 <- e1      # e2 zeigt auf e1
e2$a <- 2     # ohne copy on modify
e1$a          # 2
e1[["a"]]     # 2

e3 <- rlang::env_clone(e1, parent.env(e1))
e3$a          # 2
e3$a <- 3
e3$a          # 3
e1$a          # 2

# Geht nicht für unevaluated promises
e4 <- as.environment(as.list(e1, all.names=TRUE))
e4$a          # 2
e4$a <- 3
e4$a          # 3
e1$a          # 2

x <- list(a = 1)
y <- x        # y zeigt auf x
y$a <- 2      #  mit copy on modify
x$a           # 1
\end{lstlisting}

Mann kann Environments mit \lstinline|lockEnvironment()| gegen Änderungen sperren. Diese Sperre kann nicht deaktiviert werden. Es können auch die Bindungen gesperrt werden, welche wieder entsperrt werden können.

\begin{lstlisting}
e <- new.env()
e$x <- 0
lockEnvironment(e)
#e$y <- 1    ## Error, nicht hinzufügbar
e$x <- 2     # Jedoch Bindung veränderbar
lockEnvironment(e, TRUE)  # Sperrt auch Bindungen
#e$x <- 3    ## Error, nicht änderbar
unlockBinding("x", e)
e$x <- 4
\end{lstlisting}

Bei Start von R gibt es folgende Environments:

\begin{lstlisting}
search()
# ".GlobalEnv"        "package:stats"     "package:graphics" 
# "package:grDevices" "package:utils"     "package:datasets" 
# "package:methods"   "Autoloads"         "package:base"     
\end{lstlisting}

Wenn ein Paket mit \lstinline|library| oder \lstinline|require| geladen wird, erscheint es standardmäßig direkt hinter \lstinline|.GlobalEnv| im Suchpfad, sofern es nicht bereits geladen ist. 
\lstinline|require| gibt \lstinline|FALSE| zurück, wenn das Paket fehlt, während \lstinline|library| einen Fehler auslöst.

Mit \lstinline|library(pkg, pos = ...)| lässt sich die Einfügeposition gezielt steuern. 
Ein Paket kann dabei weder vor \lstinline|.GlobalEnv| noch hinter \lstinline|package:base| platziert werden. 
Die Position im Suchpfad ist entscheidend, da Variablen und Funktionen in dieser Reihenfolge durchsucht werden. 
Dies ist relevant, wenn mehrere Pakete Objekte mit demselben Namen bereitstellen. Es wird stets das zuerst gefundene Objekt verwendet.

\begin{lstlisting}
library(compiler)
search() # ".GlobalEnv" "package:compiler" "package:stats"
library(tools)
search() # ".GlobalEnv" "package:tools" "package:compiler"
library(compiler)
search() # ".GlobalEnv" "package:tools" "package:compiler"
unloadNamespace("compiler")  # Entlädt Paket
#detach("package:compiler", unload = TRUE) # Alternative
library(compiler)
search() # ".GlobalEnv" "package:compiler" "package:tools"
unloadNamespace("compiler")
library(compiler, pos = length(search())) # vor base
search() # ".GlobalEnv" ... "package:compiler" "package:base"
\end{lstlisting}

Mir \lstinline|attach()| kann man auch eigene Environments in diesen Suchpfad bringen und mit \lstinline|detach()| wieder entfernen.

\begin{lstlisting}
e <- new.env()
e$x <- 0
#x              ## Error, nicht gefunden
attach(e, name = "meinEnv")
x               # 0
search()        # ".GlobalEnv" "meinEnv" ...
detach("meinEnv")
attach(e, pos = length(search()), name = "meinEnv")
search() # ".GlobalEnv" ... "meinEnv" "package:base"

as.environment("meinEnv")$x  # 0; Zugriff über Namen
\end{lstlisting}


%%% NEU %%%

\subsection{Funktionen: Closures aus Code und Environment}


\subsection{Pakete -- Libraries}

\begin{lstlisting}
base::
base:::
 ls(getNamespace("stats"), all.names = TRUE)
\end{lstlisting}

\begin{lstlisting}
# Temporäres Package-Verzeichnis anlegen
pkg_dir <- tempfile("meinPkg")
dir.create(file.path(pkg_dir, "R"), recursive = TRUE)

# Eine minimale DESCRIPTION und NAMESPACE-Datei
writeLines('Package: meinPkg
Version: 0.0.1
Title: Test
Description: Nur zum Testen
License: GPL-3
LazyData: true', file.path(pkg_dir, "DESCRIPTION"))

writeLines('export(x)', file.path(pkg_dir, "NAMESPACE"))

# Eine R-Datei mit Inhalt
writeLines('x <- 42
.mein_intern <- 100', file.path(pkg_dir, "R", "stuff.R"))

# Package bauen und laden
devtools::install(pkg_dir, quiet = TRUE, upgrade = "never")
# oder: pkgbuild::build(pkg_dir); install.packages(...)

library(meinPkg)

meinPkg::x      # exportiert 42
meinPkg:::x     # auch 42
meinPkg:::.mein_intern  # nicht exportiert 100 (funktioniert!)
\end{lstlisting}


\subsection{Funktionen: Closures aus Code und Environment}

x <- 0
f1 <- function(x = x) x
f2 <- function(x. = x) x.
%#f1()     ## Error, rekursiv
%f2()      # 0
%f1(x)     # 0
%f2(x)     # 0
%https://stackoverflow.com/questions/4357101
%The reason you can't use x=x in the formal arguments of a function definition is that it first looks up the default argument within the function itself so using that form is telling it to use itself as the default but it has not been defined so that makes no sense and we get an error.)

%makeActiveBinding("rnd", \(n=1) cat(runif(n)), globalenv())
%rnd
%rnd <- 3




Eine Funktion in R besteht aus drei Teilen:
\begin{itemize}
\item dem formalen Argument-Objekt
\item dem Funktionskörper (body)
\item dem Environment, in dem die Funktion erzeugt wurde
\end{itemize}

\begin{lstlisting}[language=R]
f <- function(x) x + y     # y wird erst beim Aufruf gesucht

y <- 100
f(10)                      # 110  (findet y im globalen Environment)

g <- function() {
  y <- 1
  f(10)                    # immer noch 110! (f schaut ins Erzeugungs-Environment)
}

environment(f)             # <environment: R_GlobalEnv>
\end{lstlisting}

Jeder Funktionsaufruf erzeugt ein neues, temporäres Environment als Kind des Erzeugungs-Environments der Funktion.

Deshalb:
\begin{itemize}
\item \lstinline|x <- x + 1| in einer Schleife verändert nie das äußere x
\item \lstinline|<<-| sucht nach oben bis ins Parent-Environment der Funktion
\item Funktionen merken sich die Werte ihrer freien Variablen (Closure!)
\end{itemize}

\subsection{Call-by-Promise (Lazy Evaluation)}

Argumente einer Funktion werden nicht sofort ausgewertet, sondern als Promise-Objekte gespeichert (bestehend aus Ausdruck + Environment).

\begin{lstlisting}[language=R]
f <- function(x) { print("wird erst später ausgewertet") ; x }
f( { Sys.sleep(5) ; 1:1000000 } )   # keine 5 Sekunden Wartezeit!
# "wird erst später ausgewertet"
# erst jetzt wird der Ausdruck ausgewertet
\end{lstlisting}

Folgen:
- Default-Argumente sehen das Environment der Funktion, nicht das des Aufrufs
- Seiteneffekte in Argumenten passieren erst, wenn das Argument benutzt wird
- \lstinline|missing(x)| funktioniert

\subsection{Maskierung (Shadowing)}

Ein Name im lokalen Environment verdeckt gleichnamige Namen weiter oben in der Kette.

\begin{lstlisting}[language=R]
x <- 1
g <- function() { x <- 20 ; x }   # lokale 20 maskiert globale 1
g()                               # 20
x                                 # noch immer 1
\end{lstlisting}

\subsection{Lexical Scoping}

Die Suche nach freien Variablen erfolgt im Environment, in dem die Funktion definiert wurde – nicht dort, wo sie aufgerufen wird.

\begin{lstlisting}[language=R]
make_adder <- function(n) {
  function(x) x + n               # n ist frei => wird im Erzeugungs-Env gesucht
}

add5  <- make_adder(5)
add10 <- make_adder(10)

add5(3)   # 8
add10(3)  # 13

# <<- sucht ab dem Parent-Environment der Funktion nach oben
counter <- function() {
  if (!exists("i")) i <- 0
  i <<- i + 1
  i
}
counter()   # 1
counter()   # 2
\end{lstlisting}

%%% NEU %%%

\begin{lstlisting}
q()                   # Beendet R (mit Rückfrage)
#                     # Kommentar bis Zeilenende
help()                # Hilfe starten
help(q)               # Hilfe zu Befehl q
?q                    # Hilfe zu Befehl q
#?for                 ## funktioniert nicht
?"for"                # Hilfe zur for-Schleife
#help(for)            ## erzeugt Fehler
help("for")           # Hilfe zur for-Schleife
??reg                 # Sucht nach "reg" in allen Hilfetexten
help.search("reg")    # Wie ??reg, aber als Funktion
help.start()          # Öffnet HTML-Hilfesystem
library(help = "stats")  # Hilfeübersicht zum Paket "stats"
args(lm)              # Argumente der Funktion lm
methods("plot")       # Methoden für generische Funktion plot
methods(class = "lm") # Methoden für Objekte der Klasse "lm"
getAnywhere("simpleLoess")#Zeigt auch nicht exportierte Funktion
example(lm)           # Führt Beispiele zu lm aus
demo()                # Zeigt verfügbare Demos
demo(lm)              # Demo zur linearen Regression

install.packages("lme4") # Installiert das Paket
update.packages()    # Aktualisiert Pakete
remove.packages()    # Entfernt Paket
installed.packages() # Zeigt alle installierten Pakete
library(lme4)        # Paket laden
require(lme4)        # Alternative, gibt bei Fehler FALSE zurück
search()             # Zeigt geladene Pakete und Umgebungen
vignette()           # Verfügbare Vignetten anzeigen
vignette("lmer")     # Einführung zu lmer öffnen

version              # R-Version anzeigen
sessionInfo()        # Infos zu Umgebung und geladenen Paketen
citation()           # Wie man R zitiert
x = 1                # Der Variablen x den Wert 1 zuweisen
x <- 1               # Der Variablen x den Wert 1 zuweisen
1 -> x               # Der Variablen x den Wert 1 zuweisen
assign("x", 1)       # Der Variablen x den Wert 1 zuweisen
x <<- 1              # Zuweisung in der Elternumgebung
str(x)               # Struktur von x
dput(x)              # Zeigt wie Objekt erzeugt werden kann
ls()                 # Liste Objekte im aktuellen Environment
rm(x)                # Objekt x entfernen
rm(list = ls())      # Alle Objekte entfernen (Workspace leeren)

getwd()              # Aktuelles Arbeitsverzeichnis anzeigen
setwd("D:/")         # Arbeitsverzeichnis setzen
source("file.R")     # R-Skript ausführen

x <- 1:3             # 1 2 3; Erzeugt eine Integer Sequenz
3:1                  # 3 2 1
seq(1, 3)            # 1 2 3; Erzeugt eine Integer Sequenz
seq(1, 6, 2)         # 1 3 5
seq(3, by=2, length.out=4) # 3 5 7 9
seq(0, by=3, along.with=x) # 0 3 6; so lange wie x
seq_along(x)         # 1 2 3
x <- integer(0)      # Vektor mit Länge 0
seq_along(x)         # integer(0)
n <- 3
seq_len(n)           # 1 2 3
n <- 0
seq_len(n)           # integer(0)
1:n                  # 1 0
rep(1:3, 2)          # 1 2 3 1 2 3; Objekt wiederholen
rep(1:3, each=2)     # 1 1 2 2 3 3
rep(1:3, 3:1)        # 1 1 1 2 2 3
1:4 + 1:2 + 1        # 3 5 5 7; Auto Wiederholung
1:4 + 1:3            # 2 4 6 5; Warnung Länge
1:3 + 1:4            # 2 4 6 5; Warnung Länge
\end{lstlisting}

%%% Einarbeiten %%%

%%% Copy-on-Modify für Listen %%%

\section{Grundtypen}

Mit \lstinline|typeof(x)| kann der Typ von \lstinline|x| in R bestimmt werden.
R verwendet dynamische Typisierung, d.\,h. der Typ wird zur Laufzeit zugewiesen.
R kennt keinen eigenen Zeichentyp (char); einzelne Zeichen werden als Zeichenketten (Strings) der Länge 1 behandelt.

\begin{lstlisting}[language=R]
1              # Double
1L             # Integer (standardmäßig 32 Bit)
1.0            # Double
0x2a           # 42, Double (hexadezimal)
0x2aL          # 42, Integer (hexadezimal)
TRUE           # Boolean
FALSE          # Boolean
'abc'          # String
"abc"          # String
as.raw(97)     # Raw (Byte)
as.raw(0x61)   # Raw
charToRaw("a") # 61; Raw
\end{lstlisting}

Mit \lstinline|as.T(x)| wird ein Wert \lstinline|x| in den Typ \lstinline|T| konvertiert. R prüft dabei nicht streng auf Genauigkeit, sondern führt die Konvertierung stillschweigend durch.

\begin{lstlisting}[language=R]
as.integer(1)     # Wandelt Double in Integer
as.integer(1.0)   # Wandelt Double in Integer
as.integer(1.8)   # wird abgeschnitten => 1
floor(1.3)        # Abrunden  => 1 Double
ceiling(1.3)      # Aufrunden => 2 Double
round(1.3)        # Runden    => 1 Double
\end{lstlisting}

R kennt spezielle Werte für fehlende, ungültige oder unendliche Zahlen. Sie sind typabhängig und verhalten sich in Berechnungen wie reguläre Werte ihres jeweiligen Typs.

\begin{lstlisting}[language=R]
NA                        # Fehlender Wert vom Typ logical
NA_integer_               # Integer NA
NA_real_                  # Double NA
NA_character_             # Character NA
is.na(1)                  # FALSE
is.na(NA)                 # TRUE

typeof(1L + NA)           # integer
typeof(1L + NA_real_)     # double

NaN                       # Not a Number (z.B. 0/0)
Inf                       # Unendlich (z.B. 1/0)
-Inf                      # Negativ unendlich (z.B. -1/0)
\end{lstlisting}

R unterstützt auch komplexe Zahlen. Zur exakten Berechnung mit sehr großen Zahlen oder Brüchen lassen sich externe Pakete wie \texttt{gmp} (ganze und rationale Zahlen) oder \texttt{Rmpfr} (Gleitkommazahlen) verwenden.

\begin{lstlisting}
-4+0i                            # Komplexe Zahl
#sqrt(-4)                        ## NaN; Warnung
sqrt(-4+0i)                      # 0+2i

2147483647L                      # Größte Integerzahl
2147483647L + 1L                 # NA; Ganzzahlüberlauf
2147483648L                      # Warnung Umwandlung in Double
as.character(2^53)               # 9007199254740992
as.character(2^53 - 1)           # 9007199254740991
as.character(2^53 + 1)           # 9007199254740992 !
as.character(2^53 + 2)           # 9007199254740994
0.1 + 0.2 == 0.3                 # FALSE; Rundungsfehler
all.equal(0.1 + 0.2, 0.3)        # TRUE; Einstellbare Toleranz

library(gmp)
as.bigz("2147483648")            #  2147483648 als Ganzzahl
#as.bigz(9007199254740993)       ## 9007199254740992
as.bigz("9007199254740993")      #  9007199254740993

as.bigq(1L, 3L)                  #  exakter Bruch 1/3
as.bigq(2L, 4L)   # 1 / 2
as.bigq(0.5, 1)   # 1 / 2

library(Rmpfr)
mpfr("9007199254740992.5", 55L)  # 9007199254740992.5
mpfr("9007199254740992.75", 55L) # 9007199254740993
mpfr("9007199254740992.75", 56L) # 9007199254740992.75

format(1/3, digits=20)           # 0.33333333333333331483
mpfr(as.bigq(1L, 3L), 64)        # 0.333333333333333333342
\end{lstlisting}

\subsection{Vector}

Ein Vektor ist eindimensional, enthält Elemente des gleichen Typs und kann beliebig lang sein. Mit \lstinline|c| werden mehrere Werte zu einem Vektor oder einer Liste zusammengefügt.

\begin{lstlisting}[language=R]
1                 # numerischer Vektor mit Länge 1
c(1, 2, 3)        # numerischer Vektor mit Länge 3
c("a", "b", "c")  # Zeichen-Vektor (String)
c(1, 2, "x")      # Zahlen werden in String umgewandelt

x = c(a=1, "b b"=2, a=3)   # Elemente bekommen einen Namen
names(x)                   # "a" "b b" "a"
x["a"]                     # 1; gibt ersten Treffer zurück
make.names(names(x), TRUE) # "a" "b.b" "a.1"
make.unique(names(x))      # "a" "b b" "a.1"
length(x)                  # 3
x[3]                       # 3; Inhalt drittes Element
x[4]                       # NA

vector("integer", 3)       # 0 0 0; Erzeugt int Vektor
integer(3)                 # 0 0 0; Erzeugt int Vektor

x <- Matrix::sparseVector(c(3,5,7), c(1,10,90), 100)
# Erzeugt wenig besetzten Vektor
x[1]                       # 3
x[2]                       # .
x[101]                     # NA
\end{lstlisting}

\subsection{Matrix, Array}

Array ist eine ein bis mehrdimensionale Strukturen die Elemente des gleichen Typs enthält. Eine Matrix ist ein zweidimensionales Array.

Operationen sind meist schneller, wenn sie der Anordnung der Elemente im Speicher folgen. In R werden Matrizen und mehrdimensionale Arrays spaltenweise (d.\,h.\ in der Reihenfolge der ersten Dimension) im Speicher abgelegt, weshalb spaltenorientierte Berechnungen meist effizienter sind als zeilenorientierte.

\begin{lstlisting}[language=R]
array(1:3, dim=3)                # 1D-Array
x <- matrix(1:6, nrow=2, ncol=3) # 2x3 Matrix
matrix(1:6, 2, 3, byrow=TRUE)    # Füllt zeilenweise
rownames(x)                      # Zeilennamen
colnames(x)                      # Spaltennamen
length(x)                        # 6
nrow(x)                          # 2
ncol(x)                          # 2
a <- array(1:8, dim=c(2,2,2))    # 3D-Array 2x2x2
dimnames(a)                      # Dimensionsnamen
dim(a)                           # 2 2 2
is.matrix(a)                     # FALSE
is.array(a)                      # TRUE

x <- Matrix::sparseMatrix(c(1,100), c(1,100), x=c(2,3),
                          dims=c(100,100))
# Erzeugt wenig besetzte Matrix
x[1,1]                           # 2
x[5,5]                           # 0
\end{lstlisting}

\subsection{List}

Eine Liste ist ein Vektor für Objekte beliebiger Typen und Längen.

\begin{lstlisting}[language=R]
list(1, "a", TRUE, c(1,2))  # Liste mit verschiedenen Typen
c("a", list(2, 3))          # c fügt Listen zusammen
vector("list", 3)           # Erzeugt Lite mit 3 Elementen
\end{lstlisting}

\subsection{Data.frame}

Ein data.frame ist eine tabellarische Datenstruktur in R, die als Liste gleich langer Spalten organisiert ist. Die Spalten sind in der Regel Vektoren, können aber auch komplexere Objekte enthalten, solange alle Spalten die gleiche Länge haben.

\begin{lstlisting}[language=R]
x = data.frame(Name=c("Anna", "Max"), Alter=c(25, 30))
x$l = list(3:2, "a")                   # list als Spalte
x$m = matrix(1:6, 2)                   # matrix als Spalte
x$d = data.frame(a=c("c", "d"), b=2:1) # data.frame als Spalte
names(x)                               # Spaltennamen
length(x)                              # Anzahl Spalten
ncol(x)                                # Anzahl Spalten
nrow(x)                                # Anzahl Zeilen
row.names(x)                           # Zeilennamen
head(x)                                # Anfang
tail(x)                                # Ende
summary(x)                             # Datenüberblick
str(x)                                 # Daten Struktur
\end{lstlisting}

\subsection{Factor}

Ein factor repräsentiert kategoriale Daten. Intern werden diese als Ganzzahlen mit zugehörigen Namen (Levels) gespeichert.

\begin{lstlisting}[language=R]
f <- factor(c("rot", "blau", "rot")) # Faktor erstellen
levels(f)        # "blau" "rot"
nlevels(f)       # 2
unclass(f)       # 2 1 2; interne Ganzzahl-Repräsentation

# Geordneter Faktor (ordinal)
f <- ordered(c("wenig", "mittel", "viel"),
             levels = c("wenig", "mittel", "viel"))

# Faktor mit systematisch generierten Levels
gl(3, 2)  # 1 1 2 2 3 3; erzeugt Faktor mit 3 Levels
\end{lstlisting}

\subsection{Datum und Zeit}

R kennt mehrere Klassen für Zeitangaben:
\lstinline|Date| für reine Datumsangaben sowie
\lstinline|POSIXct| und \lstinline|POSIXlt| für kombinierte Datums- und Zeitangaben.
Zeitdifferenzen werden mit \lstinline|difftime| dargestellt.

\begin{lstlisting}[language=R]
Sys.Date()                # "2025-10-24"; Aktuelles Datum
as.Date("2025-10-24")     # Standardformat: "%Y-%m-%d"
as.Date("24.10.2025", format = "%d.%m.%Y")
  
Sys.time()                # "2025-10-24 08:16:44 CEST"
Sys.timezone()            # "Europe/Vienna"; Lokale Zeitzone
ct <- as.POSIXct("2025-10-24 08:16:44")
# "2025-10-24 08:16:44 CEST"
as.POSIXct("2025-10-24 08:16:44", "UTC")
# "2025-10-24 08:16:44 UTC"
ISOdatetime(2025, 10, 24, 8, 16, 44)
# "2025-10-24 08:16:44 CEST"
ISOdate(2025, 10, 24)
# "2025-10-24 12:00:00 GMT"
unclass(ct)               # 1761286604; Sekunden seit 1970-01-01
lt <- as.POSIXlt("2025-10-24 08:16:44") #Liste mit Jahr, Monat..
lt$hour                   # 8

as.Date("2024-3-1") - as.Date("2024-2-1") # 29 days
a <- ISOdate(2025, 10, 1, 8, 0, 0)
e <- ISOdate(2025, 10, 1, 9, 10, 30)
e - a                                     # 1.175 hours
difftime(e, a, units = "mins")            # 70.5 mins

seq(as.Date("2025-10-01"), as.Date("2025-10-25"), "1 week")
# "2025-10-01" "2025-10-08" "2025-10-15" "2025-10-22"
seq(as.Date("1582-10-4"), as.Date("1582-10-15"), "1 day") # !
# "1582-10-04" "1582-10-05", ..., "1582-10-14" "1582-10-15"

.leap.seconds  # Zeigt Schaltsekunden
seq(ISOdate(2016,12,31,23,59,59), by="1 sec", length.out = 3)
# "2016-12-31 23:59:59 GMT" "2017-01-01 00:00:00 GMT"
# "2017-01-01 00:00:01 GMT"
ISOdate(2016, 12, 31, 23, 59, 60)   #  "2017-01-01 GMT"
as.POSIXlt("2016-12-31 23:59:60", tz = "UTC")
# "2016-12-31 23:59:60 UTC"
\end{lstlisting}

\subsection{NULL}

\lstinline|NULL| repräsentiert ein Objekt ohne Wert oder Inhalt. 
Es ist ein spezieller Typ, der häufig für leere Rückgaben, Platzhalter oder gelöschte Einträge verwendet wird.
Vektoren können \lstinline|NULL| nicht enthalten, da alle Elemente eines Vektors denselben Typ besitzen müssen.

\begin{lstlisting}[language=R]
x <- NULL
is.null(x)            # TRUE
length(x)             # 0

x <- c(1, NULL, 3, 4) # 1 3 4; NULL Verschwindet
#x[2] <- NULL         ## Fehler
x[2] <- list(NULL)    # Wandelt Vector a in Liste um

x <- list(1, NULL, 3) # [[1]] 1  [[2]] NULL  [[3]] 3
x[[3]] <- NULL        # Löscht drittes Element
x[2] <- NULL          # Löscht zweites Element
x[1] <- list(NULL)    # Fügt NULL ein

x <- data.frame(a=1:2, b=3:4)
x$c <- list(NULL, 2)  # Fügt neue Liste ein
x$b <- NULL           # Löscht Spalte b
\end{lstlisting}

\subsection{Funktionen und Closure}

Beim Aufruf von Funktionen werden Argumente nach folgender Priorität zugeordnet:
\begin{enumerate}
  \item exakter Name  
  \item partieller Name  
  \item Position  
\end{enumerate}
Dadurch können Argumente frei kombiniert positional und per Name übergeben werden.

\begin{lstlisting}
f <- function(x, xa, ya, yb, za) cat(x, xa, ya, yb, za)
f(1, 2, 3, 4, 5)         # 1 2 3 4 5; Position
f(1, 2, 3, 4, x=5)       # 5 1 2 3 4; exakter Name + Position
f(1, 2, 3, 4, xa=5)      # 1 5 2 3 4; exakter Name + Position
#f(1, 2, 3, x=4, x=5)    ## Error, x passt zu mehreren
#f(1, 2, 3, 4, y=5)      ## Error, y mehrdeutig ya oder yb
f(z=1, 2, 3, 4, 5)       # 2 3 4 5 1; Partieller Name und Position
#f(zak=1, 2, 3, 4, 5)    ## Error, unbenutztes Argument zak
\end{lstlisting}

In R sind Funktionen sogenannte Closures: Objekte, die aus einem Funktionskörper und einem enclosing environment bestehen.
Variablen, die nicht als Funktionsargumente übergeben werden, sucht R zuerst im enclosing environment der Funktion und dann in den übergeordneten Environments.
Im Environment können Variablen gespeichert werden.
Bei Funktionen wird der letzte Ausdruck zurückgegeben.
Zusätzlich gibt es noch \lstinline|return|.

\begin{lstlisting}[language=R]
f <- function(x) x+1
f(3)           # 4

f2 <- \() {x}  # \() Kurzschreibweise
#f2()          ## Fehler, x nicht gefunden
x <- 1
f2()           # 1; greift jetzt auf globales x zu

f3 <- \() {x <- 2; x}
f3()           # 2; greift auf lokales x zu

f4 <- local(\() x)
f4()           # 1; greift auf globales x zu
environment(f4)$x <- 4
f4()           # 4; greift auf lokales x zu
x              # 1

f5 <- local({n=0L; \() {n <<- n+1L; n}})
f5()           # 1
f5()           # 2
environment(f5)$n <- 8
f5()           # 9

f6f <- \(n){\() {n <<- n+1L; n}} # Function factory
f6 <- f6f(7L)  # Gibt Funktion zurück
f6()           # 8
f6()           # 9
ls(environment(f6))      # n
as.list(environment(f6)) # n 9

f7 <- \(a, b) a(b) # Argument ist eine Funktion
f7(mean, 1:3)  # 2
f7(sum , 1:3)  # 6

f8 <- \() {x <<- 2; invisible(x)}
f8()           # Gibt nichts in der Konsole aus
cat(f8())      # 2; Gibt aber dennoch Wert zurück

f9 <- \(n) if (n > 0) n + f9(n-1) else n
f9(3)          # 6; Rekursiv
\end{lstlisting}

\lstinline|local()| erzeugt ein Environment, in dem Objekte (z. B. Zähler oder Parameter) dauerhaft für die zurückgegebene Funktion gebunden bleiben.

Die Ellipsis \lstinline|...| fängt alle nicht explizit definierten Argumente auf und ermöglicht deren unveränderte Weitergabe an andere Funktionen.

\begin{lstlisting}
fx <- \(x) x
fx(1)           # 1
fx(x=1)         # 1
#fx(y=1)        ## Error, unbenutztes Argument
#fx(1, 2)       ## Error, unbenutztes Argument
#fx()           ## Error, Argument x fehlt
f <- \(...) fx(...)
f(1)            # 1
f(x=1)          # 1
#f(y=1)         ## Error, unbenutztes Argument
#f(1, 2)        ## Error, unbenutztes Argument

fx <- \(x, y=0) x + y  # Defaultwert für y
fx(1)           # 1
#fx(y=1)        ## Error, kein x
fx(1, 2)        # 3
fx(1, 2, 3)     ## Error, unbenutztes Argument

fx <- \(x, ...) x
#fx(y=1)        ## Error, Argument x fehlt
fx(1, 2)        # 1
f <- \(x, ...) fx(...) # Vermeiden da x nur unbenannt an fx geht
#f(1)           ## Error, Argument x fehlt für fx
f(1, 2)         # 2
f(x=1, 2)       # 2; 
#f(x=1, x=2)    ## Error, x passt zu mehreren Argumenten
f(x=1, y=2)     ## Error, Argument x fehlt für fx
f <- \(y, ...) fx(...)
f(1, 2)         # 2
f(x=1, 2)       # 1
f(x=1, y=2)     # 1

f <- \(x, ...) ..2  # zweites Element von ...
f(1, 2, 3, 4)   # 3
f(1, 2, 3, x=4) # 2
f(1, 2, 3, y=4) # 3
#f()            ## Error, ..2 nicht vorhanden

f <- \(x, ...) ...elt(2)  # zweites Element von ...
f(1, 2, 3, 4)   # 3

f <- \(x, ...) ...length()  # Länge von ...
f()             # 0
f(1, 2, 3)      # 2, weil x=1 nicht in ... ist
f(1, cat("a"))  # 1; Wertet Argumente nicht aus

f <- \(x, ...) length(list(...))  # Länge von ...
f(1, cat("a"))  # 1; list wertet Argumente aus

f <- \(...) ...names()  # Namen von ...
f(1, 2)         # NULL
f(1, a=2)       # "" "a"
\end{lstlisting}

Man kann auch eigene Infix Operatoren definieren. Jeder Operator, dessen Name mit \lstinline|%| beginnt und endet (z.~B. \lstinline|%myop%|), wird als Infix-Operator behandelt und hat in der Regel zwei Argumente. Er hat die gleiche Priorität wie der Operator \lstinline|+| und wird von links nach rechts ausgewertet.

\begin{lstlisting}
1 + 1      # 2; + ist Infix Operatoren
`+`(1,1)   # 2; Aufruf als Funktion
`%A%` <- \(l,r) l + r
1 %A% 1    # 2
`%A%`(1,1) # 2

`%+%` <- \(l,r) l + r
`%*%` <- \(l,r) l * r  # Überdeckt Matrixprodukt %*% !!
1 + 2 * 3      # 7
1 %+% 2 %*% 3  # 9; Wird von links nach recht ausgewertet

`%^%` <- \(l,r) l^r  # Ausnutzung der Operatorpriorität
`:=` <- \(l,r) l * r
`?` <- \(l,r) l + r  # Überdeckt ? (help) !
2 + 3 * 4^2          # 50
2 ? 3 := 4%^%2       # 50
\end{lstlisting}


\section{Subsetting (Teilmengen)}

In R werden Elemente von Datenstrukturen mit Hilfe von Subsetting ausgewählt. Die gebräuchlichsten Subsetting-Operatoren sind \lstinline|[ ]|, \lstinline|[[ ]]| und \lstinline|$|. Subsetting kann mit numerischen Indizes, logischen Vektoren oder Namen erfolgen.

\lstinline|[ ]| gibt immer ein Objekt des gleichen Typs zurück (z.\,B. Liste, data.frame), sofern \lstinline|drop=FALSE| gesetzt ist, \lstinline|[[ ]]| extrahiert ein einzelnes Element.

\begin{lstlisting}[language=R]
v <- c(a=10, b=20, c=30, d=40, e=50)
v[2]             # 20; Element an Position 2
v[[2]]           # 20
v[1:3]           # 10 20 30; Element 1 bis 3
v[3:1]           # 30 20 10; Element 3 bis 1
v[c(1,3,5)]      # 10 30 50; Mehrere Elemente
v[c(1,1)]        # 10 10; Mehrfach gleiches Element
v[-c(2,4)]       # 10 30 50; Alle außer Position 2 und 4: 
v["c"]           # 30; Über Namen
#v$c             ## Fehler
v[6]             # NA
#v[[6]]          ## Fehler, Indizierung außerhalb
v[c(TRUE,FALSE,TRUE,FALSE,TRUE)] # 10 30 50; Logisch
v[c(TRUE,FALSE)] # 10 30 50; Wird automatisch wiederholt
v[v>30]          # 40 50; Logisch
v[!v>30]         # 10 20 30; ! (not)
v[which(v>30)]   # 40 50; Über Position
v[-which(v>30)]  # 10 20 30
v[-which(v>50)]  # Nichts!
v                # Ganzer Vektor
v[]              # Ganzer Vektor
v[0]             # Nichts
v[-0]            # Nichts
v[NULL]          # Nichts
v[integer(0)]    # Nichts

m <- matrix(1:6, 2, dimnames=list(c("a","b")))
m[2, 3]         # 6; Zeile 2, Spalte 3
m[[2, 3]]       # 6
#m[[c(3, 2)]]   ## Fehler
#m[1, 4]        ## Fehler, Indizierung außerhalb
#m[[1, 4]]      ## Fehler, Indizierung außerhalb
m[1, ]          # 1 3 5; Vektor, Ganze 1. Zeile
#m[[1, ]]       ## Fehler,  missing subscript
m["a", ]        # 1 3 5; Vektor, Zeile a
m[1, , drop=FALSE]  # 1 3 5; Matrix
m[, 2]          # 3 4; Ganze Spalte 2
m[-1, -3]       # Ohne Zeile 1 und Spalte 3
m[2, 2:3]       # Zeile 2, Spalte 2 bis 3
m[4]            # 4; Kann wie Vektor verwendet werden
m[[4]]          # 4
m[7]            # NA
#m[[7]]         ## Fehler, Indizierung außerhalb
m[m>3]          # 4 5 6
a <- array(1:8, dim=c(2,2,2))
a[ , , 1]       # Erste Schicht

l <- list(a=1, b=c(a=2,b=3,c=4), c="Hallo")
l[2]            # 2 3 4; Liste mit zweitem Element
l[[2]]          # 2 3 4; Zweites Element
l[[2]][[1]]     # 2; Zweites Element, erster Eintrag
l[[c(2, 1)]]    # 2; Zweites Element, erster Eintrag
l[[c("b", "a")]]# 2; Element b, Eintrag a
#l[[1,2]]       ## Fehler, falsche Anzahl Subscripts
l$b             # 2 3 4; Element b
l["b"]          # 2 3 4; Liste mit Element b
l[["b"]]        # 2 3 4; Element b
l[1:2]          # Liste mit Element 1 und 2
l[c("a","c")]   # Liste mit Element a und c
l[-2]           # Liste ohne zweites Element
l[c(TRUE, FALSE)] # Liste jedes zweites Element
l[4]            # NULL
#l[[4]]         ## Fehler, Indizierung außerhalb
l <- list(x = 1, y = list(z = 2, w = 3))
l$y$z           # 2; verschachtelter Zugriff

Ich habe in R ein data.frame d und möchte dort vom Spalte 2 die Elemente 2 und 1 abfragen, was mit "d[[2]][2:1]" geht. Warum geht "d[[2:1, 2]]" nicht?

d <- data.frame(a=c("d","e"), b=2:1)
d[[2]][2:1]
d[[2:1, 2]]  # Fehler


d <- data.frame(a=c("d","e"), b=2:1)
d[1, ]          # d 2; data.frame, Erste Zeile
d[, 2]          # 2 1; Vektor, Zweite Spalte
d[[2]]          # 2 1; Vektor, Zweite Spalte
d[2]            # 2 1; data.frame, Zweite Spalte
d[, 2, drop=FALSE] # 2 1; data.frame, Zweite Spalte
d[, "b"]        # 2 1; Vektor
d$b             # 2 1; Vektor
d$b[1]          # 2; Erstes Element von Spalte b
d[1, "b"]       # 2; Variante
d[1, 2]         # 2; Variante
d[[2]][1]       # 2; Variante
d[[2]][[1]]     # 2; Variante
d[[1, 2]]       # 2; Variante
d[[c(2, 1)]]    # 2; Variante
d[[1, "b"]]     # 2; Variante
d$b[2:1]        # 1 2; Element 2, 1 von Spalte b
d[2:1, "b"]     # 1 2; Variante
d[2:1, 2]       # 1 2; Variante
d[[2]][2:1]     # 1 2; Variante
#d[[2]][[2:1]]  ## Error; [[ geht nur für ein Element
#d[[2:1, 2]]    ## Error; [[ geht nur für ein Element
d[2:1, 2:1]     # Reihenfolge von Zeilen und Spalten ändern
d[-1, ]         # data.frame ohne erste Zeile
d[, -1]         # Da nur eine Spalte => Vektor
d[, 1:2]        # Spalten 1 bis 2
d[c(TRUE, FALSE),] # Jede zweite Zeile
d[0]            # data.frame mit 0 Spalten
d[0,]           # data.frame mit 0 Zeilen
d[d$a == "d", ] # Zeilen, bei denen a == "d"
d[d$b > 1, "a"] # Spalte a, Zeilen mit b > 1
d[d$a == "d" & d$b > 1, ] # d 2
#d[3]           ## Fehler, nicht definierte Spalte
#d[[3]]         ## Fehler, Indizierung außerhalb
d$b[3]          # NA

e <- new.env()
e$a <- 1
assign("b", 2, envir = e)
e$a                  # 1
e$b                  # 2
e[["a"]]             # 1
#e[[1]]              ## Fehler
#e["a"]              ## Fehler
e[["c"]]             # NULL
get("a", envir = e)  # 1; Sucht auch in Parrent
rm(b, envir = e)     # Löscht Element b
ls(e)                # "a"; Listet Elemente von e
\end{lstlisting}

\section{Datenmanipulation}

\subsection{Operatoren}

Dieses Beispiel zeigt die wichtigsten arithmetischen, Vergleichs- und
logischen Operatoren.

\begin{lstlisting}
x <- 1:3
y <- c(2, 4, 6)
x + y     # 3 6 9; Elementweise Addition
x - y     # -1 -2 -3; Subtraktion
x * y     # 2 8 18; Multiplikation
y / x     # 2 2 2; Division
x^2       # 1 4 9; Potenzierung
x %% 2    # 1 0 1; Rest der Division (Modulo)
x %/% 2   # 0 1 1; Ganzzahldivision
1 + 2 * 3    # 7; Multiplikation vor Addition
(1 + 2) * 3  # 9; Klammern ändern Reihenfolge

x < 2           # TRUE  FALSE FALSE
x > 2           # FALSE FALSE TRUE
x <= 2          # TRUE  TRUE  FALSE
x >= 2          # FALSE TRUE  TRUE
x == 2          # FALSE TRUE  FALSE
x != 2          # TRUE  FALSE TRUE
x > 1 & x < 3   # FALSE TRUE  FALSE; UND (elementweise)
x > 1 | x < 3   # TRUE  TRUE  TRUE;  ODER (elementweise)
xor(x>1, x<3)   # TRUE  FALSE TRUE
!(x > 1)        # TRUE  FALSE FALSE; Negation

FALSE && TRUE          # FALSE
TRUE  || FALSE         # TRUE
l <- TRUE
FALSE && (l <- FALSE)  # Auswertung bis Ergebnis klar
l                      # TRUE
TRUE && (l <- FALSE)
l                      # FALSE
NA && TRUE             # NA
NA || TRUE             # TRUE

sum(x > 1)        # 2; Anzahl der Elemente > 1
any(x > 2)        # TRUE; Mindestens ein TRUE?
all(x > 0)        # TRUE; Alle TRUE?
which(x > 1)      # 2 3

1 == 1L           # TRUE
identical(1, 1L)  # FALSE; Typ unterschiedlich
\end{lstlisting}

\subsection{String}

Das folgende Beispiel zeigt typische Operationen zur Verarbeitung von
Zeichenketten in R, einschließlich Zählen, Suchen, Ersetzen, Aufteilen
und Vergleichen von Strings.

\begin{lstlisting}
s <- c("Mehr", "Licht")
nchar(s)                  # 4 5; Anzahl Zeichen
nchar(c("a", "ä"), "bytes") # 1 2
nzchar(s)                 # TRUE TRUE; Länge > 0
toupper(s)                # "MEHR" "LICHT"
tolower(s)                # "mehr" "licht"
chartr("hi", "Xy", s)     # "MeXr" "LycXt"; Zeichen austauschen

grepl("c.", s)            # FALSE TRUE ; enthält Regex "c."
grepl("c.", s, fixed=TRUE)# FALSE FALSE; enthält "c."
grep("ch", s)             # 2; Index des Treffers
grep("ch", s, value=TRUE) # "Licht"

agrep("Meer", s)          # 1; Ungefähre Treffer
adist("Meer", s)          # 1 5; String Abstände

i <- regexpr("[eih]", s)  # Erster Treffer von e, i, oder h
regmatches(s, i)          # "e" "i"; Treffer Ausgeben
i <- gregexpr("[eih]", s) # Alle Treffer von e, i, oder h
regmatches(s, i)          # "e" "h", "i" "h"
s1 <- lapply(regmatches(s, i), \(x) paste0("<", x, ">"))
regmatches(s, i) <- s1    # Treffer überschreiben
s                         # "M<e><h>r"  "L<i>c<h>t"

s <- c("abcd", "dcba")    # Mehrere ersetzen
r <- c(ef="a", gh="c")    # a=>ef, c=>gh
i <- gregexpr(paste(r, collapse="|"), s)
s1 <- lapply(regmatches(s, i), \(x) names(r)[match(x, r)])
regmatches(s, i) <- s1
s                         # "efbghd" "dghbef"

sub("a", "xz", "aba")     # "xzba"; erstes Vorkommen ersetzen
gsub("a", "xz", "aba")    # "xzbxz"; alle ersetzen
gsub("([ac])", "<\\1>", "abc") # "<a>b<c>"; Treffer verwenden
gsub("\\s+", " ", "a  b") # "a b"; Mehrfachleerzeichen=> " "
trimws("  Text  ")        # "Text"; Umgebende " " entfernen

s <- c("Mehr", "Licht")
toString(s)               # "Mehr, Licht";Fügt mit ", " zusammen
s <- paste(s[1], s[2])    # "Mehr Licht"; Fügt mit " " zusammen
strsplit(s, " ", TRUE)    # Liste: "Mehr" "Licht"; Trennt String
paste(c("A","B","C"), collapse=", ") # "A, B, C"
paste("A", 1:3, sep="-")  # "A-1" "A-2" "A-3"
paste0("A", 1:3)          # "A1" "A2" "A3"
sprintf("Pi: %0.2f", pi)  # "Pi: 3.14"; formatiertes Einfügen

substr(s, 1, 4)           # "Mehr"; Teilstring
substr(s, 1, 4) <- "Weniger"  # "Weni Licht"; Nur Teil ersetzt !
strtrim(s, 3)             # "Wen"; auf Länge 3 kürzen

startsWith(s, "Wen")      # TRUE; beginnt mit "Wen"
endsWith(s, "ht")         # TRUE; endet mit "ht"

charToRaw("ä")            # c3 a4; Bytes anzeigen
s <- "\u00e4"             # "ä"
iconv("Müller", "UTF-8", "latin1")  # Encoding ändern
utf8ToInt("ä")            # 228
intToUtf8(228)            # "ä"

s <- noquote(c("Ab", "C"))# Ausgabe ohne Anführungszeichen
s                         # Ab C

s <- c("Ab", NA, "C")
paste("x", s, sep="-")   # "x-Ab" "x-NA" "x-C"; NA wird String !

s <- c("ä", "a", "b")
Sys.setlocale("LC_COLLATE", "C")  # ASCII-Reihenfolge
sort(s)                  # "a" "b" "ä"
"ä" < "z"                # FALSE
Sys.setlocale("LC_COLLATE", "de_AT.UTF-8")
sort(s)                  # "a" "ä" "b"
"ä" < "z"                # TRUE
\end{lstlisting}

\subsection{Factor}

Faktoren werden zur Darstellung kategorialer Daten verwendet.
Im Folgenden einige kurze Beispiele zur Manipulation von Faktoren.

\begin{lstlisting}
f <- factor(c("rot", "blau", "rot"))
f <- relevel(f, "rot")  # "rot" wird erster Level

n <- c(3, 2, 2)
reorder(f, n)           # sortiert Levels

# Reihenfolge der Levels festlegen
f <- factor(c("rot", "blau", "rot"), c("rot", "blau"))
#f < "blau"             ## Warning: < nicht sinnvoll
f <- ordered(c("rot", "blau", "rot"), c("rot", "blau"))
f < "blau"              # TRUE FALSE  TRUE

levels(f)[levels(f) == "rot"] <- "grün" # "rot" wird "grün"

# Mehrere Levels umbenennen, zusammenfassen
f <- factor(c("j","n","ja","X","ja","nein","X"))
levels(f)                # "j" "ja" "n" "nein" "X"
levels(f)[match(c("j","n"), levels(f))] <- c("ja","nein")
levels(f)                # ja nein X
#
f <- factor(c("j","n","ja","X","ja","nein","X"))
levels(f) <- list(ja=c("ja","j"), nein=c("nein","n"), X="X")
#
f <- factor(c("j","n","ja","X","ja","nein","X"))
local({
  s <- c(ja="j", nein="n", m="u")
  i <- match(levels(f), s, 0)
  levels(f)[i != 0] <<- names(s)[i]
})

f <- factor(c("A","B"), levels = c("A","B","C"))
levels(f)                # "A" "B" "C"
f[2:1]                   # Behällt alle Levels
f[2:1, drop=TRUE]        # Nur die vorhandenen Levels
f <- droplevels(f)       # Entfernt unbenutzte Levels
levels(f)                # "A" "B"
#f[3] <- "C"             ## Warning => NA
levels(f) <- c(levels(f), "C") 
f[3] <- "C"

f <- factor(c(2,1,3,2,1), c(2,3,1))
unclass(f)               # 1 3 2 1 3; Interner Repräsentant
as.integer(f)            # 1 3 2 1 3
as.numeric(levels(f))[f] # 2 1 3 2 1
as.character(f)          # "2" "1" "3" "2" "1"

f <- factor(c("b","a","b","c","a"))
x <- table(f)            # a b c; Häufigkeiten pro Level
                         # 2 2 1
summary(f)               # 2 2 1
addmargins(x)            # 2 2 1 5
proportions(x)           # 0.4 0.4 0.2

f1 <- factor(c("A","A","B","B"))
f2 <- factor(c("X","Y","X","X"))
f12 <- interaction(f1, f2) # Kombinieren
f12                      # A.X A.Y B.X B.X
levels(f12)              # "A.X" "B.X" "A.Y" "B.Y"
f12 <- interaction(f1, f2, drop=TRUE) # Nur vorhandene Kombis
levels(f12)              # "A.X" "B.X" "A.Y"
f <- c(f1, f2)           # Faktoren zusammen hängen
f3 <- factor(c("1","1","2","2"))
table(f1, f2, f3)        # 3D Tabelle
ftable(f1, f2, f3)       # 2D Tabelle
x <- c(1.3, 2.4, 0.2, 1.1)
xtabs(x ~ f1 + f2, data.frame(x, f1, f2)) # Summiert x je Gruppe
\end{lstlisting}

\subsection{Vektor}

Das folgende Beispiel zeigt grundlegende Operationen mit Vektoren in
R, einschließlich Erstellen, Indexieren, Sortieren, Gruppieren und
Mengenoperationen.

\begin{lstlisting}
x <- 1:3          # 1 2 3; Integer
x[2] <- 4         # 1 4 3; zweites Element ändern, Int->Numeric
x[2:3] <- 5:6     # 1 5 6
x[x>1] <- 2       # 1 2 2; Alle >1 auf 2 ändern
x[5] <- 5         # 1 2 2 NA 5; Element hinterm Ende einfügen
x <- c(x, 6)      # 1 2 2 NA 5 6; Element anhängen
append(x, 7, 3)   # 1 2 2 7 NA 5 6; nach Position 3 einfügen
x <- tail(x, 4)   # 2 NA 5 6; Letzten 4 Elemente behalten
x <- head(x, 3)   # 2 NA 5; Ersten 3 Elemente behalten
x <- x[-2]        # 2 5; entfernt zweites Element
x <- rev(x)       # 5 2; Reihung umkehren
i <- order(x)     # 2 1; Index mit dem x sortiert ist
order(c(1,2,1))   # 1 3 2
rank(c(1,2,1))    # 1.5 3.0 1.5
x[i]              # 2 5
is.unsorted(x)    # TRUE
is.unsorted(x[i]) # FALSE
x <- sort(x)      # 2 5
x <- x + 1        # 3 6; Alle um 1 erhöhen
x[2] <- "a"       # "3" "a"; Umwandlung in Char
as.numeric(c("1", "2")) # 1 2; explizite Umwandlung

x <- c(2, 2, 1, 1, 3)
unique(x)         # 2 1 3
duplicated(x)     # FALSE TRUE FALSE TRUE FALSE
table(x)          # 1 2 3; Anzahlen
                  # 2 2 1
stem(x)           # stem-and-leaf plot
summary(x)        # Min. 1st Qu. Median Mean 3rd Qu. Max.
range(x)          # 1 3; kleinster und größter Wert
length(x)         # 5; Anzahl Elemente
which.max(x)      # 5; Index des ersten größten Wertes
which.min(x)      # 3; Index des ersten kleinsten Wertes
rle(x)            # lengths: int [1:3] 2 2 1;Run Length Encoding
                  # values : num [1:3] 2 1 3
g <- c("A", "A", "C", "B", "B")
ave(x, g)         # Gruppenmittel für jedes Element
tapply(x, g, mean) # Mittel je Gruppe
s <- split(x, g)  # Teil x in Liste grupiert mit g
lapply(s, mean)   # Mittel je Gruppe
match(x, c(3,1,3))# NA NA  2  2  1; Position erster Treffer
x %in% 1:2        # TRUE  TRUE  TRUE  TRUE FALSE
findInterval(x, c(0,2)) # 2 2 1 1 2;
pmin(x, 2)        # 2 2 1 1 2
pmin(x, 0:4)      # 0 1 1 1 3
pmax(x, 0:4)      # 2 2 2 3 4

x <- c(1,2,3,4)
y <- c(3,4,5,6)
union(x, y)       # 1 2 3 4 5 6; Vereinigung
intersect(x, y)   # 3 4;         Schnittmenge
setdiff(x, y)     # 1 2; Elemente in x, aber nicht in y
setdiff(y, x)     # 5 6; Elemente in y, aber nicht in x
setequal(x, y)    # FALSE; # Mengen gleich?
setequal(x, 4:1)  # TRUE
\end{lstlisting}

\subsection{Matrix und Array}

\begin{lstlisting}
m <- matrix(1:6, 2)  # 2x3 Matrix
as.vector(m)         # Matrix in Vektor
as.data.frame(m)     # Matrix in Data Frame
as.matrix(1:4)       # Vektor in Matrix
rownames(m) <- c("A","B")
colnames(m) <- c("x","y","z")
dimnames(m)          # Dimensionsnamen
t(m)                 # Transponieren
dim(m) <- c(3,2)     # Neue Dimensionen setzen
aperm(m, c(2,1))     # Dimensionen vertauschen

m <- matrix(1:4, 2)
v <- 1:2
m + 1                # Elementweise Rechenoperationen
m + m
m + v                # Spaltenweises Recycling von v
m + v[col(m)]        # Zeilenweise Addition
sweep(m, 1, v, `+`)  # Spaltenweise Addition
sweep(m, 2, v, `+`)  # Zeilenweise Addition
outer(v, 1:3)        # Kreuzweise Kombination zweier Vektoren
outer(v, 1:3, `+`)
outer(v, 1:3, \(x, y) x+y)
row(m)               # Zeilenindex
col(m)               # Spaltenindex
slice.index(m, 1)    # Zeilenindex
slice.index(m, 1:2)  # Vektorindex

m %*% m              # Matrixprodukt
matrix(c(sum(m[1,] * m[,1]), sum(m[2,] * m[,1]),
         sum(m[1,] * m[,2]), sum(m[2,] * m[,2])), 2)
m %*% v              # 7 10
crossprod(m, v)      # t(m) %*% v
tcrossprod(v, m)     # v %*% t(m)
kronecker(diag(1, 2), m) # Kronecker produkt
diag(2)              # Einheitsmatrix
diag(m)              # Diagonale extrahieren
diag(m) <- 0         # Diagonale ändern

m <- matrix(1:6, 2)
rowSums(m)           # 9 12
colSums(m)           # 3 7 11
addmargins(m)        # Zeilen und Spaltensummen
rowMeans(m)          # 3 4
colMeans(m)          # 1.5 3.5 5.5
apply(m, 1, mean)    # 3 4; Margin 1..Zeile
apply(m, 2, sum)     # 3 7 11; Margin 2..Spalte
apply(m, 1, sd)      # 2 2; Standard Deviation
max.col(m)           # 3 3; Splalte mit größtem Wert
apply(m, 1, which.max)# 3 3; Splalte mit größtem Wert

y <- scale(m)        # Zentriert und skaliert Spalten
x <- sweep(m, 2, colMeans(m))
x <- sweep(x, 2, apply(x, 2, sd), `/`)
all(x == y)          # TRUE

proportions(m)       # Gesamte Matrix Summe = 1
proportions(m, 1)    # Zeilenweise
proportions(m, 2)    # Spaltenweise

m <- matrix(1:12, 4)
g <- c("A","B","A","B")
rowsum(m, g)         # Gruppierte Zeilensummen

rbind(m, m)          # Zeilen anhängen
n <- m
colnames(m) <- 1:3
colnames(n) <- 3:1
rbind(m, n)          # Namen werden nicht berücksichtigt
cbind(m, m)          # Spalten anfügen
simplify2array(list(m, m)) # Array aus Matrix
replicate(2, m)      # Array aus Matrix
abind::abind(m, m, along=3) # Beliebig stapeln

split(m, col(m))     # Spaltenweise Aufteilung als Liste
split(m, row(m))     # Zeilenweise Aufteilung

a <- array(1:24, dim=c(2,3,4))
apply(a, 1, sum)     # 144 156; Summe je Zeile
apply(a, 3, sum)     # 21 57 93 129; Summe je Schicht
apply(a, c(1,3), sum)# Summe je Zeile und Schicht
aperm(a, c(2,1,3))   # Dimensionen vertauschen
ftable(a)            # macht 2D Tabelle daraus
b <- a[1,,,drop=FALSE]
drop(b)              # Entfernt 1 Element Dimensionen
i <- which(a > 20)   # Vektor index
which(a > 20, arr.ind=TRUE) # Indizes als Matrix
arrayInd(i, dim(a))  # Wandelt in Matrix Index
\end{lstlisting}

Lineare Algebra

\begin{lstlisting}
A <- matrix(c(2,1,1,3), 2)
b <- c(1,4)

solve(A, b)     # Löst A x = b
solve(A)        # Inverse Matrix
det(A)          # Determinante
eigen(A)        # Eigenwerte/-vektoren
svd(A)          # Singulärwertzerlegung
qr(A)           # QR-Zerlegung
chol(A)         # Cholesky-Zerlegung (symm. positiv)
\end{lstlisting}

\subsection{List und data.frame}

\begin{lstlisting}
l <- list(a = 1:3, b = c("x", "y"), c = TRUE)
lengths(l)      # 3 2 1; Länge der Elemente

l$d <- 99       # Neues Element
l$a <- list(10,20) # Bestehendes Element ersetzen
l$c <- NULL     # Element entfernen
l["c"] <- list(NULL) # NULL einfügen
unlist(l)       # "10" "20" "x" "y" "99"; List2Vektor ohne NULL
unlist(l, FALSE) # Nicht rekursiv, bleibt hier Liste

l2 <- list(a=1, b=2)
c(l, l2)        # Listen zusammenfügen

list(1:3)       # [[1]] 1 2 3
as.list(1:3)    # [[1]] 1 [[2]] 2 [[3]] 3
as.list(iris)   # data.frame => list, Eintrag je Spalte

l <- list(a=1:2, b=list(1, 1:2))
data.frame(l)   # Wandelt b in 2 Vektorspalten um
as.data.frame(l)# Wandelt b in 2 Vektorspalten um
d <- list2DF(l) # b bleibt Liste
d$c <- matrix(1:4, 2) # Matrix als Spalte
d$d <- array(1:8, c(2,2,2)) # Array als Spalte
d[1,]           # Funktioniert bei Array nicht wie erwartet
tibble::tibble(d)[1,] # Hier wie erwartet
#as.matrix(d)         ## Error
as.matrix(d[c(1,2)])  # Geht
as.matrix(d[c(1,3)])  # Geht
#as.matrix(d[c(2,3)]) ## Error

d <- data.frame(a=1:3, row.names = 3:1)
ti <- tibble::as_tibble(d) # Verliert row.names
as.data.frame(ti)

l <- list(a=2, b=3:5, c=5:9)
x <- lapply(l, mean) # [[1]] 2 [[2]] 4 [[3]] 7; Liste
simplify2array(x)    # 2 4 7; Vereinfacht Liste
sapply(l, mean)      # 2 4 7; In einem Schritt
vapply(x, mean, numeric(1)) # 2 4 7; Angabe der Rückgabe

l <- list(a=1:3, b=list(c=3:5, d=5:9))
rapply(l, mean,)     # 2 4 7; rekursiv in Liste anwenden

l1 <- list(1,c(2,3))
l2 <- list(10,c(20,30))
mapply(sum, l1, l2)  # 11 55; mehere Listen gemeinsam
Map(sum, l1, l2)     # Ausgabe als Liste
mapply(sum, l1, l2, SIMPLIFY = FALSE) # Ausgabe als Liste

replicate(2, 1:3, simplify=FALSE) # n mal wiederholen

l <- list(a=1, b=2:3)
do.call(paste, l)             # "1 2" "1 3"
  # Ruft Funktion mit Argumenten aus Liste auf
paste(1, 2:3)                 # "1 2" "1 3"
do.call(paste, c(l, sep="-")) # "1-2" "1-3"
l <- list(a=1, b=2:3, sep="-")
do.call(paste, l)             # "1-2" "1-3"
paste(1, 2:3, sep="-")        # "1-2" "1-3"

l <- list(a=2, b=3:5, c=5:9)
Reduce(\(x, y) x * sum(y), l) # 840; Kumulatives Anwenden
Reduce(\(x, y) x * sum(y), l, 2) # 1680; Mit Startwert
Reduce(\(x, y) x * sum(y), l, 2, accumulate = TRUE)
  # 2 4 48 1680; Jeden Zwischenschritt ausgeben

l <- list(c=1:3, b="x", a=4)
Filter(is.numeric, l)   # Nur numerische Elemente
l[order(names(l))]      # Nach Namen Sortieren
names(l) <- toupper(names(l)) # Namen ändern
\end{lstlisting}

\begin{lstlisting}
d <- data.frame(a=1:4, b=c("x","y"), c=TRUE)
  # b und c werden automatisch wiederholt
dim(d)        # 4 3; Zeilen Spalten
length(d)     # 3; Anzahl Spalten
ncol(d)       # 3; Anzahl Spalten
nrow(d)       # 4; Anzahl Zeilen
names(d)      # Spaltennamen
row.names(d)  # Zeilennamen

#d$d <- 1:3   ## Fehler der Länge
#d$d <- 1:5   ## Fehler der Länge
d$d <- 1:4
d$e <- 1:2    # Wird zu 1 2 1 2
d$f <- 1      # Wird zu 1 1 1 1

d <- data.frame(a=1:2, b=c("x","y"))
d2<- data.frame(b=c("a","b"), a=4:3)
d <- rbind(d, d2) # Zeilen anfügen über Spaltennamen
d3<- data.frame(d=5:6, e=c("f","g"))
#rbind(d, d3)     ## Error, Namen passen nicht
rbind(d, setNames(d3, names(d))) # Spalten umbenenne

d <- data.frame(a=1:2, b=c("x","y"))
d2<- data.frame(a=2:3, c=c(TRUE, FALSE))
cbind(d, d2)      # Spalten anhängen
merge(d, d2)      # Spalten über gemeinsame Spalte a anhängen
merge(d, d2, all=TRUE)   # Alle Daten erhalten
merge(d, d2, all.x=TRUE) # Alle Daten von d  erhalten
merge(d, d2, all.y=TRUE) # Alle Daten von d2 erhalten
d3<- data.frame(a=1, c=c(TRUE, FALSE))
merge(d, d3)      # Zeile 1 von d wird wiederholt
d4<- data.frame(a=1, b=c("x","y"))
merge(d4, d3)      # Alle Kombinationen werden generiert

d <- data.frame(a=1:4, b=c("x","y"))
d$a <- 4:1              # Inhalt von Spalte ändern
d[2,] <- list(5L, "z")  # Inhalt von Zeile ändern
d[2:3,] <- list(7:8, "X")  # Inhalt von Zeilen ändern
d$a <- NULL             # Löscht Spalte a
#d[2,] <- NULL          ## Error
d <- d[-2,,drop=FALSE]  # Löscht Zeile 2

d <- data.frame(a=1:4, b=4:1, g=c("x","y"),h=c("k","k","k","l"))
aggregate(a ~ g, d, mean) # x 2, y 3;Funktion je Gruppe anwenden
aggregate(a ~ g, d, sum)  # x 4, y 6
rowsum(d$a, d$g)          # x 4, y 6; Bei Summierung schneller
tapply(d$a, d$g, sum)     # x 4, y 6; Für einzelne Spalten
xtabs(a ~ g, d)           # x 4, y 6; Alternative
aggregate(a ~ g + h, d, sum) #   g h a; Mehrere Gruppen
                             # 1 x k 4; Als Tabelle
                             # 2 y k 2
                             # 3 y l 4
xtabs(a ~ g + h, d)          #   k l; Mehrere Gruppen
                             # x 4 0; Als Matrix
                             # y 2 4
aggregate(. ~ g, d, sum)  #   g a b; Mehrere Spalten
                          # 1 x 4 6
                          # 2 y 6 4
aggregate(d[1:2], d[3], sum) # Alternativer Aufruf
rowsum(d[1:2], d[,3])     # Schnelle Alternative für Summen
sapply(split(d[1:2], d[3]), colSums) # Alternative

d <- data.frame(a=1:2, b=2:1)
transform(d, a=b, b=a, x=a-b) # a b  x; Zuweisung erst danach
                              # 2 1 -1
                              # 1 2  1
#transform(d, x=a+b, y=x)     ##Error, x nicht gefunden
within(d, {a<-b; b<-a; x<-a-b}) # a b x; Zuordnung sofort
                                # 2 2 0
                                # 1 1 0
within(d, {x<-a+b; y<-x})       # Geht
with(d, a+b)                    # 3 3
attach(d)                       # Zum Suchpfad
a+b                             # 3 3
detach(d)                       # Aus dem Suchpfad

d <- data.frame(x=1:4, g=c("x","y"), t=c(1,1,2,2))
w <- reshape(d, idvar="g", timevar="t", direction="wide")
# g x.1 x.2
# x   1   3
# y   2   4
reshape(w, idvar="g", direction="long")
#     g t x.1
# x.1 x 1   1
# y.1 y 1   2
# x.2 x 2   3
# y.2 y 2   4
\end{lstlisting}


\section{Programmierung}

Es werden Kontrollstrukturen (wenn dann, if), Wiederholungen
bzw.\ Schleifen, Fehlerbehandlung und Funktionen kurz gezeigt.

\subsection{if, else und switch}

\lstinline|if|, \lstinline|else| und \lstinline|switch| zählen zu den
Kontrollstrukturen. \lstinline|if| und \lstinline|else| zählen zu den
Keywords, \lstinline|switch| ist eine Funktion.

\begin{lstlisting}
x <- 5
if (x > 0) {         print("+")
} else if (x == 0) { print("0")
} else               print("-")

if (x > 0) print("+")
if (x > 0) {print("+")}
#else print("!+")    ## Fehler, kein Bezug zu vorigem if
if (x > 0) print("+") else print("!+")
if (x > 0) {print("+")
} else print("!+")

x <- 1:2
#if (x > 0) print("+") ## Fehler, Länge muss 1 sein
x <- NA
#if (x > 0) print("+") ## Fehler, braucht TRUE oder FALSE
x <- NULL
#if (x > 0) print("+") ## Fehler, Länge ist 0
x <- numeric()
#if (x > 0) print("+") ## Fehler, Länge ist 0
\end{lstlisting}

\begin{lstlisting}
x <- c(9,0,2,1,3)
s <- "Mittel"
switch (s,
        Median = median(x),
        Mittel =,            # Geht zur nächsten Zeile
        avg    = mean(x))    # 3
switch (s, sum = sum(x))     # NULL; kein Treffer
switch (s, sum = sum(x), -1) # -1; Angabe für kein Treffer
#switch (1:2, a = 0)         ## Fehler, Länge muss 1 sein
\end{lstlisting}

Daneben gibt es noch \lstinline|ifelse(test, yes, no)|. Sie ist
besonders praktisch für einfache bedingte Ersetzungen, hat jedoch zwei
wesentliche Nachteile:
\begin{itemize}
\item Beide Alternativen \lstinline|yes| und \lstinline|no| werden
  vollständig ausgewertet (auch wenn nur eine benötigt wird).
\item Attribute (z.~B. \lstinline|class|, Datumseigenschaften) gehen
  häufig verloren.
\end{itemize}

\begin{lstlisting}
x <- c(-1:1)
sqrt(x)                      # NaN 0 1; Warung
sqrt(ifelse(x >= 0, x, NaN)) # NaN 0 1; Ohne Warnung
ifelse(x >= 0, sqrt(x), NaN) # NaN 0 1; Warung
sqrt(`[<-`(x, x<0, NaN))     # NaN 0 1; sqrt gibt bei NaN NaN

y <- rep(NaN, length(x))
i <- x >= 0
#i <- which(x >= 0)          # Variante bei wenig TRUE
y[i] <- sqrt(x[i])

x <- seq(as.Date("2000-02-29"), as.Date("2004-10-04"), by = "1 year")
y <- ifelse(as.POSIXlt(x)$mday == 29, x, NA)
y   # 11016    NA    NA    NA 12477; Verliert Attribute
class(y) <- class(x)
y   # "2000-02-29" NA NA NA "2004-02-29"
y2 <- x
y2[as.POSIXlt(x)$mday != 29] <- NA # Effizienter
\end{lstlisting}


\subsection{for, while und repeat}

Mit \lstinline|for|, \lstinline|while| oder \lstinline|repeat| kann man Wiederholungen bzw.\ Schleifen erzeugen.

\begin{lstlisting}
for (i in 1:5) cat(i)  # 12345
i                      # 5; For hat keine eigene Umgebung
for (i in 1:5) {cat(i); i<-i*2} # 12345
i                               # 10
for (i in 1:5) {if (i==3) next; cat(i)} # 1245; Überspringen
for (i in 1:5) {if (i>2) break; cat(i)} # 12; Abbruch

x <- c(3,5,1)
for (y in x) cat(y)               # 351; Direkt
for (i in seq_along(x)) cat(x[i]) # 351; Über Index
cat(x, sep="")                    # 351; Ohne Schleife

x <- 1:1e6
system.time(for (y in x) cat(y))               # 2.756 Sek.
system.time(for (i in seq_along(x)) cat(x[i])) # 3.026 Sek.
system.time(cat(x, sep=""))                    # 0.621 Sek.

i <- 1
while (i <= 5) {
  cat(i)
  i <- i + 1
}                      # 12345

i <- 1
repeat{
  cat(i)
  i <- i + 1
  if(i > 5) break
}                      # 12345
\end{lstlisting}

\subsection{Fehlerbehandlung: try, tryCatch, stop, warning, message}

Fehler können im Program mit \lstinline|try| oder \lstinline|tryCatch| behandelt werden.

\begin{lstlisting}
f1 <- \(x) {
  ret <- NA_real_
  ret <- log(x)
  ret
}
x <- f1("a")
#x                ## Fehler, x nicht gefunden
f1(-1)            # NaN

f2 <- \(x) {
  ret <- NA_real_
  try(ret <- log(x)) # Kein Abbruch
  ret
}
f2("a")           # NA
f2(-1)            # NaN

f3 <- \(x) {
  tryCatch(log(x),
    warning = \(s) {message("Warnung: ", s); NULL},
    error = \(s) {message("Fehler: ", s);  NA_real_},
    finally = {message("Ende")} )
}
x <- f3("a")      # Fehler, Ende
x                 # NA
x <- f3(-1)       # Warnung, Ende
x                 # NULL

f4 <- \(x) {
  tryCatch(log(x),
    error = \(s) {message("Fehler");  NA_real_} )
}
f4("a")           # NA, Fehler
f4(-1)            # NaN, Warnmeldung

f5 <- \(x) {
  tryCatch(withCallingHandlers(log(x),
    warning = \(s) {
      message("Warnung")
      invokeRestart("muffleWarning")} ),
    error = \(s) {message("Fehler");  NA_real_} )
}
f5("a")           # NA, Fehler
f5(-1)            # NaN, Warnung

f6 <- \() {
  stop("Abbruch") # erzeugt Fehler
  42
}
y <- f6()
#y                ## y nicht gefunden

f7 <- \() {
  warning("Achtung") # Warnung, Programm läuft weiter
  42
}
f7()              # 42, Warnmeldung

f8 <- \() {
  message("Info") # Informative Meldung
  42
}
f8()              # 42, Info

f9 <- \(x) { stopifnot(x >= 0); log(x) } # Beenden wenn nicht
f9(0)     # -Inf
f9(-1)    # Fehler in f9(-1) : x >= 0 ist nicht TRUE
\end{lstlisting}


\subsection{Fehlersuche und Debugging}

Mit \lstinline|traceback()| wird der Aufrufstack (die Kette von
Funktionen, die sich gegenseitig aufrufen) zum Zeitpunkt des Fehlers
angezeigt.

Mit \lstinline|debug(fun)| wird eine Funktion dauerhaft, mit
\lstinline|debugonce(fun)| nur beim nächsten Aufruf für interaktives
Debugging markiert.

Mit \lstinline|browser()| kann an beliebiger Stelle gezielt in den
Debugger gesprungen werden.

Im interaktiven Debugger stehen u.\,a. folgende Befehle zur Verfügung:

\begin{description}
  \item[\texttt{n\dots next}:] nächste Anweisung ausführen („step over“)
  \item[\texttt{s\dots step into}:] in den aufgerufenen Funktionsaufruf hineingehen
  \item[\texttt{f\dots finish}:] aktuelle Funktion bis zum Ende ausführen
  \item[\texttt{c\dots continue}:] weiterlaufen bis zum nächsten Breakpoint oder Ende
  \item[\texttt{Q\dots Quit}:] Debugger verlassen und Ausführung abbrechen
  \item[\texttt{where}:] aktuellen Call-Stack anzeigen (äquivalent zu \texttt{traceback()})
  \item[\texttt{beliebiger R-Ausdruck}:] wird direkt im aktuellen Environment ausgewertet, z.\,B. \lstinline|ls()|, \lstinline|x|, \lstinline|head(x)|
\end{description}

\begin{lstlisting}
f <- \(x) g(x)
g <- \(x) {
  h(x) }
h <- \(x) stop("Testfehler")
f(0)        # Fehler in h(x) : Testfehler
traceback() # 4: stop("Testfehler") at #1
            # 3: h(x) at #2; Callstack 3, h(x) in Zeile 2 von g
            # 2: g(x) at #1; Callstack 2, g(x) in Zeile 1 von f
            # 1: f(0)

trace("g", quote(browser()), at=2) # Fügt browser() in g ein
f(0)        # Geht jetzt in Debugging Modus => Interaktiv
body(g)     # Gibt funktion mit eingefügtem tracing code aus
untrace("g")

trace(sum)  # Zeigt an wenn Funktion sum aufgerufen wird
hist(rnorm(100)) # Wird 3-4 mal aufgerufen
untrace(sum)

debug(g)    # Debugging für Funktion g aktivieren
f(0)        # Interaktiv: Q, n, s, c, ... verwenden
undebug(g)  # Debugging wieder ausschalten

debugonce(g) # Debugging einmal aktivieren
f(0)

f <- \(x) {
  browser()   # Ausführung hier anhalten und in Debugger gehen
  x <- x + 1
  x * 2
}
f(0)        # Interaktiv: Q, n, s, c, ... verwenden
\end{lstlisting}


\subsection{Lazy Evaluation}

Funktionsargumente werden erst ausgewertet wenn sie verwendet werden.
Mit \lstinline|delayedAssign| können Zuweisungen auf den Zeitpunkt
ihrer esten Verwendung verschoben werden.

\begin{lstlisting}
f1 <- \(x, y=x) c(x <- x+1, y)
f1(0)                 # 1 1
f2 <- \(x, y=x) c(y, x <- x+1)
f2(0)                 # 0 1

f <- \(x, y=x) print(substitute(y))  # Zeigt unausgewerteten Ausdruck
f(0)                  # x
f(0, 1)               # 1

#y <- x               # Error, x nicht gefunden
delayedAssign("y", x + 1)
# y                   # Error, x nicht gefunden
x <- 0
y                     # 1
x <- 42
y                     # 1
\end{lstlisting}

\subsection{on.exit: Aufruf bei Funktionende}

Mit \lstinline|on.exit| können in einer Funktion Aktionen registriert
werden, die beim Verlassen der Funktion garantiert ausgeführt werden,
unabhängig davon, ob sie regulär endet oder durch einen Fehler
abgebrochen wird.

\begin{lstlisting}
f <- \(x) {
  on.exit(cat("EXIT: "))
  if (x < 0) stop("Error")
  x + 1
}
f(0)       # EXIT: [1] 1
f(-1)      # Fehler in f(-1) : Error, EXIT:
\end{lstlisting}


\subsection{Pipes}

Der native Pipe-Operator \lstinline!|>! ist reiner syntaktischer Zucker 
und \emph{keine} schrittweise Links-nach-Rechts-Ausführung. 

Ein Ausdruck wie \lstinline!x |> f() |> g() |> h()!
wird vor der Auswertung zu \lstinline|h(g(f(x)))| umgeschrieben 
und anschließend nach den üblichen R-Regeln ausgewertet
(insbesondere mit Lazy Evaluation der Funktionsargumente).

Jeder Pipe-Ausdruck lässt sich ersetzen durch:
\begin{itemize}
  \item verschachtelte Funktionsaufrufe: \lstinline!h(g(f(x)))! oder
  \item explizite Zwischenspeicherung:
\begin{lstlisting}
tmp <- f(x)
tmp <- g(tmp)
h(tmp)
\end{lstlisting}
\end{itemize}

Die Pipe ändert weder Semantik noch Auswertungsreihenfolge.
Sie bietet lediglich eine für manche
lesbarere Schreibweise verschachtelter Funktionsaufrufe.

\begin{lstlisting}
1:3 |> sum()           # 6
#1:3 |> sum            ## Error, braucht function call
sum(1:3)               # 6; Äquivalent
quote( 1:3 |> sum() )  # sum(1:3); Syntax transformation

. <- 1:3               # Zwischenwerte explizit speichern
sum(.)                 # 6

1:3 -> .               # Zwischenwerte explizit speichern
sum(.)                 # 6

1:3 ->.; sum(.)        # 6; Bizarro pipe

#1:3 |> `+`(4)         ## Error, nicht unterstützt
1:3 |> (`+`)(4)        # 5 6 7
1:3 |> base::`+`(4)    # 5 6 7
1:3 |>  `+`(4, e2 = _) # 5 6 7

1 |> seq(3)            # 1 2 3; Einfügen erster freier Platz
3 |> seq(from=1)       # 1 2 3
1 |> seq(to=3)         # 1 2 3

3 |> seq(1, to=_)      # 1 2 3; _ ... Platzhalter
#3 |> seq(1, _)        ## Error, _ braucht Namen
"b" |>  paste("a", . = _, "c") # "a b c"; Auch ... benötigt Name 
3 |> (\(.) seq(1, .))() # 1 2 3; Über Funktion
#3 |> rep(x=_, times=_)## Error, _ darf nur einmal vorkommen
3 |> (\(.) rep(., .))() # 3 3 3; Über Funktion

#1:3 |> sum(sqrt(x=_)) ## Error, _ nicht in nested calls
1:3 |> (\(.) sum(sqrt(x=.)))() # 4.146; Über Funktion
#1:3 |> sum(sqrt())    ## Error, kein Argument an sqrt
1:3  |> sum(sqrt(1))   # 7; sum(1:3, sqrt(1))

mtcars |> _$cyl        # 6 6 4 ...; Extraction call
mtcars |> _$cyl[3]     # 4

"x" |> assign(1)       # Kein zusätzliches Environment
x                      # 1
"x" |> (\(.) assign(., 2))() # Im Funktionsenvironment
x                      # 1

f1 <- \(x) { message("f1"); x }
f2 <- \(x) { message("f2"); x }
. <- 0
. <- f1(.)             # f1; Auswertung je Zeile
f2(.)                  # f2 0
0 |> f1() |> f2()      # f2 f1 0; Lazy evaluation
quote(0 |> f1() |> f2()) # f2(f1(0))
f2(f1(0))              # f2 f1 0
\end{lstlisting}

\end{document}


