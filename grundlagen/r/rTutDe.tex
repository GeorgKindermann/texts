\documentclass[10pt,twocolumn]{scrartcl}

\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}

\usepackage{microtype}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

\usepackage{textcomp}
\usepackage{newpxtext}
\usepackage{newpxmath}
\usepackage[scaled=0.75]{beramono}

\usepackage{xpatch}
\usepackage{xcolor}
\usepackage{realboxes}
\definecolor{mygray}{rgb}{0.9,0.9,0.9}

\usepackage{listings}
%\lstdefinelanguage{commentonly}{
%  morecomment=[l]{\#},
%  sensitive=true,
%}
\lstset{literate=%
{Ö}{{\"O}}1
{Ä}{{\"A}}1
{Ü}{{\"U}}1
{ß}{{\ss}}1
{ü}{{\"u}}1
{ä}{{\"a}}1
{ö}{{\"o}}1
{²}{{$^2$}}1
{├}{{|}}1
{─}{{-}}1
{└}{{L}}1
{│}{{|}}1
,basicstyle=\ttfamily%\small
,backgroundcolor=\color{mygray}
,commentstyle=\emph
%,language=commentonly
,language=R
,stringstyle=\emph %\color{red!50!black}
,upquote=true
,aboveskip=0pt
,belowskip=0pt
}
\makeatletter
\xpretocmd\lstinline
  {%
   \bgroup\fboxsep=1.5pt
   \Colorbox{mygray}\bgroup\kern-\fboxsep\vphantom{\ttfamily\char`\\y}%
   \appto\lst@DeInit{\kern-\fboxsep\egroup\egroup}%
  }{}{}
\makeatother

\usepackage{enumitem}
\setlist{nosep}

\usepackage{adjustbox}
\usepackage[a4paper, margin=1mm, includefoot, footskip=15pt]{geometry}

\usepackage[pdftitle={Grundlagen der Statistiksprache R}
, pdfauthor={Georg Kindermann}
, pdfsubject={R}
, pdfkeywords={R, Lang, Progammiersprache, Tutorial, Einführung, German,
               Deutsch}
, pdflang={de-AT-1996}
, colorlinks=true
, linkcolor=blue
, urlcolor=blue
, pdfpagemode=UseNone]{hyperref}

\nonfrenchspacing
\sloppy

\title{Grundlagen der Statistiksprache R}
\author{Georg Kindermann}
%\date{19. Juni 2023}

\begin{document}

\maketitle

%\begin{abstract}
%  Eine kurze Beispielorientierte Einführung in die Statistiksprache R.
%\end{abstract}

\tableofcontents
\smallskip
%\hrule
\noindent
\href{https://www.r-project.org/}{R} kann vorkompiliert vom
\href{https://cran.r-project.org/}{CRAN} (The Comprehensive R Archive
Network) als \href{https://cran.r-project.org/bin/}{Binärdatei} für
das entsprechende Betriebssystem heruntergeladen werden.

Alternativ kann der
\href{https://cran.r-project.org/src/base/R-4/}{Quellcode}
heruntergeladen und lokal kompiliert werden. Unter Linux kann dies
z.B. so erfolgen, wobei die \lstinline|export|-Zeilen und
\lstinline|./configure|-Flags optional sind. Sie dienen der
Geschwindigkeit und besseren Debug-Möglichkeiten:

\begin{lstlisting}[language=sh]
wget https://cran.r-project.org/src/base/R-latest.tar.xz
mkdir R-latest
tar -xf R-latest.tar.xz -C R-latest --strip-components=1
cd R-latest
export CFLAGS="-O3 -march=native -mtune=native -pipe \
 -flto=auto -fwrapv"
export CXXFLAGS="$CFLAGS"
export FFLAGS="-O3 -march=native -mtune=native -pipe \
 -flto=auto -fallow-argument-mismatch"
export FCFLAGS="$FFLAGS"
export LDFLAGS="-flto=auto -Wl,-O2,--as-needed"
./configure --enable-R-shlib --with-blas --with-lapack \
 --enable-memory-profiling
# --disable-memory-profiling --disable-R-profiling # Schneller
make -j$(nproc)
sudo make install
cd ..
#rm R-latest.tar.xz
#rm -r R-latest/
\end{lstlisting}

Nach dem Start kann R interaktiv verwendet werden. Alternativ lässt
sich R auch über verschiedene IDEs (integrierte Entwicklungsumgebung)
oder Texteditoren nutzen. Die gezeigten Codeabschnitte wurden mit R
Version 4.5.2 (2025-10-31) getestet.

Wenn man R startet, kommt man in den interaktiven Modus.
Deren wichtigste Tastenkombinationen sind:
\begin{description}[style=multiline,leftmargin=2cm,nolistsep]
  \item[CTRL+d] Beendet R (EOF) (Linux/Mac)
  \item[CTRL+z] Beendet R (EOF) (Windows)
  \item[CTRL+c] Bricht laufende Berechnungen oder Eingaben ab
  \item[CTRL+l] Löscht die Konsole (nur in manchen Umgebungen)
  \item[Pfeil ↑ / ↓] Navigiert im Befehlverlauf (History)
  \item[CTRL+r] Rückwärtssuche im Befehlverlauf
  \item[Tab] Auto-Vervollständigung
\end{description}

Beim Beenden von R besteht die Möglichkeit, den Arbeitsbereich (Workspace-Image) zu speichern. Dabei werden ausschließlich die Objekte im globalen Environment, also die im Arbeitsspeicher befindlichen R-Objekte, gesichert, nicht jedoch geladene Pakete. Die vorhandenen Objekte kann man mit \lstinline|ls()| oder \lstinline|objects()| auflisten. Wird R in einem Verzeichnis gestartet, in dem eine gespeicherte Arbeitsumgebung (Datei \lstinline|.RData|) vorhanden ist, wird diese beim Start automatisch geladen. So kann man die Arbeit, nach erneutem Laden der benötigten Pakete, an dem Punkt fortsetzen, an dem man aufgehört hat.

Den Arbeitsbereich kann man jederzeit mit \lstinline|save.image()| speichern. Dabei wird standardmäßig die Datei \lstinline|.RData| erstellt, die beim nächsten Start von R im selben Verzeichnis wieder geladen wird. Alternativ kann man auch einen Dateinamen angeben, z.\,B.\ \lstinline|save.image("WSI.RData")| bzw.\ \lstinline|save.image(file = "WSI.RData")|. Diese Datei kann später mit \lstinline|load("WSI.RData")| bzw.\ \lstinline|load(file = "WSI.RData")| geladen werden. Dabei werden existierende Objekte mit gleichem Namen im aktuellen Environment überschrieben.

Für reproduzierbare Analysen empfiehlt sich der Start von R mit der Option \lstinline|--vanilla| (\lstinline|R --vanilla|). In diesem Fall werden weder Konfigurationsdateien (\lstinline|.Rprofile|, \lstinline|.Renviron| etc.) noch ein gespeichertes Workspace-Image geladen, und beim Beenden wird kein neues gespeichert.

Befehle, die in einer Datei gespeichert sind, lassen sich mit \lstinline|R -f FILE| ausführen. Ein einzelner Ausdruck kann mit \lstinline|R -e EXPR| ausgeführt werden, wobei R danach sofort beendet wird, z.,B.\ \lstinline|R -e "summary(iris)"|. In beiden Fällen wird der Arbeitsbereich beim Beenden standardmäßig nicht gespeichert. Möchte man ihn speichern, muss dies mit der Option \lstinline|--save| explizit angegeben werden, z.,B.\ \lstinline|R --save -f FILE| oder \lstinline|R --save -e "x=5"|.

Bei Verwendung von \lstinline|R -f FILE| oder \lstinline|R -e EXPR| werden standardmäßig ebenfalls Konfigurationsdateien sowie ein eventuell vorhandenes Workspace-Image geladen. Wie bereits beschrieben, kann dies durch \lstinline|--vanilla| unterdrückt werden (\lstinline|R --vanilla -f FILE|, \lstinline|R --vanilla -e EXPR|).

Einige Funktionen die teilweise beim Starten von R kurz vorgestellt werden:

\begin{lstlisting}
q()                   # Beendet R (mit Rückfrage)
help()                # Hilfe starten
help.start()          # Öffnet HTML-Hilfesystem
help(q)               # Hilfe zu Befehl q
?q                    # Hilfe zu Befehl q
demo()                # Zeigt verfügbare Demos
demo(lm)              # Demo zur linearen Regression
version               # R-Version anzeigen
sessionInfo()         # Infos zu Umgebung und geladenen Paketen
citation()            # Wie man R zitiert
\end{lstlisting}


\section{Grundlagen}

\subsection{Objekte und Namen}

In R gibt es:
\begin{description}
\item[Objekte] die eigentlichen Daten, die Platz im Arbeitsspeicher belegen.
\item[Namen] (auch \emph{Bindings}, \emph{Symbole} oder umgangssprachlich \emph{Variablen} genannt), die auf Objekte verweisen.
\end{description}
In R wird ein Name verwendet, um auf ein Objekt im Speicher zu verweisen. Diese Bindungen (Name–Objekt-Zuordnungen) werden in Umgebungen (\emph{Environments}) gespeichert. Ein Name ist nicht das Objekt selbst, sondern stellt lediglich die Verbindung zu ihm her und ermöglicht so dessen Verwendung. Mehrere Namen können gleichzeitig auf \emph{dasselbe} Objekt verweisen.

Wird ein durch mehrere Namen referenziertes Objekt über einen dieser Namen modifiziert, legt R in der Regel \emph{vor} der Modifikation eine Kopie an und lässt den modifizierenden Namen anschließend auf diese Kopie zeigen (\emph{Copy-on-Modify}-Semantik).
Bei sehr kleinen Objekte wie \lstinline|1| wird einfach ein neues Objekt erzeugt, statt zuerst eine Kopie zu erstellen.

Ein Name kann jederzeit durch eine neue Zuweisung auf ein anderes Objekt umgebunden werden (\emph{Rebinding}).

Mit \lstinline|rm()| wird ein Name aus der aktuellen Umgebung entfernt. Objekte ohne verbleibende Referenzen werden automatisch vom \emph{Garbage Collector} gelöscht. Der Garbage Collector kann manuell mit \lstinline|gc()| aktiviert werden.

\begin{lstlisting}
1                     # Ein Objekt mit dem Wert 1
x <- 1                # Name x zeigt auf Objekt mit Inhalt 1
x                     # Zeigt den Inhalt des Objekts
get("x")              # 1; Standardweg für dynamische Namen
s <- "x"
get(s)                # 1
tracemem(x)           # Zeigt Speicher auf den x zeigt
y <- x                # y zeigt auf das gleiche Objekt wie x
tracemem(x) == tracemem(y) # TRUE
y <- 2                # y erhält ein neues Objekt mit Wert 2
tracemem(x) == tracemem(y) # FALSE

a <- 1:3                    # Zahlen 1, 2, 3
b <- a
tracemem(a) == tracemem(b)   # TRUE
b[1] <- 0L                   # jetzt wird eine Kopie angelegt
                             # Erstem Element 0 zuweisen
tracemem(a) == tracemem(b)   # FALSE
identical(a, b)              # FALSE; Inhalt unterschiedlich
a[1] <- 0L
identical(a, b)              # TRUE; Inhalte jetzt wieder gleich
tracemem(a) == tracemem(b)   # FALSE; aber verschiedene Objekte
b <- a                       # Zeigen wieder auf gleiches Objekt
tracemem(a) == tracemem(b)   # TRUE
 # Objekt auf das b zeigte wird automatisch gelöscht
\end{lstlisting}

\lstinline|tracemem()| zeigt die Speicheradresse an und meldet jedes Mal, wenn ein Objekt kopiert wird. Dies funktioniert nur, wenn R mit aktiviertem Memory-Profiling kompiliert wurde (überprüfbar mit \lstinline|capabilities("profmem")|). \lstinline|untracemem()| deaktiviert die Meldung bei Objektkopien.

Die interne Funktion \lstinline|.Internal(inspect(x))| zeigt ebenfalls die Speicheradresse sowie weitere interne Informationen, darunter die Anzahl der Namen (REF-Wert), die auf das Objekt zeigen. Sie benötigt kein Memory-Profiling.

\begin{lstlisting}
x <- 1
.Internal(inspect(x))
# @5577ec525cf8 14 REALSXP g0c1 [REF(2)] (len=1, tl=0) 1
y <- x
.Internal(inspect(x))
# @5577ec525cf8 14 REALSXP g0c1 [REF(3)] (len=1, tl=0) 1
rm(x)          # Löscht nur den Namen x, nicht das Objekt
.Internal(inspect(y))
# @5577ec525cf8 14 REALSXP g0c1 [REF(2)] (len=1, tl=0) 1
rm(y)          # Keine Referenz mehr auf Objekt
gc()           # Löst Garbage Collector per Hand aus
\end{lstlisting}

Reguläre Sequenzen (z.\,B.\ \lstinline|1:10000|) werden als \emph{Alternate Representation} (ALTREP) platzsparend gespeichert. Sie belegen erst dann den vollen Speicher, wenn sie verändert werden (Materialisierung).

\lstinline|object.size()| zeigt stets die Größe eines vollständig materialisierten Vektors, während \lstinline|lobstr::obj_size()| die tatsächliche, oft deutlich geringere Speicherbelegung ermittelt. Dazu muss jedoch erst das Paket \lstinline|lobstr| in R mit \lstinline|install.packages("lobstr")| installiert werden, wobei hier meist noch nach einem zu verwendenden Server gefragt wird.

\begin{lstlisting}
x <- 1:10000
object.size(x)       # 40048 bytes
lobstr::obj_size(x)  # 680 B
x[1] <- 0L           # Vector wird wirklich erzeugt
object.size(x)       # 40048 bytes
lobstr::obj_size(x)  # 40.05 kB
\end{lstlisting}

\lstinline|str()| zeigt einen kompakten Überblick über die Struktur eines Objekts.
\lstinline|dput()| erzeugt Code, mit dem man das Objekt rekonstruieren kann.

\begin{lstlisting}
x <- 1:3
str(x)     # int [1:3] 1 2 3
dput(x)    # 1:3
x[1] <- 0L
str(x)     # int [1:3] 0 2 3
dput(x)    # c(0L, 2L, 3L)
\end{lstlisting}

Namen werden aus Buchstaben, Ziffern, \lstinline|.| (Punkt) und \lstinline|_| (Unterstrich) gebildet. Sie sollten weder mit \_ noch mit einer Zahl anfangen und nicht zu den reservierten Wörtern gehören, die man mit \lstinline|?Reserved| ansehen kann. Namen, die nicht diesen Regeln folgen oder syntaktisch zweideutig sind, müssen mit Backticks geschrieben werden (z.\,B.\ \lstinline|`_`| oder \lstinline|`in`|).

\begin{lstlisting}
x <- 1
#_x <- 1   ## Error, unerwartetes Symbol
#1x <- 1   ## Error, unerwartetes Symbol
#in <- 1   ## Error, Unerwartete(s) 'in'
.x <- 1
#.1 <- 1   ## Error, ungültige linke Seite
`_` <- 1
`_`        # 1
"_" <- 2
`_`        # 2
'_' <- 3
`_`        # 3
`2` <- 1
`2`        # 1
`in` <- 1
`in`       # 1
`.1` <- 1
`.1`       # 1
\end{lstlisting}


\subsection{Zuweisungen}

Eine Zuweisung bindet einen Namen an ein Objekt oder ändert eine bestehende Bindung.

R kennt mehrere Syntaxvarianten:

\begin{lstlisting}
x <- 1          # Häufig verwendete Form
2 -> x          # Äquivalent zu <-
x = 3           # Ebenfalls möglich
`<-`(x, 4)      # Funktionale Form

assign("x", 5)  # Standardweg für dynamische Namen
s <- "x"
assign(s,   6)  # Bindet an Name der in s steht

eval(parse(text = paste(s, "<- 7"))) # Alternative
\end{lstlisting}

Der Operator \lstinline|=| wird außerdem verwendet, um Argumente oder Elemente zu benennen:

\begin{lstlisting}
c(x = 0)        # Erstes Element hat den Namen x
c(x <- 9)       # Zuweisung! Element hat KEINEN Namen
x               # 9
\end{lstlisting}

In R wird die Zuweisung eines Objekts zu einem Namen üblicherweise mit \lstinline|<-| vorgenommen, während für die Übergabe benannter Argumente an Funktionen immer \lstinline|=| verwendet werden muss. Der Name verweist dabei auf das Objekt, ist aber nicht das Objekt selbst. Durch die Verwendung von \lstinline|<-| wird  diese Bindung deutlich dargestellt.

Bei jedem Funktionsaufruf entsteht ein eigenes, temporäres Ausführungs-Environment, dessen Elternumgebung das Environment ist, in dem die Funktion definiert wurde.

Normale Zuweisungen mit \lstinline|<-| oder \lstinline|=| erzeugen Bindings ausschließlich im lokalen Ausführungs-Environment und verändern äußere Umgebungen nicht.

Der Super-Assignment-Operator \lstinline|<<-| (bzw.\ \lstinline|->>|) durchsucht die Elternumgebungen nach einem bestehenden Binding. 
Existiert der Name in einer dieser Umgebungen, wird das Binding dort geändert. 
Wird der Name nicht gefunden, wird er im \lstinline|.GlobalEnv| angelegt oder eine dort bereits bestehende Bindung aktualisiert, unabhängig davon, ob das \lstinline|.GlobalEnv| auf dem Suchpfad der aktuellen Umgebung liegt.
Im lokalen Ausführungs-Environment wird dabei nie eine vorhandene Bindung verändert und auch keine neue angelegt, ausser man befindet sich im GlobalEnv.

\begin{lstlisting}
i <- 1
j <- 2
f <- function() {    # Erzeugt eine Funktion
  i <-  30    # Neues lokales i (verdeckt in f globales)
  j <-  0
  j <<- 40    # Findet und überschreibt das globale
  cat(j)
  k <-  50    # Nur lokal
  l <<- 60 }  # Wird global angelegt
f()           # 0; Ruft Funktion auf
i   # 1
j   # 40
#k  ## Error, nicht gefunden
l   # 60
\end{lstlisting}

Bindungen können mit \lstinline|lockBinding()| gesperrt und mit \lstinline|unlockBinding()| wieder entsperrt werden.

\begin{lstlisting}
x <- 0
lockBinding("x", globalenv())  # Sperren
#x <- 1                        ## Error, gesperrt
unlockBinding("x", globalenv())
x <- 2
lockBinding("x", globalenv())
rm(x)                          # Geht
\end{lstlisting}

Mit \lstinline|delayedAssign| können Zuweisungen auf den Zeitpunkt
ihrer esten Verwendung verschoben werden.

\begin{lstlisting}
#y <- x               # Error, x nicht gefunden
delayedAssign("y", x + 1)
# y                   # Error, x nicht gefunden
x <- 0
y                     # 1
x <- 42
y                     # 1
\end{lstlisting}


\subsection{Environment (Umgebung)}

Ein Environment kann man sich wie ein Blatt Papier vorstellen, auf dem Name--Adresse--Paare stehen.
Das Environment selbst ist ebenfalls ein Objekt und kann über einen Namen referenziert werden. Jedes Environment enthält (als Speicheradresse) einen Verweis auf das nächste Blatt (\emph{Parent Environment}), in dem weitergesucht wird, falls ein Name auf diesem Blatt nicht gefunden wird (\emph{Lexical Scoping}).
Jedes Environment hat genau ein Parent. R erzwingt strikt, dass diese Parent-Kette hierarchisch und nicht zyklisch ist. Es kann jedoch mehrere voneinander unabhängige Parent-Ketten geben.
Das Parent eines Environments kann, mit Ausnahme des leeren Environments, auf ein anderes Environment gesetzt werden, solange dadurch keine zyklische Struktur entsteht.
Jede Parent-Kette endet im leeren Environment (\lstinline|emptyenv()|).
\lstinline|environment()| gibt das aktuelle Environment zurück (in interaktiven Sitzungen meist das GlobalEnv, in Funktionen das Funktionsenvironment).
\lstinline|new.env()| erzeugt ein neues Environment,
\lstinline|parent.env()| zeigt das Elternenvironment.

\begin{lstlisting}
environment()     # <environment: R_GlobalEnv>
e <- new.env()    # Erzeugt neues Environment und bindet es an e
e                 # <environment: 0x55b8959188f8>; Adresse
parent.env(e)     # <environment: R_GlobalEnv>;Elternenvironment
#get("x", e)      ## Error, x nicht gefunden
exists("x", e)    # FALSE
x <- 0
get("x", e)       # 0; findet x im globalEnv
#get("x", e, inherits = FALSE) ## Error, x nicht gefunden
get0("x", e, inherits = FALSE) # NULL; NULL weil nicht gefunden
exists("x", e, inherits = FALSE) # FALSE
e[["x"]]          # NULL; Sucht x nur in e
e$x               # NULL; Sucht x nur in e
e$x <- 1          # e enthält nun x
#assign("x", 1, e) # Alternative
get("x", e)       # 1; findet x in e
e[["x"]]          # 1
e$x               # 1
y <- 0
get("y", e)       # 0; findet y im globalEnv
parent.env(e) <- emptyenv() # Neues Parent Environment
#get("y", e)      ## Error, y nicht gefunden
#parent.env(e) <- e  ## Error, zyklisch Kette
ls(e)             # "x"; Zeigt Namen in e

e <- new.env(parent = emptyenv()) # Parent angegeben
e$x               # NULL

e <- emptyenv()
e                 # <environment: R_EmptyEnv>
#parent.env(e)    ## Error, hat keinen Parent
#parent.env(e) <- emptyenv() ## Error, emptyEnv hat kein Parent
e$x               # NULL
e$x <- 2          # Error, leere Umgebung
\end{lstlisting}

Ein Environment kann Namen enthalten, die auf andere Environments zeigen.
Namen innerhalb eines Environments können auch wieder auf dasselbe Environment verweisen und dadurch zyklische Referenzen bilden.

\begin{lstlisting}
e <- new.env()
e$x <- 1          # e enthält nun x  
e$e <- e          # e zeigt auf sich selbst
e$e$x             # 1
e$e$e$x           # 1
e$e$e$e$x         # 1
e$eb <- e         # e zeigt mit weiteren Namen auf sich selbst
e$eb$x            # 1
e$eb$e$eb$x       # 1
e$x <- 2
e$eb$e$eb$x       # 2
\end{lstlisting}

Innerhalb eines Environments kann die Namenssuche mittels Hash-Lookup erfolgen, also über einen schnellen Schlüsselindex.

\begin{lstlisting}
e1 <- new.env()
e2 <- new.env(hash = FALSE) # Nicht mit Hash suchen
env.profile(e1)             # Info zur Hash Suche
env.profile(e2)             # NULL; keine Hash Suche
lobstr::obj_size(e1)        # 336 B
lobstr::obj_size(e2)        #  56 B
\end{lstlisting}

Im Gegensatz zu einer Liste ist ein Environment referenzbasiert (Environments werden gewöhnlich nicht kopiert), besitzt keine feste Reihenfolge seiner Elemente und verfügt stets über ein Parent-Environment. Mit \lstinline|rlang::env_clone()| kann man ein Environment kopieren.

\begin{lstlisting}[language=R]
e1 <- new.env()
e1$a <- 1
e2 <- e1      # e2 zeigt auf e1
e2$a <- 2     # ohne copy on modify
e1$a          # 2
e1[["a"]]     # 2

e3 <- rlang::env_clone(e1, parent.env(e1))
e3$a          # 2
e3$a <- 3
e3$a          # 3
e1$a          # 2

# Geht nicht für unevaluated promises
e4 <- list2env(as.list(e1, all.names=TRUE), parent=parent.env(e1))
e4$a          # 2
e4$a <- 3
e4$a          # 3
e1$a          # 2

e5 <- attach(e1)
parent.env(e5) <- parent.env(e1)
detach()
e5$a          # 2
e5$a <- 3
e5$a          # 3
e1$a          # 2

x <- list(a = 1)
y <- x        # y zeigt auf x
y$a <- 2      #  mit copy on modify
x$a           # 1
\end{lstlisting}

Man kann Environments mit \lstinline|lockEnvironment()| gegen Änderungen sperren. Die Sperre eines Environments kann nicht deaktiviert werden. Es können auch die Bindungen gesperrt werden, welche wieder entsperrt werden können.

\begin{lstlisting}
e <- new.env()
e$x <- 0
lockEnvironment(e)
#e$y <- 1    ## Error, nicht hinzufügbar
e$x <- 2     # Jedoch Bindung veränderbar
lockEnvironment(e, TRUE)  # Sperrt auch Bindungen
#e$x <- 3    ## Error, nicht änderbar
unlockBinding("x", e)
e$x <- 4
\end{lstlisting}


\subsection{Funktionen}

Funktionen sind wiederverwendbare Codebausteine, mit denen sich Programme in übersichtliche Module mit klar definierten Schnittstellen und Aufgaben gliedern lassen.

Funktionen werden mit \lstinline|function()| oder mit \lstinline|\()| erzeugt. \lstinline|function()| und \lstinline|\()| sind vollständig äquivalent.


\subsubsection{Body -- Funktionskörper}

Der \emph{Funktionskörper} (Body), also der beim Funktionsaufruf auszuführende Code, kann mit \lstinline|body()| angezeigt und auch verändert werden.

\begin{lstlisting}
f <- function() 0  # Erzeugt Funktion f
#f <- \() 0        # Alternative
f                  # function() 0; Gibt Funktion zurück
f()                # 0; Ruft Funktion auf

body(f)            # 0; Funktionskörper
body(f) <- 1       # Ändert Funktionskörper
f()                # 1

g <- \(x) x * 2
g(1)               # 2
body(g) <- quote(x * 3)
g(1)               # 3
\end{lstlisting}

\lstinline|quote()| gibt seine Argumente unausgewertet (not evaluated) zurück

Besteht der \emph{Funktionskörper} aus mehr als einem Element werden diese in geschweiften Klammern \lstinline|{}| geschrieben.

\begin{lstlisting}
f <- \() {x <- sum(1:3); x / 2} # kompakte Schreibweise
g <- \() {                      # explizit bzw. formatiert
  x <- sum(1:3)
  x / 2
}
\end{lstlisting}

Funktionen geben ihren letzten evaluierten Ausdruck zurück.
Zusätzlich gibt es noch den Befehl \lstinline|return()| welcher die Funktion beendet und ebenfalls einen evaluierten Ausdruck oder \lstinline|NULL| zurück gibt.
\lstinline|return()| ist optional und dient vor allem der frühen Rückgabe oder zur besseren Lesbarkeit.

\begin{lstlisting}
f <- \() {
  4
  2
}
f()       # 2
g <- \() {
  return(4)
  2
}
g()       # 4
\end{lstlisting}

Funktionen liefern immer einen Rückgabewert, solange sie nicht durch einen Fehler abgebrochen werden. Mit \lstinline|invisible()| lässt sich jedoch verhindern, dass dieser Wert auf der Konsole ausgegeben wird.

\begin{lstlisting}
f <- \() invisible()
f()                  # Auf der Konsole erscheint nichts
x <- f()
x                    # NULL

g <- \() invisible(1)
g()                  # Auf der Konsole erscheint nichts
x <- g()
x                    # 1

h <- \() stop()      # stop löst einen Fehler aus
#y <- h()            ## Error; Funktion wird abgebrochen
#y                   ## Fehler, y nicht gefunden
\end{lstlisting}

Funktionen können sich selber aufrufen (\emph{rekursiv}). Dabei muss darauf geachtet werden, dass die Rekursion irgendwann terminiert. Die maximale Anzahl gleichzeitig ausgewerteter verschachtelter Ausdrücke kann mit \lstinline|options("expressions")| eingestellt werden.

\begin{lstlisting}
f <- \(n) if (n > 0) n + f(n-1) else n
f(3)          # 6; Rekursiv

options("expressions")        # 5000
g <- \(n) {n <<- n; g(n+1L)}
g(1L)                         ## Löst Fehler aus
n                             # 4997
options(expressions = 1000)
g(1L)                         ## Löst Fehler aus
n                             # 998

options(expressions = 25)
h <- \(x) x + 1
h(h(h(h(h(h(h(h(0))))))))     # 8
#h(h(h(h(h(h(h(h(h(0))))))))) ## Error, zu tief verschachtelt
\end{lstlisting}

\subsubsection{Formals -- Funktionsparameter}

An Funktionen können \emph{Argumente} übergeben werden. Dazu werden bei der Funktionserstellung \emph{Parameter} (\emph{Formals} bzw. \emph{Formal Arguments}) in der runden Klammer angegeben, welche die Funktion bei ihrem Aufruf erwartet. Mit dem Befehl \lstinline|formals()| können diese angezeigt und auch verändert werden.

\begin{lstlisting}
f <- \(x) x   # x .. Parameter
f(4)          # 4; 4 .. übergebenes Argument
f(2)          # 2
#f()          ## Error, Argument x fehlt

g <- \(x) 0
g()           # 0; Geht da x nie verwendet wird
g(1)          # 0
#g(1, 2)      ## Error, unbenutztes Argument

formals(f)    # $x;  Zeigt Funktionsparameter
\end{lstlisting}

Mit \lstinline|missing()| kann getestet werden ob Argument übergeben wurde.

\begin{lstlisting}
f <- \(x) missing(x)
f()                  # TRUE
f(1)                 # FALSE
x <- 0
f()                  # TRUE; x wird auch hier nicht übergeben
\end{lstlisting}

Die Parameterliste legt Namen, Reihenfolge und Default-Werte der zu übergebenden Argumente fest.

\begin{lstlisting}
f <- \(x, y = 0) x - y # y hat Defaultwert
f(3, 1)                # 2; 3 wird x, 1 wird y .. 3 - 1
f(3)                   # 3; y erhält Defaultwert 0 .. 3 - 0

formals(f)             # $x $y 0
formals(f)$y <- 1      # Setzt Defaultwert von y auf 1
f(3)                   # 2
formals(f) <- alist(y = , x = 3) # Setzt neue formals
f(1)                   # 2

g <- f
formals(f)$x <- 2      # Ändert formals mit Copy on Modify
f(1)                   # 1; f wurde geändert und dabei kopiert
g(1)                   # 2; g bleibt wie es ist

h <- \(x=0) missing(x)
h()   # TRUE; x hat zwar Defaultwert, wurde aber nicht übergeben
\end{lstlisting}

Explizit \emph{übergebene Argumente} werden im \emph{Calling
Environment} ausgewertet. \emph{Default-Argumente} werden im
\emph{Enclosing Environment} ausgewertet.

\begin{lstlisting}
e <- new.env()
e$x <- 1
f <- with(e, \(y = x) y)
f()             # 1; aus Enclosing Environment e
x <- 2
f(x)            # 2; aus Calling Environment
\end{lstlisting}

Ein Defaultwert kann nicht denselben Namen wie der Parameter haben, weil in diesem Fall der Defaultwert auf das Promise des Parameters verweist und sich somit beim Auswerten selbst referenziert, obwohl er noch keinen Wert hat.

\begin{lstlisting}
f <- \(x = x) x
#f()                 ## Error, rekursive Referenz
\end{lstlisting}

Es können auch Funktionen übergeben werden.

\begin{lstlisting}
f7 <- \(a, b) a(b) # Argument a ist eine Funktion
f7(mean, 1:3)  # 2
f7(sum , 1:3)  # 6
\end{lstlisting}


\paragraph{Argument Matching}

Beim Funktionsaufruf kann der Name der Argumente angegeben werden.

\begin{lstlisting}
f <- \(x, y = 0) x - y
f(y = 1, x = 3)        # 2
\end{lstlisting}

Bei einem Funktionsaufruf werden die übergebenen \emph{Argumente} den formalen \emph{Parametern} gemäß folgender Priorität zugeordnet:

\begin{enumerate}
  \item Exakter Name  
  \item Partieller Name (eindeutiger Präfix eines formalen Arguments)
  \item Position  
\end{enumerate}

Dadurch können Argumente frei kombiniert (positional und per Name) übergeben werden.

\begin{lstlisting}
f <- function(x, xa, ya, yb, za) cat(x, xa, ya, yb, za)
f(1, 2, 3, 4, 5)         # 1 2 3 4 5; Position
f(1, 2, 3, 4, x=5)       # 5 1 2 3 4; exakter Name + Position
f(1, 2, 3, 4, xa=5)      # 1 5 2 3 4; exakter Name + Position
#f(1, 2, 3, x=4, x=5)    ## Error, x passt zu mehreren
#f(1, 2, 3, 4, y=5)      ## Error, y mehrdeutig ya oder yb
f(z=1, 2, 3, 4, 5)     # 2 3 4 5 1; Partieller Name und Position
#f(zak=1, 2, 3, 4, 5)    ## Error, unbenutztes Argument zak
\end{lstlisting}

Auch wenn Funktionsaufrufe mittels Position oder partiellem Matching kompakter sind, ist der Aufruf mittels Exakter Namen meist nachvollziehbarer. Mit \lstinline|options(warnPartialMatchArgs = TRUE)| wird bei jedem partiellem Matching eine Warnmeldung angezeigt.

\paragraph{Ellipsis (...)}

Die Ellipsis \lstinline|...| fängt alle nicht explizit definierten Argumente auf und ermöglicht deren unveränderte Weitergabe an andere Funktionen.

Die einfachste Nutzung besteht darin, \lstinline|...| an eine andere Funktion
durchzureichen. Dadurch kann eine Funktion zusätzliche Argumente akzeptieren,
ohne sie selbst zu kennen oder auszuwerten.

\begin{lstlisting}
fx <- \(x) x
fx(1)           # 1
fx(x=1)         # 1
#fx(y=1)        ## Error, unbenutztes Argument
#fx(1, 2)       ## Error, unbenutztes Argument
#fx()           ## Error, Argument x fehlt
#
f <- \(...) fx(...) # Weitergabe von ... an fx
f(1)            # 1
f(x=1)          # 1
#f(y=1)         ## Error, unbenutztes Argument
#f(1, 2)        ## Error, unbenutztes Argument
\end{lstlisting}

Beim Matching von Argumenten können Konflikte entstehen, wenn benannte
Argumente in \lstinline|...| auf Funktionsparameter einer Ziel-Funktion passen.
Dies betrifft sowohl fehlende als auch mehrdeutige Zuordnungen.

\begin{lstlisting}
fx <- \(x, y=0) x + y  # Defaultwert für y
fx(1)           # 1
#fx(y=1)        ## Error, kein x
fx(1, 2)        # 3
fx(1, 2, 3)     ## Error, unbenutztes Argument

fx <- \(x, ...) x
#fx(y=1)        ## Error, Argument x fehlt
fx(1, 2)        # 1
fx(1, a=1, a=2) # 1; 2 mal a! ... wird nicht ausgewertet
#
f <- \(x, ...) fx(...) # Vermeiden da x nur unbenannt an fx geht
#f(1)           ## Error, Argument x fehlt für fx
f(1, 2)         # 2
f(x=1, 2)       # 2; 
#f(x=1, x=2)    ## Error, x passt zu mehreren Argumenten
f(x=1, y=2)     ## Error, Argument x fehlt für fx
#
f <- \(y, ...) fx(...)
f(1, 2)         # 2
f(x=1, 2)       # 1
f(x=1, y=2)     # 1
\end{lstlisting}

R stellt Funktionen bereit, um direkt auf einzelne Elemente der
Ellipsis zuzugreifen ohne diese auszuwerten. Der Zugriff kann über \lstinline|..1| für das erste, \lstinline|..2| zweite \dots Element erfolgen.

\begin{lstlisting}
f <- \(x, ...) ..2  # zweites Element von ...
f(1, 2, 3, 4)   # 3
f(1, 2, 3, x=4) # 2
f(1, 2, 3, y=4) # 3
#f()            ## Error, ..2 nicht vorhanden
\end{lstlisting}

Alternativ kann auch \lstinline|...elt(1)|, \lstinline|...elt(2)|, \dots verwendet werden.

\begin{lstlisting}
f <- \(x, ...) ...elt(2)  # zweites Element von ...
f(1, 2, 3, 4)   # 3
\end{lstlisting}

\lstinline|...length()| zeigt die Länge der Ellipsis und wertet die Argumente nicht aus.

\begin{lstlisting}
f <- \(x, ...) ...length()  # Länge von ...
f()             # 0
f(1, 2, 3)      # 2, weil x=1 nicht in ... ist
f(1, cat("a"))  # 1; Wertet Argumente nicht aus
\end{lstlisting}

\lstinline|...names()| zeigt die Namen der Ellipsis und wertet die Argumente nicht aus.

\begin{lstlisting}
f <- \(...) ...names()  # Namen von ...
f(1, 2)         # NULL
f(1, a=1, a=2)  # "" "a" "a"
f(1, cat("a"))  # NULL; Wertet Argumente nicht aus
\end{lstlisting}

Alternativ kann \lstinline|...| auch in eine Liste umgewandelt werden, wobei die Argumente ausgewertet werden.

\begin{lstlisting}
f1 <- \(x, ...) list(...)[[2]]     # Zweites Element
f1(1, cat("Z"), 3, 4)   # Z 3; list wertet Argumente aus

f2 <- \(x, ...) length(list(...))  # Länge von ...
f2(1, cat("a"), 3)    # a 2

f3 <- \(...) names(list(...))      # Namen von ...
f3(1, a=1, a=2)       # "" "a" "a"
f3(a=1, b=cat("Z"))   # Z "a" "b"
\end{lstlisting}

\paragraph{Lazy Evaluation}

Funktionsargumente werden erst bei ihrer ersten Verwendung ausgewertet (\emph{Lazy Evaluation}). Bis dahin liegen sie als sogenannte \emph{Promises} vor, unevaluierte Ausdrücke mit zugehörigem Environment. Dies gilt auch für Defaultargumente, die ebenfalls erst beim ersten Zugriff berechnet werden und daher von der Umgebung zum Zeitpunkt ihrer Auswertung abhängen können.
Explizit \emph{übergebene Argumente} werden im \emph{Calling Environment}, \emph{Default-Argumente} im \emph{Enclosing Environment} der Funktion ausgewertet. Wird ein Promise zum ersten Mal benötigt, wird es einmalig ausgewertet. Der resultierende Wert wird im Promise selbst gespeichert, das im Execution Environment der Funktion liegt. Weitere Zugriffe verwenden dann diesen zwischengespeicherten Wert. Der Parameternamen kann jedoch später im Execution Environment neu gebunden werden (z.,B.\ mittels \lstinline|<-|).

Wird ein Promise zum ersten Mal benötigt, wird es einmalig ausgewertet und der resultierende Wert für alle weiteren Zugriffe im selben Funktionsaufruf zwischengespeichert.

Eine Auswertung kann mittels \lstinline|force()| oder einfach anführen des Namens erfolgen.

\begin{lstlisting}
f1 <- \(x, y=x) c(x <- x+1, y)
f1(0)                 # 1 1

f2 <- \(x, y=x) c(y, x <- x+1)
f2(0)                 # 0 1

f3 <- \(x, y=x) {force(y); c(x <- x+1, y)}
f3(0)                 # 0 1

f4 <- \(x, y=x) {y; c(x <- x+1, y)}
f4(0)                 # 0 1
\end{lstlisting}

Da Argumente vor ihrer ersten Verwendung reine Ausdrücke sind, kann dies mit
\lstinline{substitute()} sichtbar gemacht werden.

\begin{lstlisting}
f <- \(x, y=x) print(substitute(y))  # Zeigt unausgewerteten Ausdruck
f(0)                  # zeigt den Ausdruck: x
f(0, 1)               #     zeigt den Wert: 1
f(0, xyz)             # zeigt den Ausdruck: xyz
\end{lstlisting}

Die Funktion \lstinline|substitute()| gibt den übergebenen Ausdruck in
\emph{nicht ausgewerteter Form} zurück. Das heißt, sie liefert den
syntaktischen Ausdruck (eine sogenannte Language- oder Symbol-Struktur),
den R an dieser Stelle erhalten hat, ohne ihn zu evaluieren.


\subsubsection{Environment -- Funktionsumgebungen}

Bei einem Funktionsaufruf erzeugt R ein temporäres \emph{Execution Environment} (auch \emph{Evaluation Environment genannt},  Ausführungsumgebung), dessen Parent das \emph{Enclosing Environment} der Funktion ist. In diesem Execution Environment befinden sich während der Ausführung die Parameter sowie alle lokal erzeugten Namen.

Das Execution Environment ist temporär und wird nach dem Funktionsaufruf verworfen. Es sei denn,
\begin{itemize}
\item es wird an einen Namen in einem dauerhaften Environment gebunden, oder
\item es wird direkt von der Funktion zurückgegeben, oder
\item es bleibt als Enclosing Environment einer neu erzeugten Funktion erhalten, die entweder zurückgegeben oder in einem dauerhaften Environment gebunden wird.
\end{itemize}

Funktionen, die andere Funktionen zurückgeben, heißen \emph{function factories}.
Die zurückgegebene Funktion ist eine Closure und behält ihr enclosing environment.
Dadurch bleiben alle in diesem Environment gebundenen Objekte erhalten.
Dies ermöglicht z.\,B.\ die Speicherung von Zustand zwischen Aufrufen (Zähler, Zwischenergebnisse, Parameter).
Um unnötige Speicherbelegung zu vermeiden, sollten nicht benötigte Objekte vor der Rückgabe des Closure mit \lstinline|rm()| entfernt werden.

\begin{lstlisting}
f1 <- \() {x <- 1; ef1 <<- environment()}
f1()           # bindet sein Execution Environment an ef1
ef1$x          # 1; Execution Environment von f1

f2 <- \() {x <- 2; environment()}
ef2 <- f2()    # gibt Execution Environment zurück
ef2$x          # 2

f3 <- \() {x <- 3; f4 <<- \() x}
f3()           # Bindet erzeugte Funktion an f4
f4()           # 3
environment(f4)$x # 3
environment(f4)$x <- 4
f4()           # 4

f5 <- \() {x <- 5; \() x}
f6 <- f5()     # Gibt Funktion zurück
f6()           # 5
environment(f6)$x <- 6
f6()           # 6
\end{lstlisting}

Bei Funktionen kann man folgende Environments unterscheiden:

\begin{description}
  \item[Binding Environment:] Das Environment, in dem der Funktionsname gebunden ist (wo der Name gefunden wird). Ein Funktionsobjekt kann unter mehreren Namen in verschiedenen Environments gebunden sein. Das Binding Environment spielt für die spätere Namenssuche innerhalb der Funktion keine Rolle.
  \item[Enclosing Environment:] Das Environment, in dem das Funktionsobjekt ursprünglich erzeugt wurde, welches jedoch nachträglich geändert werden kann. Dieses Environment bestimmt die Environment-Kette, entlang der die Funktion nach Namen sucht. 
  \item[Execution Environment:] Das bei jedem Funktionsaufruf neu erzeugte Environment, in dem lokale Variablen entstehen.
  \item[Calling Environment:] Das Environment, aus dem die Funktion aufgerufen wurde. In den meisten Fällen ist es das Environment des \emph{Parent-Frames} (vgl.\ \lstinline|parent.frame()|). Bevor die Ausführung der Funktion beginnt, werden die Ausdrücke der Argumente im Calling Environment lokalisert und als \emph{Promises} im Execution Environment den formalen Parametern zugewiesen. Die Auswertung (force) der Promises erfolgt erst beim ersten Zugriff innerhalb der Funktion (lazy evaluation).
\end{description}

Funktionen suchen Namen weder entlang der Environment-Kette ihres Aufrufortes (Calling Environment) noch entlang der Environment-Kette, in der der Funktionsname gefunden wurde (Binding Environment), sondern entlang der Environment-Kette ihres \emph{Enclosing Environments}.
Die Namenssuche beginnt im Execution Environment. Wenn ein Name dort nicht gefunden wird, sucht R im Enclosing Environment der Funktion und dann in der übergeordneten Environment-Kette.

Mehrere Funktionen können dasselbe Environment nutzen. Das Enclosing Environment ist ein dauerhaftes Environment, in dem Variablen gespeichert werden können.

\begin{lstlisting}
f1 <- \() x
#f()           ## Fehler, x nicht gefunden
x <- 1
f1()           # 1; greift jetzt auf globales x zu

f2 <- \() {x <- 2; x} # Erzeugt lokales x
f2()           # 2; greift auf lokales x zu

f3 <- \() {x <<- 3; x} # Verändert x in Parent
f3()           # 3
f1()           # 3

f4 <- local(\() x)
f4()           # 3; greift auf globales x zu
environment(f4)$x <- 4
f4()           # 4; greift auf lokales x zu
x              # 3

f5 <- local({n=0L; \() {n <<- n+1L; n}})
f5()           # 1
f5()           # 2
environment(f5)$n <- 8
f5()           # 9
\end{lstlisting}

\lstinline|local()| erzeugt ein Environment, in dem Objekte (z. B. Zähler oder Parameter) dauerhaft für die zurückgegebene Funktion gebunden bleiben.

\begin{lstlisting}
e1 <- new.env()
e1$x <- 1
e2 <- new.env(parent = e1)
e2$f1 <- \() x            # enclosing environment: GlobalEnv
environment(e2$f1)        # R_GlobalEnv
#e2$f1()                  ## Fehler, 'x' nicht gefunden
environment(e2$f1) <- e1  # setzt e1 als enclosing environment
e2$f1()                   # 1

e2$f2 <- with(e2, \() x)  # enclosing environment: e2
e2$f2()                   # 1
e2$x <- 2
e2$f1()                   # 1; Beginnt Suche in e1
e2$f2()                   # 2; Beginnt Suche in e2

e2$f3 <- with(e2, \() x <- 3)
e2$f3()                   # Lokales x
e2$x                      # 2

e2$f4 <- with(e2, \() x <<- 4)
e2$f4()                   # Parent x
e2$x                      # 4
e1$x                      # 1; Nicht geändert

e1$y <- 0
e2$f5 <- with(e2, \() y <<- 5)
e2$f5()                   # Parent y
e2$y                      # NULL
e1$y                      # 5

e2$f6 <- with(baseenv(), \() z <<- 6)
e2$f6()                   # z Nicht gefunden => globalEnv
z                         # 6

f7 <- \() x <- 0
environment(f7) <- emptyenv()
#f7()                     ## Fehler Funkion "<-" nicht gefunden
\end{lstlisting}

Mit \lstinline|with()| kann ein Ausdruck (Expression) in einem bestimmten Environment ausgeführt werden, womit es zum Enclosing Environment einer erzeugten Funktion wird.

\lstinline|environment(f) <- env| ändert das Enclosing Environment einer Funktion. Das Enclosing Environment einer Funktion aus einem Package ist in der Regel ein \emph{Namespace-Environment}. Dieses Environment und seine Bindungen sind unveränderlich (locked bindings). Wenn man versucht, das Enclosing Environment einer Paketfunktion zu ändern, wird nicht das Original verändert, sondern es wird eine Kopie der Funktion im aufrufenden Environment angelegt, solange dieses modifizierbar ist.

\begin{lstlisting}
environment(sd)    # <environment: namespace:stats>
e1 <- new.env()
e2 <- new.env()
with(e1, environment(sd) <- e2)
environment(sd)    # <environment: namespace:stats>
environment(e1$sd) # <environment: 0x55a8d83c7308>
e2                 # <environment: 0x55a8d83c7308>
#with(baseenv(), environment(sd) <- baseenv()) ## Error
e1$sd(1:3)         # 1
environment(e1$sd) <- emptyenv()
#e1$sd(1:3)        ## Error, findet sqrt nicht
\end{lstlisting}


\subsubsection{Closure}

Eine Funktion in R setzt sich aus drei Komponenten zusammen:

\begin{description}
\item[Formals (Parameterliste):] Liste der formalen Argumente (formal arguments), die die Funktion erwartet. Sie legen Namen, Reihenfolge, Default-Werte und ggf.\ \lstinline|...| fest. Die Liste kann leer sein (Funktion ohne Parameter).
\item[Body (Funktionskörper):] Der eigentliche auszuführende R-Code.
\item[Enclosing Environment:] Es bestimmt, wo nach nicht-lokalen Variablen gesucht wird, falls sie nicht im \emph{execution environment} gefunden werden. Die Suche läuft dann die Elternkette des Enclosing Environments hinauf.
\end{description}

Die Kombination aus \lstinline|formals()|, \lstinline|body()| und \lstinline|environment()| bildet das, was man in R als \emph{Closure} (oder genauer: Funktions-Closure, first-class function) bezeichnet.
Alle nicht-primitiven Funktionen in R sind Closures. Primitive Funktionen (z.~B. \lstinline|+|) existieren nicht als R-Closures und haben daher kein R-Environment. \lstinline|environment(+)| gibt aus diesem Grund \lstinline|NULL| zurück.

\lstinline|formals()| und \lstinline|body()| unterliegen der \emph{Copy-on-Modify}-Semantik. Zeigen zwei verschiedene Funktionsnamen auf dasselbe Closure, wird bei einer Änderung des Formals ausschließlich eine Kopie des Formals gemacht. Eine Änderung des Bodys führt hingegen derzeit zu einer Kopie des Bodys als auch des Formals.

Environments sind \emph{referenzielle} Objekte und werden nicht kopiert.
Daher können zwei verschiedene Funktionsnamen auf dasselbe Closure verweisen und ihr Enclosing Environment unabhängig voneinander verändern, ohne dass Formals oder Body dupliziert werden.

\begin{itemize}
\item \lstinline|environment(f) <-| nur Environment wird geändert, \emph{keine Kopien}
\item \lstinline|formals(f) <-| oder \lstinline|formals(f)$x <-| \emph{nur Formals} werden kopiert
\item \lstinline|body(f) <-| \emph{sowohl Formals als auch Body} werden kopiert
\end{itemize}

\begin{lstlisting}
x <- 1
g <- \(y=0) x + y  # Enclosing environment ist globalEnv
f <- g
f()          # 1; zeigt x vom globalEnv
g()          # 1; zeigt x vom globalEnv

e <- new.env()
e$x <- 2
environment(f) <- e  # Ändert Enclosing Environment
f()          # 2; zeigt x von e
g()          # 1; zeigt x vom globalEnv
tracemem(formals(f)) == tracemem(formals(g)) # TRUE
tracemem(body(f)) == tracemem(body(g))       # TRUE
identical(environment(f), environment(g))    # FALSE

f <- g
formals(f) <- alist(y = 1)  # Ändert Formals
f()          # 2
g()          # 1
tracemem(formals(f)) == tracemem(formals(g)) # FALSE
tracemem(body(f)) == tracemem(body(g))       # TRUE
identical(environment(f), environment(g))    # TRUE

f <- g
body(f) <- quote(x + 1) # Ändert Body
f()          # 2
g()          # 1
tracemem(formals(f)) == tracemem(formals(g)) # FALSE
tracemem(body(f)) == tracemem(body(g))       # FALSE
identical(environment(f), environment(g))    # TRUE
\end{lstlisting}


\subsubsection{Frames}

Neben den Environments gibt es \emph{Frames} (Rahmen, auch \emph{Evaluation Frame} oder \emph{Call Frame} genannt).

Beim Aufruf einer Funktion wird ein neuer Frame erzeugt und mit einem neuen Execution Environment verknüpft.

Das Parent Environment des Execution Environment ist das mit der aufgerufenen Funktion gebundene Enclosing Environment. Und entlang dieser Kette, startend mit dem Execution Environment über das Enclosing Environment und dessen Parent Environments, werden Namen gesucht.

Der Parent Frame (auch calling frame) des neu erzeugten Frames ist das Frame, in dem der aktuelle Funktionsaufruf stattgefunden hat, also das Frame des Aufrufers.  Damit entsteht eine Kette von Frames die der Kette von Funktionen die Funktionen aufrufen entspricht (\emph{Call-Stack} bzw.\ Aufrufkette).

\lstinline|parent.frame()| liefert das \emph{Execution Environment} des aufrufenden Frames.

\begin{lstlisting}
f <- \(n) {
  if (n > 0) {
    f(n-1)
    e <- environment()  # Execution Environment
    cat("n:", n, " Exec -Env: ", format(e), "\n")
    cat("n:", n, " Par  -Env: ", format(parent.env(e)), "\n")
    cat("n:", n, " Par-Frame: ", format(parent.frame()), "\n")
  }
}
f(2)
# n: 1  Exec -Env:  <environment: 0x55d87016d880> 
# n: 1  Par  -Env:  <environment: R_GlobalEnv> 
# n: 1  Par-Frame:  <environment: 0x55d87016da08> 
# n: 2  Exec -Env:  <environment: 0x55d87016da08> 
# n: 2  Par  -Env:  <environment: R_GlobalEnv> 
# n: 2  Par-Frame:  <environment: R_GlobalEnv> 
\end{lstlisting}

Damit ist es möglich abweichend von der üblichen \emph{lexikalischen}
Namenssuche \emph{dynamisch} entlang der Aufrufkette (Call-Stack)
also den Frames und ihren zugehörigen Execution Environments nach Namen
zu suchen.

Die Funktion \lstinline|dynGet()| sucht dynamisch entlang der Aufruferkette

\begin{lstlisting}
f <- \() {x <- 1; g()}
g <- \() {y <- 2; h()}
h <- \() {
# cat(x)      ## Error, x nicht gefunden
# cat(y)      ## Error, y nicht gefunden
  cat("x:", dynGet("x"))
  cat("  y:", dynGet("y"))
}
f()           # x: 1  y: 2
\end{lstlisting}

Dynamische Suche entlang des Call-Stacks (\lstinline|dynGet()|, \lstinline|parent.frame()|) sollte nach Möglichkeit vermieden werden.
In der Dokumentation (\lstinline|?dynGet|) gibt es die Warung: \emph{Mit Vorsicht verwenden} (Use with caution).

Alternativ empfiehlt es sich, benötigte Variablen aus höheren Scopes
explizit als Funktionsargumente zu übergeben, da dies robust,
nachvollziehbar und klar ist.

\begin{lstlisting}
f <- \() {x <- 1; g(x)}
g <- \(x) {y <- 2; h(x, y)}
h <- \(x, y) {
  cat("x:", x)
  cat("  y:", y)
}
f()           # x: 1  y: 2
\end{lstlisting}


\subsubsection{Infix Operator}

Man kann auch eigene Infix Operatoren definieren. Jeder Operator, dessen Name mit \lstinline|%| beginnt und endet (z.~B. \lstinline|%myop%|), wird als Infix-Operator behandelt und hat in der Regel zwei Argumente.
Benutzerdefinierte Infix-Operatoren der Form \lstinline|%myop%| haben dieselbe Priorität und Assoziativität (links nach rechts) wie die speziellen built-in Operatoren \lstinline|%%|, \lstinline|%/%| oder \lstinline|%in%|. Sie liegen in der Operator-Hierarchie über \lstinline|*| und \lstinline|/|, aber unter dem Sequence-Operator \lstinline|:| (siehe ?Syntax).

\begin{lstlisting}
1 + 1      # 2; + ist Infix Operatoren
`+`(1,1)   # 2; Aufruf als Funktion
`%A%` <- \(l,r) l + r
1 %A% 1    # 2
`%A%`(1,1) # 2

`%M%` <- \(l,r) l * r
1 + 2 * 3      # 7
1 %A% 2 %M% 3  # 9; Wird von links nach recht ausgewertet

4 / 1 %A% 1    # 2; Priorität über /
1 %A% 2^2      # 5; Priorität unter ^
\end{lstlisting}

Durch maskieren von bereits vorhandenen Operatoren kann deren Operatorpriorität verwendet werden.

\begin{lstlisting}
`%E%` <- \(l,r) l^r  # Ausnutzung der Operatorpriorität
`:=` <- \(l,r) l * r  # Priorität: ? < := < %myop%
`?` <- \(l,r) l + r  # Überdeckt ? (help) !
2 + 3 * 4^2          # 50
2 ? 3 := 4%E%2       # 50
rm("?")              # ? (help) nicht mehr überdeckt
\end{lstlisting}


\subsubsection{Active Binding}

Man kann mit der Funktion \lstinline|makeActiveBinding()| sogenannte \emph{active bindings} erzeugen. Dabei wird ein Name in einem Environment mit einer Funktion verknüpft, die bei jedem \emph{Lesezugriff} auf das Symbol aufgerufen wird.

\begin{lstlisting}
makeActiveBinding("rnd", \() runif(1), globalenv())
set.seed(0)
rnd              # 0.8966972
rnd              # 0.2655087
#rnd <- 0        ## Error, unbenutztes Argument
\end{lstlisting}

Hat die zugrunde liegende Funktion \emph{keinen} Parameter, schlägt eine Zuweisung mit \lstinline|<-| oder \lstinline|<<-| fehl.
Der Schreibzugriff versucht nämlich, die Funktion mit dem zugewiesenen Wert als Argument aufzurufen, was zu einem Fehler führt.

Besitzt die Funktion hingegen mindestens einen Parameter, wird dieser beim Schreibzugriff mit dem zugewiesenen Ausdruck belegt. Eine Zuweisung ruft die Binding-Funktion also mit dem zugewiesenen Ausdruck als Argument auf.

\begin{lstlisting}
makeActiveBinding("rnd", \(n=1) cat(runif(n)), globalenv())
set.seed(0)
rnd           # 0.8966972
rnd <- 3      # 0.2655087 0.3721239 0.5728534

e <- new.env()
e$N <- 1
with(e, f <- \(n=1) {
    if (missing(n)) runif(N)
    else N <<- n
})
makeActiveBinding("rnd2", e$f, globalenv())
set.seed(0)
rnd2          # 0.8966972
rnd2 <- 3
rnd2          # 0.2655087 0.3721239 0.5728534
\end{lstlisting}


\subsubsection{on.exit: Aufruf bei Funktionende}

Mit \lstinline|on.exit| können in einer Funktion Aktionen registriert
werden, die beim Verlassen der Funktion garantiert ausgeführt werden,
unabhängig davon, ob sie regulär endet oder durch einen Fehler
abgebrochen wird. Der Code in \lstinline|on.exit()| wird ausgeführt,
bevor die Funktion verlassen wird. Also vor der Rückgabe des
Ergebnisses an den Aufrufer und vor der Anzeige des Rückgabewerts in
der interaktiven Konsole.

\begin{lstlisting}
f <- \(x) {
  on.exit(cat("EXIT: "))
  if (x < 0) stop("Error")
  x + 1
}
f(0)       # EXIT: [1] 1
f(-1)      # Fehler in f(-1) : Error, EXIT:

g <- \() {
  on.exit(cat(" E0"))
  on.exit(cat(" E1"))  # Ersetzt vorheriges
}
g()        # E1

h <- \() {
  on.exit(cat(" E0"))
  on.exit(cat(" E1"), add = TRUE)
  on.exit(cat(" E2"), add = TRUE, after = FALSE)
}
h()        # E2 E0 E1

F <- \() {on.exit({stop("Error in Exit"); cat("Ende")}); 0}
F()        # Fehler in F() : Error in Exit
\end{lstlisting}


\subsection{Organisation von Environments zur Namensauflösung}

Namen werden zunächst im aktuellen Auswertungs-Environment (Execution Environment) gesucht. Werden sie dort nicht gefunden, wird die Suche im Parent Environment fortgesetzt, anschließend im Parent des Parent Environments usw. Die Namenssuche endet entweder mit dem Auffinden des Namens oder beim Erreichen des leeren Environments (\lstinline|emptyenv()|).

Man kann die Suche auch explizit in einem bestimmten Environment starten (z.\,B. mit \lstinline|get()| oder \lstinline|assign()|), allerdings muss das Environment-Objekt selbst zuvor über die normale Namenssuche verfügbar sein.

Ähnlich ist es beim Aufruf einer Funktion. Dabei muss zunächst deren Name gefunden werden. Beim Start der Funktion wird ein temporäres Auswertungs-Environment (Execution Environment) erzeugt in dem die, in der Funktion verwendeten, Namen gesucht werden. Die Suche wird anschließend im Parent dieses Environments fortgesetzt, dem sogenannten Enclosing Environment der Funktion, und danach in dessen Parent-Environments.

Bei interaktiver Arbeit in der Konsole sowie beim Start eines Skripts beginnt die Namensauflösung im globalen Environment (\lstinline|.GlobalEnv|). Ist der Name dort nicht vorhanden, wird die Suche in der dem \lstinline|.GlobalEnv| folgende Environmentkette fortgesetzt, welche mit \lstinline|search()| (Suchpfad) angezeigt werden kann.

Zusätzlich besitzen Packages eigene Namespaces. Exportierte Namen können über \lstinline|::| (z.\,B. \lstinline|stats::sd|) direkt aus dem Namespace referenziert werden, ohne den Suchpfad zu durchlaufen.

Namespaces existieren unabhängig vom Suchpfad. Der Suchpfad baut auf Namespaces auf und macht deren Objekte über seine Namenssuche zugänglich.


\subsubsection{Namespace (Namensraum)}

Ein Namespace dient in R dazu, die Umgebung eines Pakets klar von anderen Paketen und vom globalen Arbeitsbereich zu trennen. Er definiert, welche Objekte eines Pakets nach außen sichtbar exportiert werden und welche intern bleiben, schützt vor Namenskonflikten zwischen gleichlautenden Funktionen verschiedener Pakete und legt fest, welche Funktionen aus anderen Paketen importiert werden. Darüber hinaus ist der Namespace üblicherweise das Enclosing Environment für die Paketfunktionen, wodurch diese auf interne Objekte des Pakets zugreifen können.

Üblicherweise ist hier die Environment-Kette so aufgebaut:
\lstinline|namespace:env| =>
\lstinline|imports:env| =>
\lstinline|namespace:base| =>
\lstinline|R_GlobalEnv|, \dots

Wichtige Funktionen sind:

\begin{itemize}
\item \lstinline|loadedNamespaces()|: zeigt alle geladenen Namespaces.
\item \lstinline|loadNamespace("pkg")| bzw.\ \lstinline|requireNamespace("pkg")|: lädt den Namespace.
\item \lstinline|getNamespace("pkg")| und \lstinline|asNamespace("pkg")|: liefert das Namespace-Environment (lädt es bei Bedarf).
\item \lstinline|unloadNamespace("pkg")|: Entfernt den Namespace solange er nicht noch von anderen geladenen Namespaces importiert wurde.
\item \lstinline|getNamespaceUsers("pkg")| Zeigt Pakete die pkg importiert haben
\item \lstinline|getNamespaceImports("pkg")| Zeigt welche Pakete pkg importiert
\item \lstinline|ls(getNamespace("pkg"), all.names = TRUE)| zeigt alle und \lstinline|getNamespaceExports("pkg")| die exportierten Namen eines Namespaces.
\end{itemize}

\lstinline|requireNamespace()| gibt TRUE/FALSE zurück und bricht nicht ab, wenn das Paket fehlt, während \lstinline|loadNamespace()| das Namespace-Objekt zurückgibt und mit einem Fehler abbricht, wenn das Paket nicht gefunden wird.

Nach dem Laden eines Namespace steht das \emph{Namespace-Environment (namespace:pkg)} zur Verfügung. Es enthält \emph{alle} Funktionen und Variablen des Pakets, auch interne, nicht-exportierte. Es ist das Enclosing Environment fast aller exportierten Funktionen.

Auf Namen dieser Environments kann man mit \lstinline|::| bzw.\ \lstinline|:::| zugreifen.

\begin{itemize}
\item \lstinline|pkg::name|: Greift auf \emph{exportierte} Objekte im Namespace zu.
\item \lstinline|pkg:::name|: Greift auf \emph{alle} Objekte im Namespace zu, auch interne.
\end{itemize}

Beide Operatoren laden den Namespace automatisch, falls dieser noch nicht geladen wurde und suchen nur im Namespace des angegebenen Pakets. Sie folgen \emph{keiner} Environment-Kette.

\begin{lstlisting}
loadedNamespaces()  # Bei Start von R automatisch geladene Pakete
# compiler graphics utils grDevices stats datasets methods base

loadNamespace("splines")     # Lädt splines
requireNamespace("splines")  # Alternative
"splines" %in% loadedNamespaces()  # TRUE
unloadNamespace("splines")   # Entfernt splines
"splines" %in% loadedNamespaces()  # FALSE

splines::bs     # Lädt Namespace automatisch
"splines" %in% loadedNamespaces()  # TRUE
#bs             ## Error, nicht gefunden

getNamespaceExports("splines")  # Zeigt exportierte Namen
ls(getNamespace("splines"), all.names = TRUE) # Zeigt alle

stats:::sd(1:3)                    # 1
getNamespace("stats")$sd(1:3)      # 1; Ähnlich wie :::
asNamespace("stats")$sd(1:3)       # 1; Ähnlich wie :::

#unloadNamespace("stats")  ## Error, auch von splines importiert
getNamespaceUsers("stats") # splines
unloadNamespace("splines")
unloadNamespace("stats")
#unloadNamespace("base")   ## Error, bei base nicht erlaubt
\end{lstlisting}

Funktionen beginnen ihre Namenssuche \emph{immer} im Execution Environment, gefolgt von deren Enclosing Environment und dessen Parent Kette. Das Enclosing Environment einer Paket Funktion ist in der Regel der Namespace des Pakets.

\begin{lstlisting}
environment(stats::sd)  # <environment: namespace:stats>
getNamespace("stats")   # <environment: namespace:stats>
\end{lstlisting}

Um Funktionen anderer Pakete im eigenen Paket verwenden zu können, wird der Namespace dieser Pakete im eigenen Paket importiert.

\begin{lstlisting}
names(getNamespaceImports("stats"))
# base graphics grDevices utils
\end{lstlisting}

Das Environment in dem die NamespaceImports eingetragen sind ist das Parent Environment des Paket Namespace.

\begin{lstlisting}
(e <- getNamespace("stats"))  # namespace:stats
(e <- parent.env(e))          # imports:stats
\end{lstlisting}

In diesem \lstinline|imports| Environment sind alle Funktionen fremder Pakete eingetragen.

\begin{lstlisting}
getNamespaceImports("stats")  # Zeigt alle importierten Funktionen
nn <- unlist(getNamespaceImports("stats")[-1])
e <- parent.env(getNamespace("stats")) # imports:stats
ne <- ls(e, all.names = TRUE) # Alle Namen in e
setdiff(ne, nn)               # character(0)
setdiff(nn, ne)               # character(0)
\end{lstlisting}

Darauf folgt \lstinline|namespace:base|, anschließend \lstinline|R_GlobalEnv|, und die Parent-Kette setzt sich bis \lstinline|base| fort, bevor sie im \lstinline|R_EmptyEnv| endet.

\begin{lstlisting}
(e <- getNamespace("stats")) # namespace:stats
(e <- parent.env(e))         # imports:stats
(e <- parent.env(e))         # namespace:base
(e <- parent.env(e))         # R_GlobalEnv
(e <- parent.env(e))         # package:stats
# ...
(e <- parent.env(e))         # base
(e <- parent.env(e))         # R_EmptyEnv
\end{lstlisting}


\subsubsection{Suchpfad}

Während Namespaces die interne Organisation und Kapselung von Paketobjekten regeln, beschreibt der Suchpfad die externe Reihenfolge der Environments, die R bei der Namensauflösung berücksichtigt. Er bestimmt somit, welche Objekte für den Benutzer direkt sichtbar und referenzierbar sind.

Die dem \lstinline|.GlobalEnv| folgende Parent-Environmentkette wird als Suchpfad (search path) bezeichnet. Er umfasst typischerweise die Environments der geladenen und angehängten Pakete (attached packages) welche mit (\lstinline|package:base|) abgeschlossen wird.

Bis auf das \lstinline|.GlobalEnv| dienen alle folgenden Parent-Environments dieser Environment-Kette der Namenssuche, sind also im Gegensatz zu einem Namespace-Environment üblicherweise kein Enclosing-Environment von Funktionen. Eine Veränderung des Parent-Environments dient dazu ihre Position im Suchpfad und damit ihre Sichtbarkeit gegenüber anderen Environments zu verändern.

Um die Eigenschaften eines vorhandenen Environments nicht zu verändern, also dessen Parent-Environment und der damit verbundenen Namenssuche sowie die darin enthaltenen Namen und Bindungen, sind Environments im Suchpfad entweder Kopien (Lists, Dataframes, Environments) oder dedizierte Package-Environments (\lstinline|package:env|), die die exportierten Bindings des zugehörigen Namespace-Environments enthalten.

Es werden also die Bindungen (Namen und Verweise auf die Objekte) aus dem Original übernommen. Dieses neue Environment wird dann in den Suchpfad eingefügt. Die Werte der Objekte werden dabei referenziert (nicht kopiert), sodass zunächst auf dieselben Daten zugegriffen wird. Nachträgliche Änderungen am Original-Environment haben \emph{keinen} Effekt auf das attached Environment und umgekehrt sondern lösen ein Copy on Modify aus.

Mit \lstinline|search()| wird der Suchpfad angezeigt. Mit \lstinline|searchpaths()| erhält man die vollständigen Dateipfade zu den geladenen Paketen. Beim Start von R werden einige Standardpakete bzw.\ Libraries automatisch geladen. Dadurch stehen deren Funktionen und Daten zur Verfügung. Folgende Pakete stehen bei einem Neustart von R zur Verfügung:

\begin{lstlisting}
search()
# ".GlobalEnv"        "package:stats"     "package:graphics"
# "package:grDevices" "package:utils"     "package:datasets"
# "package:methods"   "Autoloads"         "package:base"

searchpaths()
# ".GlobalEnv" "/usr/local/lib/R/library/stats" ...
\end{lstlisting}

Deren Reihenfolge ist entscheidend. Die Suche erfolgt strikt von vorne nach hinten, d.\,h.\ ein Name in einem Environment maskiert gleiche Namen in nachfolgenden Environments. Dieser Mechanismus ermöglicht eine einfache Nutzung von Funktionen und Daten, birgt jedoch das Risiko von Namenskonflikten (masking), welches bei Verwendung von \lstinline|paket::funktion()| über den Namespace von Paketen umgangen werden kann. Mit \lstinline|as.environment()| kann man auch über den im Suchpfad angegeben Environmennamen auf dieses direkt zugreifen ohne den Suchpfad zu durchwandern.

Dabei geht es zunächst einmal darum welcher Name gefunden wird. Wenn es sich um Daten handelt werden diese zurückgeliefert. Ist es hingegen eine \emph{Funktion}, ist diese mit einem \emph{Enclosing Environment} verbunden und bestimmt damit selbst wo sie, nachdem sie aufgerufen wurde, ihre Namen (Daten und weitere Funktionen) sucht.

Beispielsweise verwendet die Funktion \lstinline|sd| die Funktion \lstinline|sqrt|. Wenn sich der Name \lstinline|sqrt| im \lstinline|.GlobalEnv| befindet wird dieser von der Konsole aus gefunden. Die Funktionalität von \lstinline|sd| wird dadurch jedoch nicht beeinflusst, da \lstinline|sd| die Namenssuche nicht im \lstinline|.GlobalEnv| beginnt.

\begin{lstlisting}
sqrt(4)         # 2
find("sqrt")    # package:base
sd(1:3)         # 1
sqrt <- \(x) 0  # Eigene Funktion mit Namen sqrt
find("sqrt")    # .GlobalEnv, package:base
sqrt(4)         # 0
sd(1:3)         # 1
find("sd")      # package:stats
sd <- sd        # legt weitere Bindung im .GlobalEnv an
find("sd")      # .GlobalEnv package:stats
environment(sd) # <environment: namespace:stats>
environment(sd) <- globalenv() # Ändert Enclosing Environment
sd(1:3)         # 0; Dieses sd findet eigene sqrt Funktion
stats::sd(1:3)  # 1; Verwendet Namespace
as.environment("package:stats")$sd(1:3) # 1; über Suchpfadnamen
rm(sqrt)        # Entfernt sqrt aus .GlobalEnv
find("sqrt")    # package:base
sd(1:3)         # 1; Verwendet sqrt in base
\end{lstlisting}


\paragraph{Suchpfadmodifikation}

\subparagraph{Paket}

\lstinline|library("pkg")| bzw.\ \lstinline|require("pkg")| lädt den Namespace (namespace:pkg) und hängt das Package-Environment (package:pkg) mit den exportierten Objekten in den Suchpfad.
\lstinline|require()| gibt TRUE/FALSE zurück und bricht nicht ab, während \lstinline|library()| mit einem Fehler abbricht, wenn das Paket nicht gefunden wird.

Wenn ein Paket mit \lstinline|library()| oder \lstinline|require()| geladen wird, erscheint es standardmäßig direkt hinter \lstinline|.GlobalEnv| im Suchpfad, sofern es nicht bereits geladen ist.
Mit \lstinline|library(PKG, pos = POSITION)| lässt sich die Einfügeposition gezielt steuern. 
Ein Paket kann dabei weder vor \lstinline|.GlobalEnv| noch hinter \lstinline|package:base| platziert werden.

\lstinline|unloadNamespace()| bzw.\ \lstinline|detach("package:pkg", unload = TRUE)| entlädt das ganze Paket sowohl aus dem Suchpfad als auch aus dem Namespace während \lstinline|detach("package:pkg")| nur das Environment aus dem Suchpfad entfernt wohin es mit \lstinline|attachNamespace()| wieder gebracht werden kann.

\begin{lstlisting}
library(compiler)
search() # ".GlobalEnv" "package:compiler" "package:stats"
library(tools)
search() # ".GlobalEnv" "package:tools" "package:compiler"
library(compiler)            # Bleibt an Position
search() # ".GlobalEnv" "package:tools" "package:compiler"
unloadNamespace("compiler")  # Entlädt Paket
#detach("package:compiler", unload = TRUE) # Alternative
library(compiler)            # Jetzt ganz vorne
search() # ".GlobalEnv" "package:compiler" "package:tools"
unloadNamespace("compiler")
library(compiler, pos = length(search())) # vor base
search() # ".GlobalEnv" ... "package:compiler" "package:base"

detach("package:compiler")   # Entfernt nur aus Suchpfad
loadedNamespaces()           # compiler enthalten
search()                     # ohne package:compiler
attachNamespace("compiler")
search()                     # mit package:compiler
\end{lstlisting}


\subparagraph{Environment und Liste}

Mit \lstinline|attach()| kann man \emph{Kopien} von eigene Environments, Listen oder Dataframes in den Suchpfad bringen und mit \lstinline|detach()| wieder entfernen. Änderungen mit \lstinline|<<-| betreffen die Kopie und nicht das Original.

\begin{lstlisting}
e <- new.env()
e$x <- 0
#x                        ## Error, nicht gefunden
attach(e, name = "meinEnv")
x                         # 0

e                         # <environment: 0x559e3925da70>
as.environment("meinEnv") # <environment: 0x559e3925cd18>
parent.env(e)             # <environment: R_GlobalEnv>
parent.env(as.environment("meinEnv")) # package:stats
tracemem(x)               # <0x559e39218608>
tracemem(e$x)             # <0x559e39218608>
tracemem(as.environment("meinEnv")$x)
                          # <0x559e39218608>
x <- 1                    # Erzeugt x im .GlobalEnv
x                         # 1
e$x                       # 0
as.environment("meinEnv")$x # 0
rm(x)           # Entfernt x aus .GlobalEnv
x <<- 1                     # findet x in meinEnv
x                           # 1
as.environment("meinEnv")$x # 1
e$x                         # 0
e$x <- 2
x                           # 1
as.environment("meinEnv")$x # 1

search()        # ".GlobalEnv" "meinEnv" ...
detach("meinEnv")
attach(e, pos = length(search()), name = "meinEnv")
search() # ".GlobalEnv" ... "meinEnv" "package:base"

detach("package:stats")   # Kann auch ausgehängt werden
#detach(".GlobalEnv")     ## Error
#detach("package:base")   ## Error
\end{lstlisting}


\subsection{Pakete -- Libraries}

Pakete enthalten Funktionen und Daten und können damit die Funktionalität von R erweitern. Pakete werden meist mit \lstinline|library()| oder \lstinline|require()| geladen.

Beim Laden eines Pakets wird dessen Namespace geladen, der ein eigenes
Namespace--Environment besitzt. Dessen Parent ist das Imports--Environment,
welches die importierten Bindungen aus anderen Paketen enthält. Zusätzlich
wird ein Package--Environment erzeugt, das die exportierten Namen enthält und
in den Namenssuchpfad eingehängt wird.

Im Package--Environment befinden sich ausschließlich die exportierten Namen,
während im Namespace--Environment alle Namen des Pakets enthalten sind.

Im Imports--Environment befinden sich Namensbindungen zu Funktionen und Daten
anderer Pakete, die über \lstinline|Imports| oder \lstinline|import()| im
\lstinline|NAMESPACE| eingebunden wurden und im Paket ohne explizite Verwendung
von \lstinline|::| genutzt werden können.

Auf exportierte Namen in Paketen kann man mit \lstinline|::| zugreifen unabhängig davon ob sie im Suchpfad eingetragen sind. Der Zugriff erfolgt über das Namespace--Environment des Pakets, welches, falls es noch nicht geladen wurde, mit \lstinline|::| geladen wird. Mit \lstinline|:::| kann man auf alle, also auch die nicht exportierten Namen eines Paketes zugreifen.

\begin{lstlisting}
compiler::cmpfun(sum)  # Zugriff auf exportierte Funktion 
compiler:::asm         # Zugriff auf interne Funktion 
\end{lstlisting}

\lstinline|library()| bzw.\ \lstinline|installed.packages()| listet alle installierten Pakete auf.
Pakete mit Priority = \lstinline|base| oder \lstinline|recommended| werden bei jeder R-Installation standardmäßig mitgeliefert.
Base-Pakete gehören zum R-Core und haben stets dieselbe Versionsnummer wie die R-Installation selbst.
Recommended-Pakete sind nicht Teil des Core und können unabhängig von der R-Version aktualisiert, entfernt oder neu installiert werden.

\begin{lstlisting}
names(which(installed.packages()[,"Priority"]=="base"))
# base      compiler  datasets  graphics  grDevices grid     
# methods   parallel  splines   stats     stats4    tcltk    
# tools     utils    

names(which(installed.packages()[,"Priority"]=="recommended"))
# boot       class      cluster    codetools  foreign   
# KernSmooth lattice    MASS       Matrix     mgcv      
# nlme       nnet       rpart      spatial    survival  
\end{lstlisting}

Pakete kann man mit \lstinline|update.packages()| aktualisieren, mit
\lstinline|install.packages()| neu installieren, mit
\lstinline|remove.packages()| entfernen und mit
\lstinline|find.package()| suchen.
Alle bereits installierten Pakete können erneut installieren mit:
\begin{lstlisting}
. <- installed.packages()[,"Priority"]
install.packages(names(.[is.na(.) | . != "base"]))
\end{lstlisting}

Pakete auf GitHub können mit \lstinline|remotes::install_github("USER/REPO")|, bestimmte Branches, Tags oder Commits mit \lstinline|remotes::install_github("USER/REPO@BRANCH")| installiert werden.

Die Hilfe zu einem Paket erhält man mit \lstinline|library(help = "pkg")| und alle exportierten Funktionen mit \lstinline|getNamespaceExports("pkg")|.

Ein einfaches R-Paket lässt sich nach folgendem Muster erstellen.
Das Beispiel demonstriert den minimal notwendigen Paketaufbau mit
\lstinline|DESCRIPTION| und \lstinline|NAMESPACE|, den Umgang mit
exportierten und nicht exportierten Objekten im Namespace, die Einbindung
von Abhängigkeiten sowie die Erstellung von Dokumentation und Datensätzen.
Abschließend wird der Build-- und Installationsprozess über
\lstinline|R CMD build| und \lstinline|R CMD INSTALL| gezeigt.

\begin{lstlisting}
# Temporäres Package-Verzeichnis anlegen
pkgDir <- tempfile("meinPkg")
dir.create(file.path(pkgDir, "R"), recursive = TRUE)

# Eine minimale DESCRIPTION und NAMESPACE-Datei
writeLines('Package: meinPkg
Version: 0.0.1
Title: Test
Description: Nur zum Testen
Encoding: UTF-8
Authors@R: c( person("Ich", "Nachname",
   email = "ich@home.at", role = c("aut", "cre")),
 person("Du", "Nachname", role = "ctb") )
URL: https://github.com/ich/meinPkg
BugReports: https://github.com/ich/meinPkg/issues
License: GPL-3
Imports: stats
Depends: R (>= 4.1.0)
LazyData: true', file.path(pkgDir, "DESCRIPTION"))

writeLines('export(x, f, g)
importFrom(stats, rnorm)', file.path(pkgDir, "NAMESPACE"))

# Eine R-Datei mit Inhalt
writeLines(r"(x <- 1
y <- 2
f <- \(n=1) rnorm(n)
g <- \(n=1) stats::runif(n)  # explizit ohne Import
)", file.path(pkgDir, "R", "xyz.R"))

# Dokumentation
dir.create(file.path(pkgDir, "man"), recursive = TRUE)
writeLines(r"(
\name{f}
\alias{f}
\title{Zufallszahlen erzeugen}
\description{
Die Funktion \code{f} erzeugt normalverteilte Zufallszahlen
unter Verwendung von \code{stats::rnorm}.
}
\usage{
f(n = 1)
}
\arguments{
  \item{n}{Anzahl der Zufallszahlen.}
}
\value{
Ein numerischer Vektor der Länge \code{n}.
}
\examples{
f()
f(5)
}
)", file.path(pkgDir, "man", "f.Rd"))

# Daten
dat <- data.frame(id = 1:3, value = 3:1)
dir.create(file.path(pkgDir, "data"), recursive = TRUE)
save(dat, file = file.path(pkgDir, "data", "dat.rda"),
  compress = "xz" )
rm(dat)
  
writeLines(r"(
\name{dat}
\alias{dat}
\docType{data}
\title{Beispieldatensatz}
\description{
Ein kleiner Beispieldatensatz mit IDs und Zahlen.
}
\format{
Ein data.frame mit 3 Zeilen und 2 Variablen:
\describe{
  \item{id}{Ganzzahlige ID.}
  \item{value}{Zahlen.}
}
}
\usage{
dat
}
)", file.path(pkgDir, "man", "dat.Rd"))

# Package Installieren
system2( file.path(R.home("bin"), "R"),
  c("CMD", "INSTALL", shQuote(pkgDir)) )

library(meinPkg)

x               # 1
meinPkg::x      # 1
meinPkg:::x     # 1
#y              ## y nicht gefunden
#meinPkg::y     ## Error nicht exportiert
meinPkg:::y     # 2
set.seed(0)
f()             # 1.262954
g()             # 0.3721239
?f              # Zeigt Hilfe an
?meinPkg::f     # Zeigt Hilfe an
dat             # direkt verfügbar (LazyData: true)
data(dat, package = "meinPkg") # Ohne LazyData
?dat            # Hilfe zu daten

# Tar Datei des Pakets erzeugen
# R CMD build [Verzeichnis]
## R CMD check [Verzeichnis] # Zeigt eventuelle Fehler
system2(
  file.path(R.home("bin"), "R"),
  c("CMD", "build", shQuote(pkgDir)) )
# tar kann in der Shel mit: R CMD INSTALL [PAKET.tar.gz]
# oder in R mit: install.packages("[PAKET.tar.gz]", repos =NULL)
# Installiert werden
install.packages("meinPkg_0.0.1.tar.gz", repos = NULL)
\end{lstlisting}


\subsection{Objektorientierung}

In R können Funktionen abhängig von der Klasse ihrer Argumente unterschiedliches Verhalten zeigen.


\subsubsection{S3-Klassen}

Ein S3-Objekt ist ein beliebiges R-Objekt (z.\,B. Vektor oder Liste), dem ein Klassenattribut zugewiesen wird.  Methoden werden durch Funktionsnamen mit Punktnotation definiert, wobei es hiervon Ausnahmen gibt (\lstinline|t.test|, \lstinline|data.frame|), bei denen dies keine Methoden für die Klasse \lstinline|test| oder \lstinline|frame| sind.  In S3 gibt es keine explizite Klassendefinition.  Eine Klasse entsteht allein durch das Setzen des \lstinline|class|-Attributs.

Beim Aufruf einer generischen Funktion bestimmt R anhand des \lstinline|class|-Attributs üblicherweise des ersten Arguments, welche Methode (\lstinline|generic.classname|) aufgerufen wird. Existiert keine passende Methode, wird \lstinline|generic.default| verwendet.

Mit \lstinline|inherits()| kann man prüfen ob eine Klasse enthalten ist.

Bei der Funktionsauswahl findet keine Typprüfung statt. Objekte unterschiedlichen Basis-Typs (z.\,B.\ \lstinline|character| und \lstinline|numeric|) können dieselbe Klasse zugewiesen bekommen und verzweigen aufgrund der Klasse zur selben Funktion. Diese Typprüfung könnte bei der Erzeugung der Klasse, durch eine selbst geschriebene Funktion, erfolgen.

\lstinline|methods(generic)| zeigt, für welche Klassen Methoden im Suchpfad verfügbar sind. \lstinline|methods(class = "classname")| zeigt welche spezialisierten Funktionen für eine Klasse existieren.

\begin{lstlisting}
f <- \(x) UseMethod("f")  # generische Funktion definieren
f.a <- \(x) "A"           # Methode für Klasse a
f.b <- \(x) "B"           # Methode für Klasse b
f.default <- \(x) "Def"   # Alle anderen Klassen
methods(f)                # f.a f.b f.default
methods(class = "a")      # f

x <- 0
f(x)                      # Def
class(x) <- "a"
f(x)                      # A
class(x) <- "b"
f(x)                      # B
class(x) <- "x"
f(x)                      # Def

class(x) <- c("a", "b")
f(x)                      # A
class(x) <- c("b", "a")
f(x)                      # B
class(x) <- c("x", "a")
f(x)                      # A
inherits(x, "a")          # TRUE
inherits(x, "b")          # FALSE

newA <- \(x) structure(x, class="a")  # Konstruktor
newB <- \(x) structure(x, class="b")
x <- newA(1)
f(x)                      # A
f(newB(2))                # B

f <- \(x, y) UseMethod("f", y)  # Auswahl anhand des zweiten
f.a <- \(x, y) "A"
f.default <- \(x, y) "Def"
x <- structure(0, class="a")
f(x, 0)                   # Def
f(0, x)                   # A

g <- \(x, y) {            # Auswahl über beide
  ux <- unique(class(x))  #  Manual Double Dispatch
  ux <- setNames(seq_along(ux), ux)
  uy <- unique(class(y))
  uy <- setNames(seq_along(uy), uy)
  . <- expand.grid(ux[class(x)], uy[class(y)])
  . <- .[order(pmax(.[,1], .[,2]), .[,1], .[,2]),]
  . <- paste(names(ux)[.[,1]], names(uy)[.[,2]], sep="_")
  class(x) <- unique(c(., class(x), class(y)))
  UseMethod("g", x) }
g.a_b <- \(x, y) c(x, y, "AB")
g.default <- \(x, y) "Def"
x <- structure(0, class="a")
y <- structure(1, class="b")
g(x, y)                   # 0 1 AB
g(x, x)                   # Def
g(y, y)                   # Def
x <- structure(0, class=c("x", "a"))
y <- structure(1, class=c("y", "b"))
g(x, y)                   # 0 1 AB
\end{lstlisting}

Die Klassenreihenfolge in \lstinline|class(x)| entspricht einer einfachen Form von Vererbung. Mit \lstinline|NextMethod()| kann innerhalb einer S3-Methode die nächste passende Methode gemäß der Klassenreihenfolge aufgerufen werden, wodurch spezialisiertes Verhalten schrittweise erweitert werden kann. \lstinline|NextMethod()| kann nur innerhalb einer S3-Methode verwendet werden und ruft keine rekursive Methode, sondern die nächste Klasse in der Klassen-Reihenfolge auf.

\begin{lstlisting}
f <- \(x) UseMethod("f")
f.a <- \(x) {x <- x+1; c("A", x, NextMethod())}
f.b <- \(x) {x <- x-1; c("B", x, NextMethod())}
f.default <- \(x) c("Def", x)

x <- 0
class(x) <- "a"
f(x)                     # A 1 Def 1
class(x) <- c("b", "a", "b")
f(x)                     # B -1 A 0 B -1 Def -1
\end{lstlisting}

In eigenen Paketen sollten Klassen mit Präfix (z.\,B.\ mypkg\_myclass) benannt werden, um Kollisionen zu vermeiden.


\subsubsection{S4-Klassen}

In S4 werden Klassen explizit definiert, der Typ (\lstinline|character|, \lstinline|numeric|, \dots) wird überprüft und die Funktionsauswahl kann über mehrere Argumente erfolgen.

Eine S4-Klasse wird mit \lstinline|setClass| definiert. Dabei werden die enthaltenen Slots (Attribute) sowie deren Typen explizit angegeben. Objekte einer S4-Klasse werden mit \lstinline|new| erzeugt.

Es ist nicht möglich, beliebige Attribute hinzuzufügen oder inkonsistente Objekte zu erzeugen. S4 erzwingt die Einhaltung der definierten Klassenstruktur.

Ein direkter Slot-Zugriff ist mit \lstinline|@| möglich, sollte jedoch nach Möglichkeit mittels selbst geschriebene Zugriffsfunktionen erfolgen.

\lstinline|showClass| gibt eine kompakte, menschenlesbare Übersicht einer Klassendefinition aus.
\lstinline|getClass| liefert die vollständige Klassendefinition als Objekt der Klasse \lstinline|formalClass| und eignet sich für programmatische Auswertung.
\lstinline|getClassDef| verhält sich ähnlich wie \lstinline|getClass|, gibt jedoch \lstinline|NULL| zurück, falls die Klasse nicht existiert.

\begin{lstlisting}
setClass("A", slots = list(x = "numeric"))
showClass("A")            # Info zur Klasse
x <- new("A", x = 1)
x@x                       # 1
#x <- new("A", 1)         ## Error, kein Name
#x <- new("A", y=1)       ## Error, unzulässiger Name
#x <- new("A", x = "a")   ## Error, falscher Typ
x <- new("A")
x@x                       # numeric(0)
\end{lstlisting}

Man kann auch die Slot Inhalte mit \lstinline|validity| überprüfen und Default-Werte mit \lstinline|prototype| vergeben. Validiert wird nur bei \lstinline|new()| oder explizitem Aufruf von \lstinline|validObject()|. Also z.\,B.\ nicht bei \lstinline|@<-|.

\begin{lstlisting}
setClass("A", slots = list(x = "numeric", y = "numeric"),
  validity = \(object)
    if (object@x > 0 && object@y > 0) TRUE else "Nicht > 0")
x <- new("A", x = 1, y = 1)
#y <- new("A", x = 1, y = 0)  ## Error, Nicht > 0

setClass("B", slots = list(x = "numeric"),
  prototype = list(x = 42) )
y <- new("B")
y@x                           # 42
\end{lstlisting}

S4 verwendet generische Funktionen mit expliziter Methodendeklaration. Eine generische Funktion wird mit \lstinline|setGeneric| definiert, wobei die Signatur festlegt, über welche Argumente die Funktionsauswahl erfolgt.

Methoden werden mit \lstinline|setMethod| für konkrete Klassenkombinationen definiert.

Die Methodenauswahl erfolgt anhand der Klassen aller in der Signatur angegebenen Argumente. Existiert keine passende Methode, wird ein Fehler ausgelöst. Eine Default-Methode kann mittels Typ \lstinline|ANY| definiert werden.

Mit \lstinline|showMethods()| kann man alle Methoden einer Funktion anzeigen. \lstinline|getMethod()| zeigt eine konkrete Methode mit den entsprechenden Argumenten.

\begin{lstlisting}
setClass("A", slots = list(x = "integer"))

setGeneric("f", \(x, y) standardGeneric("f"))

setMethod("f",
  signature(x = "A", y = "numeric"),
  \(x, y) {x@x - y} )

a <- new("A", x = 2L)
f(a, 1)              # 1
#f(2L, 1)            ## Error, keine Methode gefunden

setMethod("f",
  signature(x = "ANY", y = "numeric"),
  \(x, y) c(x,  y) )
f(2L, 1)             # 2 1
f("x", 1)            # x 1

setMethod("f",
  signature(x = "missing", y = "numeric"),
  \(x, y) y * 2 )
f(y=3)

setMethod("f",
  signature(x = "missing", y = "missing"),
  \() 7  # wird in eine Funktion mit x und y eingefügt
# \(x, y) 7  # Besser explizit
)
getMethod("f", signature(x = "missing", y = "missing"))
# function (x, y) { .local <- \() 7; .local() }
# Statt: function (x, y) 7

setMethod("f",
  signature(),  # ANY wird automatisch eingefügt
# signature(x = "ANY", y = "ANY"), # Besser explizit
  \(x, y) c(x, y)
)
getMethod("f", signature(x = "ANY", y = "ANY"))
# function (x, y) c(x, y)

setGeneric("getX", function(x) standardGeneric("getX"))
setMethod("getX", "A", \(x) x@x) # Accessor-Funktion
getX(a)              # 2

setGeneric("setX<-",
           function(x, value) standardGeneric("setX<-"))
setMethod("setX<-", "A", \(x, value) {
  x@x <- value
  validObject(x)
  x
})
setX(a) <- 3L

showMethods("f")    # Zeigt alle Methoden von f
\end{lstlisting}

S4 unterstützt Vererbung durch das Argument \lstinline|contains| bei der Klassendefinition. Abgeleitete Klassen erben Slots und Methoden ihrer Basisklassen.

Slots können selbst S4-Klassen sein, was komplexe, geschachtelte Datenstrukturen ermöglicht (Komposition). Im Gegensatz dazu definiert \lstinline|contains| eine \textit{is-a}-Beziehung (Vererbung).

Mit \lstinline|is()| kann man prüfen ob ein Objekt einer Klasse angehört. Mit \lstinline|as()| kann man in eine andere Klasse umwandeln.

Methoden für Basisklassen sind automatisch auch für abgeleitete Klassen gültig, sofern keine speziellere Methode existiert.

\lstinline|callNextMethod()| ruft die nächstweniger spezifische Methode in der Methodenhierarchie auf.

\begin{lstlisting}
setClass("A", slots = list(x = "integer"))
setClass("B", contains = "A", slots = list(y = "numeric"))
setClass("C", contains = c("A", "B"))  # Mehrfachvererbung

setGeneric("f", \(x) standardGeneric("f"))
setMethod("f", signature(x = "A"), \(x) x@x)

a <- new("A", x = 1L)
b <- new("B", x = 2L, y = 3)

is(a, "A")        # TRUE
is(b, "A")        # TRUE
is(a, "B")        # FALSE
is(b, "B")        # TRUE

as(b, "A")        # Wandelt in Klasse A um

f(a)              # 1
f(b)              # 2; Methode der Basisklasse

setMethod("f", signature(x = "B"), \(x) x@x + 1)
f(b)              # 3; Methode der eigenen Klasse

setMethod("f", signature(x = "B"), \(x) callNextMethod() + 2)
f(b)              # 4; Methode für B ruft Methode für A auf
\end{lstlisting}

S3-Klassen kann man mit \lstinline|setOldClass()| nach S4 übernehmen. Für Basisobjekte wie \lstinline|data.frame| ist \lstinline|setOldClass()| in der Regel bereits durchgeführt.

Virtuelle Klassen dienen als abstrakte Basisklassen, von denen keine Instanzen erzeugt werden.

\begin{lstlisting}
setGeneric("f", \(x) standardGeneric("f"))
#setMethod("f", "myS3", \(x) x$a) ## Error myS3 nicht definiert
setOldClass("myS3")
setMethod("f", "myS3", \(x) x$a)
x <- structure(list(a = 1), class = "myS3")
f(x)                 # 1

setClass("A", contains = "VIRTUAL", slots = list(x = "numeric"))
setClass("B", contains = "A", slots = list(y = "numeric"))
#a <- new("A", x = 1)      ## Error, virtuelle Klasse
b <- new("B", x = 2L, y = 3)
\end{lstlisting}

%Aufgrund der komplexen Methodensuche (Dispatch) und der formalen Prüfungen ist S4 rechenintensiver als S3. In performance-kritischen Schleifen sollte der direkte Zugriff auf Slots oder der Einsatz von S3 erwogen werden.

%Bei der Entwicklung von Paketen müssen S4-Klassen und -Methoden explizit im \texttt{NAMESPACE} exportiert werden (\lstinline|exportClasses(A)|, \lstinline|exportMethods(f)|).


\subsubsection{S7-Klassen}

S7 (Paket: \lstinline|S7|, Version 0.2.1, 2025-11-14) kombiniert die Einfachheit von S3 mit der formalen Strenge von S4 und unterstützt Klassen, generische Funktionen und Funktionsauswahl über die Klassen mehrerer Argumente.

Eine S7-Klasse wird mit \lstinline|new_class()| definiert. Dabei werden Eigenschaften (Properties) mit zugehörigen Typen festgelegt. Die Typen der Properties sind selbst S7-Klassen (z.\,B.\ \lstinline|class_integer| oder benutzerdefinierte Klassen). Base-Typen beginnen mit \lstinline|class_|. Der Zugriff auf die Elemente erfolgt mit \lstinline|@|.

Die Typen der Properties werden beim Erzeugen und Ändern eines Objekts geprüft. Zusätzliche, nicht deklarierte Properties sind nicht erlaubt.

Informationen zu einem S7 Objekt erhält man mit \lstinline|S7_class()| und auch für S3 mit \lstinline|class()|.

\begin{lstlisting}
library(S7)

A <- new_class("A", properties = list(x = class_integer))
x <- A(x = 42L)     # Erzeugt S7 Objekt
x@x                 # 42
x@x <- 0L
x@x                 # 0
#x@x <- "a"         ## Error, falscher Typ
#x@y <- 0           ## Error, gibt kein y
S7_class(x)         # <A> class
                    # @ parent     : <S7_object>
                    # @ constructor: function(x) {...}
                    # @ validator  : <NULL>
                    # @ properties :
                    #  $ x: <integer>
class(x)            # "A" "S7_object"
\end{lstlisting}

Mit dem Argument \lstinline|constructor| kann das Standardverhalten beim Erstellen eines Objekts angepasst werden (z.\,B.\ zur Vorverarbeitung von Werten) und auch Default-Werte vorgeben. Der \lstinline|validator| prüft die Konsistenz des Objekts nach der Erstellung oder Änderung, wenn einfache Typprüfungen der Properties nicht ausreichen. Der \lstinline|validator| wird sowohl beim Erzeugen eines Objekts als auch bei jeder Änderung einer Property ausgeführt. Bei der Definition in Paketen sollte das Argument \lstinline|package| gesetzt werden, um Namenskonflikte zu vermeiden.

\begin{lstlisting}
A <- new_class("A", properties = list(x = class_integer),
  constructor = \(x=10L) new_object(S7_object(), x = x - 1L),
  validator = \(self) {if (self@x < 0) "x < 0"},
  package = "meinpaket")
x <- A()
x@x                # 9; durch Constructor
x <- A(x = 2L)
x@x                # 1
x@x <- 2L          # Ohne Constructor
x@x                # 2
#x <- A(x = 0L)    ## Error, x < 0
#x@x <- -1L        ## Error, x < 0; Validator auch hier
\end{lstlisting}

In S7 können Union Types (Klassenvereinigungen) genutzt werden, um für eine Eigenschaft (Property) oder eine Methode mehrere verschiedene Klassentypen zuzulassen. Man definiert sie entweder mit der Funktion \lstinline|new_union()| oder mit \lstinline{|}.

\begin{lstlisting}
A <- new_class("A", properties = list(x = class_integer | NULL))
x <- A(x = 42L)
x <- A(x = NULL)

B <- new_class("B", properties =
       list(x = new_union(class_integer, class_character)))
x <- B(x = 42L)
x <- B(x = "z")
\end{lstlisting}

S7 bietet Computed Properties (berechnete Eigenschaften), welche bei jedem Zugriff neu berechnet werden. Es können auch Defaultwerte über Properties vergeben werden.

\begin{lstlisting}
B <- new_class("B", properties = list(
  x = class_numeric,
  x_sq = new_property(getter = \(self) self@x^2) 
))
b <- B(x=2)
b@x_sq              # 4
#b@x_sq  <- 2       ## Error, Read only
b@x  <- 3
b@x_sq              # 9

E <- new_class("E", properties = list(x =
      new_property(class_integer, default = 4L)))
e <- E()
e@x                 # 4
\end{lstlisting}

S7 verwendet generische Funktionen. Eine generische Funktion wird mit \lstinline|new_generic()| definiert. Die Signatur legt fest, über welche Argumente die Funktionsauswahl (method dispatch) erfolgt. Die Methoden werden mit \lstinline|method()| definiert.

\begin{lstlisting}
f <- new_generic("f", c("x", "y"))  # Auswahl über x und y

method(f, list(x=class_integer,y=class_integer)) <- \(x, y) "ii"
method(f, list(x=class_double, y=class_double)) <- \(x, y) "dd"
#method(f, list(x=class_integer)) <- \(x, y) "i" ## Error
method(f, list(x=class_integer, y=class_any)) <- \(x, y) "ia"

f(0L, 0L)                          # ii
f(0, 0)                            # dd
f(0L, "a")                         # ia
#f(0 , "a")                     ## Error, keine passende Methode

f                                  # Zeigt alle Methoden von f
\end{lstlisting}

S7 unterstützt Vererbung über das Argument \lstinline|parent|. Abgeleitete Klassen erben Properties und Methoden. Abgeleitete Klassen können Properties erweitern, aber nicht entfernen oder umdefinieren. S7 erlaubt die Definition abstrakter Klassen, von denen keine Instanzen erzeugt werden können. Mit \lstinline|super(from, to)| kann man zur nächsten Klasse weiterreichen.

\begin{lstlisting}
A <- new_class("A", abstract = TRUE,
  properties = list(x = class_numeric))
B <- new_class("B", parent = A, properties =
                         list(y = class_numeric))

# a <- A(x = 0)     ## Error, a ist Abstract
b <- B(x = 0, y = 1)

f <- new_generic("f", "x")
method(f, A) <- \(x) "A"
f(b)                  # A; Über Parent Methode
method(f, B) <- \(x) "B"
f(b)                  # B; Jetzt über eigene Methode
method(f, B) <- \(x) c("B",  f(super(x, A)))
f(b)                  # B A

E <- new_class("E")
e <- E()
#f(e)                 ## Error, Keine passende Methode
method(f, S7_object) <- \(x) "Def"  # Für alle S7
f(e)                  # Def
#f()                  ## Error, Keine passende Methode
method(f, class_missing) <- \(x) "Missing"
f()                   # Missing
#f(0)                 ## Error, Keine passende Methode
method(f, class_any) <- \(x) "Any"  # Für alle
f(0)                  # Any
\end{lstlisting}

S7 ist vollständig mit dem bestehenden S3-System interoperabel. S7-Objekte besitzen immer auch eine S3-Klasse, sodass sie nahtlos mit bestehenden S3-Generics und Methoden verwendet werden können.

\begin{lstlisting}
A <- new_class("A", properties = list(x = class_integer))
x <- A(x = 42L)     # Erzeugt S7 Objekt
print(x)   # <A>, @ x: int 42
#print.A <- \(x, ...) print(x@x, ...) # Nicht empfohlen
method(print, A) <- \(x, ...) print(x@x, ...) # empfohlen
print(x)   # 42
\end{lstlisting}

In S7 müssen S3-Klassen explizit mit \lstinline|new_S3_class()| deklariert werden, bevor sie als Typen für Properties oder in Methodensignaturen verwendet werden können. Während Basis-S3-Klassen wie \lstinline|data.frame| bereits vordefiniert sind, ist \lstinline|new_S3_class()| für alle anderen S3-Klassen, z.\,B.\ aus eigenen Klassen zwingend erforderlich.

\begin{lstlisting}
S3 <- list(x = 10)
class(S3) <- "S3"
# A <- new_class("A", properties = list(y = S3)) ## Error
class_S3 <- new_S3_class("S3")
A <- new_class("A", properties = list(y = class_S3))
a <- A(y = S3)
\end{lstlisting}


\subsubsection{Reference-Klassen}

Reference Classes (auch \emph{RC} genannt) stellen in R ein objektorientiertes System mit Referenzsemantik bereit. Im Gegensatz zu S3 und S4 werden Objekte nicht kopiert, sondern in-place verändert. Wird ein Reference-Class-Objekt an eine Funktion übergeben, arbeiten alle Variablen, die darauf verweisen, auf demselben Objekt.

Reference Classes werden mit \lstinline|setRefClass| definiert. Dabei werden Felder (Attribute) und Methoden explizit angegeben. Objekte werden durch den Aufruf des Klassennamens erzeugt.

Innerhalb von RefClass-Methoden kann der Zugriff auf Felder entweder direkt über den Operator \lstinline|<<-| oder explizit über \lstinline|.self$feldname| erfolgen. Empfohlen wird die Verwendung von \lstinline|.self$feldname|, um Namenskollisionen mit lokalen Variablen zu vermeiden.

Der Zugriff auf Felder und Methoden erfolgt über den Operator \lstinline|$|.

Reference Classes unterstützen Vererbung über das Argument \lstinline|contains| bei der Klassendefinition. Abgeleitete Klassen erben Felder und Methoden der Basisklasse.

\begin{lstlisting}
A <- setRefClass("A",
  fields = list(x = "numeric"),
  methods = list( inc = \() { .self$x <- .self$x + 1 } ))

a <- A$new()
a$x               # numeric(0)
a <- A$new(x = 1)
a$x               # 1
a$inc()
a$x               # 2

z <- a
z$inc()
a$x               # 3

f <- \(obj) obj$inc()
f(a)
a$x               # 4

a$x <- 7
#a$x <- "a"       ## Error, falsche Klasse

B <- setRefClass("B",
  contains = "A",           # .self wäre besser als <<-
  methods = list( dec = \() { x <<- x - 1 } ))

b <- B$new(x = 10)
b$x               # 10
b$inc()
b$x               # 11
b$dec()
b$x               # 10
\end{lstlisting}

Mit \lstinline|$copy(TRUE)| kann man eine flache Kopie (\emph{shallow copy}) eines Reference-Class-Objekts erzeugen. Referenzfelder, wie andere Reference-Class-Objekte oder Environments, werden dabei nicht kopiert. Mit \lstinline|$copy()| kann eine tiefe Kopie (\emph{deep copy}) erstellt werden, bei der auch referenzierte Objekte rekursiv kopiert werden.

\begin{lstlisting}
A <- setRefClass("A", fields = list(x = "numeric"))
B <- setRefClass("B", fields = list(x = "A", y = "numeric"))
a <- A$new(x = 0)
b <- B$new(x = a, y = 0)

c <- b$copy()     # Deep Copy
c$x$x <- 1
c$y <- 1
a$x           # 0
b$x$x         # 0
b$y           # 0

c <- b$copy(TRUE) # Shallow copy
c$x$x <- 2
c$y <- 2
a$x           # 2
b$x$x         # 2
b$y           # 0

c <- b            # Referenz
c$x$x <- 3
c$y <- 3
a$x           # 3
b$x$x         # 3
b$y           # 3
\end{lstlisting}

Im Gegensatz zu S3 und S4 erfolgt der Methodenaufruf bei Reference Classes nicht über generische Funktionen und Funktionsauswahl, sondern über direkte Methodenbindung an das Objekt. Polymorphes Verhalten wird durch Vererbung und Überschreiben von Methoden realisiert.

Man kann auch eine eigene \lstinline|initialize|-Methode definieren. \lstinline|callSuper()| ruft die gleichnamige Methode der Basisklasse auf. Die Funktion \lstinline|callSuper(...)| sollte in der Regel am \emph{Anfang} der \lstinline|initialize|-Methode aufgerufen werden. Dadurch werden die Felder zuerst mit den übergebenen Argumenten initialisiert, woraufhin die spezifische Logik der Subklasse diese Werte validieren oder modifizieren kann. Würde \lstinline|callSuper()| am Ende stehen, könnten manuelle Zuweisungen innerhalb der Methode durch die Standard-Initialisierung der Basisklasse überschrieben werden. Am Ende der \lstinline|initialize|-Methode sollte \lstinline|.self| stehen. Wenn keine eigene initialize-Methode geschrieben wird, nutzt RC eine Standardmethode, die benannte Argumente den Feldern zuweist.

\begin{lstlisting}
A <- setRefClass("A",
  fields = list(x = "numeric"),
  methods = list( inc = \() { .self$x <- .self$x + 1 },
    initialize = \(x = 0, ...) {
      callSuper(...)  # für den Fall weiterer Basisklassen
      .self$x <- x
      .self } ))
a <- A$new()
a$x                # 0
a <- A$new(x=1)
a$x                # 1

B <- setRefClass("B",
  contains = "A",
  methods = list(
    inc = \() {
      callSuper()  # ruft inc() von A auf
      .self$x <- .self$x + 10 } ))
b <- B$new(x = 1)
b$inc()
b$x                # 12
\end{lstlisting}


\iffalse
\subsubsection{R6-Klassen}

R6 ist ein modernes objektorientiertes System für R mit Referenzsemantik, das viele Konzepte von Reference Classes (RC) übernimmt, jedoch kompakter und effizienter umgesetzt ist.  
Wie bei RC werden Objekte in-place verändert und Methoden sind direkt an das Objekt gebunden. R6-Objekte sind \emph{mutable}: Änderungen wirken auf alle Variablen, die auf dasselbe Objekt verweisen.

R6-Klassen werden mit \lstinline|R6Class()| definiert. Dabei werden \emph{public} Felder (Attributes) und Methoden explizit angegeben. Objekte werden mit \lstinline|$new()| erzeugt. Der Zugriff auf Felder und Methoden erfolgt über den Operator \lstinline|$|.

\begin{lstlisting}
library(R6)

A <- R6Class("A",
  public = list(
    x = NULL,
    initialize = function(x = 0) { self$x <- x },
    inc = function() { self$x <- self$x + 1 }
  )
)

a <- A$new()
a$x               # 0
a$inc()
a$x               # 1

z <- a
z$inc()
a$x               # 2

f <- function(obj) obj$inc()
f(a)
a$x               # 3

a$x <- 7
#a$x <- "a"       ## Error, falscher Typ nicht automatisch geprüft
\end{lstlisting}

---

R6 unterstützt Vererbung über das Argument \lstinline|inherit|. Abgeleitete Klassen erben Felder und Methoden der Basisklasse. Methoden können überschrieben werden, wobei auf die Basisklassenmethode mit \lstinline|super$method()| zugegriffen werden kann.

\begin{lstlisting}
B <- R6Class("B",
  inherit = A,
  public = list(
    dec = function() { self$x <- self$x - 1 },
    inc = function() {
      super$inc()    # ruft inc() von A auf
      self$x <- self$x + 10 }
  )
)

b <- B$new(x = 1)
b$inc()
b$x               # 12
b$dec()
b$x               # 11
\end{lstlisting}

---

R6-Objekte können \emph{kopiert} werden, wobei standardmäßig eine flache Kopie erstellt wird. Für eine tiefe Kopie kann \lstinline|clone(deep = TRUE)| verwendet werden, ähnlich wie bei Reference Classes.

\begin{lstlisting}
A <- R6Class("A", public = list(x = 0))
B <- R6Class("B", inherit = A, public = list(y = NULL))

a <- A$new()
b <- B$new()
b$x <- a$x
b$y <- a

c <- b$clone(deep = TRUE)  # Deep copy
c$y$x <- 1
a$x               # 0
b$y$x             # 0

d <- b$clone()     # Shallow copy
d$y$x <- 2
a$x               # 2
b$y$x             # 2
\end{lstlisting}

---

Im Gegensatz zu S3, S4 oder S7 erfolgt der Methodenaufruf nicht über generische Funktionen, sondern direkt über das Objekt. Polymorphismus wird durch Vererbung und Überschreiben von Methoden realisiert, nicht durch Dispatch auf Klassen.

\begin{lstlisting}
# R6-Polymorphismus-Beispiel
C <- R6Class("C",
  inherit = A,
  public = list(
    inc = function() { self$x <- self$x + 100 }
  )
)

c <- C$new(x = 1)
c$inc()
c$x               # 101
\end{lstlisting}

---

R6 ist besonders geeignet für:

- mutable Objekte, die in Simulationen, GUIs oder iterativen Algorithmen benötigt werden,
- klare Kapselung von Daten und Methoden,
- kompakte, moderne Syntax im Vergleich zu Reference Classes.

Im Vergleich zu RC bietet R6:

- **leichtere Syntax** (kein \lstinline|<<-| notwendig),
- **schnellere Implementierung**, da kein S4-Metaclass-System beteiligt ist,
- klarere Trennung zwischen public, private und active fields.

R6 ergänzt damit das Spektrum objektorientierter Systeme in R und bildet die moderne Variante referenzbasierter Klassen.

\fi


\section{Typen}

Alle Objekte haben einen bestimmten Typ. Dieser Typ bestimmt, welche Werte bzw.\ Daten ein Objekt enthalten kann und welche Operationen darauf zulässig sind. Neben dem Typ bestimmt die Objektklasse, wie Operatoren und Funktionen auf ein Objekt angewendet werden.

R ist dynamisch typisiert, d.\,h.\ der Typ ist an das Objekt gebunden und wird zur Laufzeit festgelegt. Mit \lstinline|typeof()| kann der interne Typ eines Objekts bestimmt werden.

Ob ein Objekt zu einem bestimmten Typ gehört, lässt sich mit Funktionen der Form
\lstinline|is.TYP()|, z.\,B.\ \lstinline|is.numeric()|, prüfen. Ob es zu einer bestimmten Klasse gehört kann mit \lstinline|is()| geprüft werden.

\begin{lstlisting}
x <- 1
typeof(x)        # double;  interner Typ
class(x)         # numeric; Klasse(n)
is.double(x)     # TRUE
is.numeric(x)    # TRUE
is.character(x)  # FALSE
is(x, "double")  # FALSE; ist Typ nicht Klasse
is(x, "numeric") # TRUE
\end{lstlisting}

Mit \lstinline|as.TYP()| wird in den Typ, mit \lstinline|as()| in die Klasse konvertiert. R prüft dabei nicht streng auf Genauigkeit, sondern führt die Konvertierung stillschweigend durch. Mit \lstinline|canCoerce()| kann geprüft werden ob ein Objekt in eine andere Klasse konvertiert werden kann.

\begin{lstlisting}[language=R]
as.integer(1)     # Wandelt Double in Integer
as.integer(1.0)   # Wandelt Double in Integer
as.integer(1.8)   # wird abgeschnitten => 1
as.integer("a")   # NA; Warnung
floor(1.3)        # Abrunden  => 1 Double
ceiling(1.3)      # Aufrunden => 2 Double
round(1.3)        # Runden    => 1 Double
x <- "1.5"
canCoerce(x, "numeric")  # TRUE
as(x, "numeric")         # 1.5
\end{lstlisting}


\subsection{Vektor}

In R ist selbst ein einzelnes Element bereits ein Vektor. Vektoren zählen zu den atomaren Objekten, welche nur Werte eines einzigen elementaren Typs enthalten können. \lstinline|is.atomic()| prüft, ob ein Objekt atomar ist. \lstinline|is.vector()| ist nur dann \lstinline|TRUE|, wenn das Objekt atomar ist und außer \lstinline|names()| keine weiteren Attribute besitzt.

\begin{lstlisting}
x <- 1
is.atomic(x)     # TRUE
is.vector(x)     # TRUE
\end{lstlisting}


\subsubsection{Erzeugen von Vektoren}

Ein Vektor kann mit \lstinline|vector()| erzeugt werden.
Mehrere Elemente können mit \lstinline|c()| zusammengefasst werden.

\begin{lstlisting}
x <- vector("logical", 3)  # Vektor mit 3 Logical Elementen
x <- logical(3)            # Vektor mit 3 Logical Elementen
x <- c(10, 20, 30, 40)     # Vektor mit den angegebenen Elementen
numeric(0)                 # Leerer Vektor
\end{lstlisting}

Auch mit \lstinline|rep()| (wiederholen) und \lstinline|seq()| bzw.\ \lstinline|:| (Sequenz) lassen sich Vektoren erzeugen. Der Operator \lstinline|:| erzeugt immer eine Ganzzahlsequenz.

Die Schreibweise \lstinline|1:n| ergibt bei \lstinline|n = 0| \lstinline|1 0|, was beim Iterieren über einzelne Elemente meist nicht beabsichtigt ist. Daher sollten dafür \lstinline|seq_len()| oder \lstinline|seq_along()| bevorzugt werden.

\begin{lstlisting}
x <- 1:3             # 1 2 3; Erzeugt eine Integer Sequenz
3:1                  # 3 2 1
seq(1, 3)            # 1 2 3; Erzeugt eine Integer Sequenz
seq(1, 6, 2)         # 1 3 5; double Sequenz
seq(1L, 6L, 2L)      # 1 3 5; Integer Sequenz
seq(3, by=2, length.out=4) # 3 5 7 9
seq(0, by=3, along.with=x) # 0 3 6; so lange wie x
seq_along(x)         # 1 2 3
x <- integer(0)      # Vektor mit Länge 0
seq_along(x)         # integer(0)
n <- 3
seq_len(n)           # 1 2 3
n <- 0
seq_len(n)           # integer(0)
1:n                  # 1 0

rep(1:3, 2)          # 1 2 3 1 2 3; Objekt wiederholen
rep(1:3, each=2)     # 1 1 2 2 3 3
rep(1:3, 3:1)        # 1 1 1 2 2 3
\end{lstlisting}

Unterschiedliche Typen werden automatisch zum höheren Typ konvertiert (logical < integer < double < character).

\begin{lstlisting}
c(1, "a")            # Wird character-Vektor
\end{lstlisting}

Die Länge eines Vektors kann mit \lstinline|length()| abgefragt werden

\begin{lstlisting}
x <- c(1, 3, 2)
length(x)            # 3
length(x) <- 4
x                    # 1 3 2 NA; Auffüllen mit NA
length(x) <- 2
x                    # 1 3; verkürzt Vektor
\end{lstlisting}


\subsubsection{Recycling-Regel}

R verwendet bei Vektoroperationen die sogenannte \emph{Recycling-Regel}. Kürzere Vektoren werden automatisch wiederholt. Ist die Länge kein ganzzahliges Vielfaches, gibt R eine Warnung aus. Ein Skalar (einzelne Zahl) ist in R ein Vektor der Länge 1 und wird bei Operationen mit längeren Vektoren auf deren Länge erweitert.

\begin{lstlisting}
1:4 + 1:2 + 1        # 3 5 5 7; Auto Wiederholung
1:4 + 1:3            # 2 4 6 5; Warnung Länge
1:3 + 1:4            # 2 4 6 5; Warnung Länge
\end{lstlisting}


\subsubsection{Zugriff auf Vektorelemente}

Auf einzelne Elemente in einem Vektor kann mit \lstinline|[INDEX]| zugegriffen werden. Der Index selbst ist dabei wiederum ein Vektor. Bei \lstinline|[]| bleiben Namen erhalten. \lstinline|[[INDEX]]| liefert ausschließlich das Element wobei der index nur ein Element haben darf.

\begin{lstlisting}
10[c(1,1)]       # 10 10

x <- c(10, 20, 30, 40)
x                # ganzer Vektor
x[]              # ganzer Vektor
x[0]             # leerer Vektor
x[-0]            # leerer Vektor
x[NULL]          # leerer Vektor
x[integer(0)]    # leerer Vektor
x[-integer(0)]   # leerer Vektor
\end{lstlisting}


\paragraph{Positionsbasierte Indizierung}

Bei der positionsbasierten Indizierung werden Elemente über ihre numerische Position im Vektor ausgewählt.

\begin{lstlisting}
x <- c(10, 20, 30, 40)
x[2]             # 20; Element an Position 2
x[2:3]           # 20 30; Element 2 bis 3
x[3:2]           # 30 20; Element 3 bis 2
x[c(1,3,2)]      # 10 30 20; Mehrere Elemente
i <- c(1,3,2)
x[i]             # 10 30 20
x[c(1,1)]        # 10 10; Mehrfach gleiches Element

x[5]             # NA

which(x > 20)    # 3 4; which gibt TRUE Positionen
x[which(x > 20)] # 30 40; Über Position
\end{lstlisting}


\paragraph{Negative Indizes}

Negative Indizes schließen die angegebenen Positionen aus dem Ergebnis aus. Positive und negative Indizes dürfen nicht gemischt werden.

\begin{lstlisting}
x <- c(10, 20, 30, 40)
x[-c(1,3)]       # 20 40; Alle außer Position 1 und 3

x[-which(x>20)]  # 10 20
x[-which(x>50)]  # leerer Vektor

#x[c(-1,3)]      ## Error, positiv und negativ
\end{lstlisting}


\paragraph{Logische Indizierung}

Bei der logischen Indizierung wird ein logischer Vektor verwendet, um Elemente
auszuwählen. Der logische Index wird bei Bedarf automatisch wiederholt.

\begin{lstlisting}
x <- c(10, 20, 30, 40)
x[c(TRUE,FALSE,FALSE,TRUE)] # 10 40
x[c(TRUE,FALSE)] # 10 30; Wird automatisch wiederholt

x > 20           # FALSE FALSE TRUE TRUE
x[x > 20]        # 30 40
x[!(x > 20)]     # 10 20; ! (not)
x[! x > 20]      # 10 20; Das gleiche
x[!(x > 50)]     # 10 20 30 40
\end{lstlisting}


\subsubsection{Benannte Vektoren}

Elemente können auch Namen haben, über die auf sie zugegriffen werden kann.
Mit \lstinline|names()| können Namen abgefragt oder gesetzt werden.
Namen können bei bestehenden Vektoren mit \lstinline|setNames()| gesetzt werden.
Mit \lstinline|unname()| können Namen entfernt werden.

\begin{lstlisting}
x <- c("3"=10, b=20, c=30, d=40)
x["c"]           # 30; behält Namen
x[["c"]]         # 30; Nur Wert, ohne Namen
x[c("c", "d")]   # 30 40
#x[[c("c", "d")]]## Error, geht nur für ein Element
#x$c             ## Error, $ nicht bei Vektor
x[3]             # 30; Über Position
x["3"]           # 10; Über Namen

x <- c(1, 3, 2)
names(x)         # NULL
names(x) <- c("a", "c", "b")
x                              # a c b
                               # 1 3 2
unname(x)                      # 1 3 2
names(x) <- NULL               # Namen Löschen

setNames(x, c("a", "c", "b"))  # a c b
                               # 1 3 2
setNames(nm = x)               # 1 3 2; Namen aus den Werten
                               # 1 3 2
\end{lstlisting}

\subsubsection{Anfang und Ende}

Mit \lstinline|head()| und \lstinline|tail()| erhält man den Anfang bzw.\ das Ende eines Vektors.

\begin{lstlisting}
x <- 1:5
head(x, 2)    # 1 2; Ersten zwei Elemente
tail(x, 2)    # 4 5; Letzten zwei Elemente
head(x, -2)   # 1 2 3; Ohne die letzten beiden
tail(x, -2)   # 3 4 5; Ohne die ersten beiden
\end{lstlisting}


\subsubsection{Veränderung}

Bestehende Vektoren können mit \lstinline|c()| aneinander gehängt werden.

\begin{lstlisting}
x <- 1:3
x <- c(x, 4L)     # 1 2 3 4; Element anhängen
y <- 5:6
c(x, y)           # 1 2 3 4 5 6
\end{lstlisting}

Die Funktion \lstinline|c()| erzeugt jedes Mal einen \emph{neuen} Vektor und kopiert dabei alle Elemente. Das wiederholte Anhängen von Elementen in einer Schleife kann bei großen Vektoren langsam werden.

\begin{lstlisting}
x <- integer(0)
for (i in 1:100000) x <- c(x, i)

x <- integer(100000)
for (i in 1:100000) x[i] <- i
\end{lstlisting}

Mit \lstinline|append()| kann an einer bestimmten Position eingefügt werden.

\begin{lstlisting}
x <- 1:3
append(x, 5:6, 2)   # 1 2 5 6 3; nach Position 2 einfügen
append(x, 5:6, 9)   # 1 2 3 5 6; Position 9 gibt es nicht
\end{lstlisting}

Elemente können mit \lstinline|<-| überschrieben werden.

\begin{lstlisting}
x <- 1:3          # 1 2 3; Integer
x[2] <- 4L        # 1 4 3; zweites Element ändern
x[2] <- 2         # 1 2 3; Int wird Numeric
x[2:3] <- 5:6     # 1 5 6
x[x>1] <- 2       # 1 2 2; Alle >1 auf 2 ändern
x[5] <- 5         # 1 2 2 NA 5; Element hinterm Ende einfügen
x[] <- 2          # 2 2 2 2 2: Alle Elemente werden 2
x[c(2,4)] <- 3    # 2 3 2 3 2
\end{lstlisting}

Die Reihenfolge kann mit \lstinline|rev()| umgedreht werden.

\begin{lstlisting}
rev(1:3)          # 3 2 1
\end{lstlisting}

Einen Index, mit dem die Elemente sortiert sind, erhält man mit \lstinline|order()|. Mit \lstinline|sort()| kann man einen Vektor sortieren. Mit \lstinline|rank()| bekommt man den Rang.

\begin{lstlisting}
x <- c(1,3,2,1)
i <- order(x)       # 1 4 3 2
x[i]                # 1 1 2 3
is.unsorted(x)      # TRUE
is.unsorted(x[i])   # FALSE
sort(x)             # 1 1 2 3
rank(x)             # 1.5 4.0 3.0 1.5
\end{lstlisting}

Einmalige Elemente erhält man mit \lstinline|unique()|, die Positionen von doppelten Elementen mit \lstinline|duplicated|.

\begin{lstlisting}
x <- c(2, 2, 1, 1, 3)
unique(x)         # 2 1 3
duplicated(x)     # FALSE TRUE FALSE TRUE FALSE
\end{lstlisting}



%%% HIER WEITER %%%

\subsection{Grundtypen}

Die elementaren Datentypen bilden die Basis aller atomaren Vektoren.


\subsubsection{logical}

Kann entweder \lstinline|FALSE| oder \lstinline|TRUE| sein.

Übliche Operatoren für einzelne Elemente sind \lstinline|&&| (and, und), \lstinline{||} (or, oder) und \lstinline|!| (not, nicht).

\begin{lstlisting}
FALSE && TRUE          # FALSE
TRUE  || FALSE         # TRUE
!TRUE                  # FALSE
!FALSE                 # TRUE
\end{lstlisting}

% & und |

% TRUE + TRUE



\subsubsection{integer}
\subsubsection{double} numeric

R kennt spezielle Werte für ungültige oder unendliche Zahlen.

\begin{lstlisting}
NaN                       # Not a Number (z.B. 0/0)
Inf                       # Unendlich (z.B. 1/0)
-Inf                      # Negativ unendlich (z.B. -1/0)
\end{lstlisting}

\subsubsection{complex}
\subsubsection{character}
\subsubsection{raw}

\subsubsection{NA}

R kennt spezielle Werte für fehlende Daten. Sie sind typabhängig und verhalten sich in Berechnungen wie reguläre Werte ihres jeweiligen Typs.

\begin{lstlisting}
NA                        # Fehlender Wert vom Typ logical
NA_integer_               # Integer NA
NA_real_                  # Double NA
NA_character_             # Character NA
is.na(1)                  # FALSE
is.na(NA)                 # TRUE

typeof(1L + TRUE)         # integer
typeof(1L + NA)           # integer
typeof(1L + 1.5)          # double
typeof(1L + NA_real_)     # double
\end{lstlisting}

\subsection{NULL}



Rekursive Objekte können als Elemente R-Objekte und mit diesen verschiedenen Typen enthalten.
\lstinline|is.recursive()| prüft ob ein Objekt rekursiv ist.

\begin{lstlisting}
x <- list(1, 2)
is.recursive(x)  # TRUE
\end{lstlisting}


\iffalse

atomare Typen:
    logical → TRUE / FALSE
    integer → ganze Zahlen (1L)
    double → Gleitkommazahlen
    numeric → Alias für double
    complex → komplexe Zahlen
    character → Zeichenketten
    raw → Binärdaten
    NULL
    NA
    
Mengen
Gleicher Typ:
  vektor
Verschiedenen Typen:
  list
  environment

Objektklassen
Klassen, die auf atomaren Typen oder Listen aufbauen.
Datum & Zeit

    Date → basiert auf double

    POSIXct → double (Sekunden seit 1970)

    POSIXlt → list

    POSIXt → virtuelle Oberklasse für POSIXct & POSIXlt

Kategorische Daten

    factor → integer + Levels (character)

Datenstrukturen

    data.frame → spezielle list

    matrix, array
    
Sprach- & Codeobjekte (Language Objects)
Diese repräsentieren R-Code selbst.
Sprachobjekte:

    language (Oberbegriff)

    call → Funktionsaufruf

    expression → Liste von Calls

    name / symbol → Variablennamen
quote(x + y)   # call
expression(x + y)  # expression

Funktionen & Formeln

    function → ausführbarer Code

    formula → spezielle Sprache (y ~ x)

    Beide gehören nicht zu atomaren Typen, sondern sind eigene Objektklassen.

    

\subsection{Grundtypen}

character
complex
Date
double
factor
integer
logical
numeric
POSIXct
POSIXlt
POSIXt
raw

formula
function
language

call
expression

name
symbol

environment
data.frame
list
vector

\fi


\begin{lstlisting}[language=R]
1              # Double
1L             # Integer (standardmäßig 32 Bit)
1.0            # Double
0x2a           # 42, Double (hexadezimal)
0x2aL          # 42, Integer (hexadezimal)
TRUE           # Boolean
FALSE          # Boolean
'abc'          # String
"abc"          # String
r"(abc)"       # String ohne Interpretation
as.raw(97)     # Raw (Byte)
as.raw(0x61)   # Raw
charToRaw("a") # 61; Raw
\end{lstlisting}

R unterstützt auch komplexe Zahlen. Zur exakten Berechnung mit sehr großen Zahlen oder Brüchen lassen sich externe Pakete wie \texttt{gmp} (ganze und rationale Zahlen) oder \texttt{Rmpfr} (Gleitkommazahlen) verwenden.

\begin{lstlisting}
-4+0i                            # Komplexe Zahl
#sqrt(-4)                        ## NaN; Warnung
sqrt(-4+0i)                      # 0+2i

2147483647L                      # Größte Integerzahl
2147483647L + 1L                 # NA; Ganzzahlüberlauf
2147483648L                      # Warnung Umwandlung in Double
as.character(2^53)               # 9007199254740992
as.character(2^53 - 1)           # 9007199254740991
as.character(2^53 + 1)           # 9007199254740992 !
as.character(2^53 + 2)           # 9007199254740994
0.1 + 0.2 == 0.3                 # FALSE; Rundungsfehler
all.equal(0.1 + 0.2, 0.3)        # TRUE; Einstellbare Toleranz

2^53 + 1 + 1 - 2^53              # 0
sum(2^53, 1, 1, -2^53)           # 0
sum(c(2^53, 1, 1, -2^53))        # 2

library(gmp)
as.bigz("2147483648")            #  2147483648 als Ganzzahl
#as.bigz(9007199254740993)       ## 9007199254740992
as.bigz("9007199254740993")      #  9007199254740993

as.bigq(1L, 3L)                  #  exakter Bruch 1/3
as.bigq(2L, 4L)   # 1 / 2
as.bigq(0.5, 1)   # 1 / 2

library(Rmpfr)
mpfr("9007199254740992.5", 55L)  # 9007199254740992.5
mpfr("9007199254740992.75", 55L) # 9007199254740993
mpfr("9007199254740992.75", 56L) # 9007199254740992.75

format(1/3, digits=20)           # 0.33333333333333331483
mpfr(as.bigq(1L, 3L), 64)        # 0.333333333333333333342
\end{lstlisting}

\subsection{Vector}

Ein Vektor ist eindimensional, enthält Elemente des gleichen Typs und kann beliebig lang sein. Mit \lstinline|c| werden mehrere Werte zu einem Vektor oder einer Liste zusammengefügt.

\begin{lstlisting}[language=R]
1                 # numerischer Vektor mit Länge 1
c(1, 2, 3)        # numerischer Vektor mit Länge 3
c("a", "b", "c")  # Zeichen-Vektor (String)
c(1, 2, "x")      # Zahlen werden in String umgewandelt

x = c(a=1, "b b"=2, a=3)   # Elemente bekommen einen Namen
names(x)                   # "a" "b b" "a"
x["a"]                     # 1; gibt ersten Treffer zurück
make.names(names(x), TRUE) # "a" "b.b" "a.1"
make.unique(names(x))      # "a" "b b" "a.1"
length(x)                  # 3
x[3]                       # 3; Inhalt drittes Element
x[4]                       # NA

vector("integer", 3)       # 0 0 0; Erzeugt int Vektor
integer(3)                 # 0 0 0; Erzeugt int Vektor

x <- Matrix::sparseVector(c(3,5,7), c(1,10,90), 100)
# Erzeugt wenig besetzten Vektor
x[1]                       # 3
x[2]                       # .
x[101]                     # NA
\end{lstlisting}

R kennt keinen eigenen Zeichentyp (char); einzelne Zeichen werden als Zeichenketten (Strings) der Länge 1 behandelt.


\subsection{Matrix, Array}

Array ist eine ein bis mehrdimensionale Strukturen die Elemente des gleichen Typs enthält. Eine Matrix ist ein zweidimensionales Array.

Operationen sind meist schneller, wenn sie der Anordnung der Elemente im Speicher folgen. In R werden Matrizen und mehrdimensionale Arrays spaltenweise (d.\,h.\ in der Reihenfolge der ersten Dimension) im Speicher abgelegt, weshalb spaltenorientierte Berechnungen meist effizienter sind als zeilenorientierte.

\begin{lstlisting}[language=R]
array(1:3, dim=3)                # 1D-Array
x <- matrix(1:6, nrow=2, ncol=3) # 2x3 Matrix
matrix(1:6, 2, 3, byrow=TRUE)    # Füllt zeilenweise
rownames(x)                      # Zeilennamen
colnames(x)                      # Spaltennamen
length(x)                        # 6
nrow(x)                          # 2
ncol(x)                          # 2
a <- array(1:8, dim=c(2,2,2))    # 3D-Array 2x2x2
dimnames(a)                      # Dimensionsnamen
dim(a)                           # 2 2 2
is.matrix(a)                     # FALSE
is.array(a)                      # TRUE

x <- Matrix::sparseMatrix(c(1,100), c(1,100), x=c(2,3),
                          dims=c(100,100))
# Erzeugt wenig besetzte Matrix
x[1,1]                           # 2
x[5,5]                           # 0
\end{lstlisting}

\subsection{List}

%%% Copy-on-Modify für Listen %%%

Eine Liste ist ein Vektor für Objekte beliebiger Typen und Längen.

\begin{lstlisting}[language=R]
list(1, "a", TRUE, c(1,2))  # Liste mit verschiedenen Typen
c("a", list(2, 3))          # c fügt Listen zusammen
vector("list", 3)           # Erzeugt Lite mit 3 Elementen
\end{lstlisting}

\subsection{Data.frame}

Ein data.frame ist eine tabellarische Datenstruktur in R, die als Liste gleich langer Spalten organisiert ist. Die Spalten sind in der Regel Vektoren, können aber auch komplexere Objekte enthalten, solange alle Spalten die gleiche Länge haben.

\begin{lstlisting}[language=R]
x = data.frame(Name=c("Anna", "Max"), Alter=c(25, 30))
x$l = list(3:2, "a")                   # list als Spalte
x$m = matrix(1:6, 2)                   # matrix als Spalte
x$d = data.frame(a=c("c", "d"), b=2:1) # data.frame als Spalte
names(x)                               # Spaltennamen
length(x)                              # Anzahl Spalten
ncol(x)                                # Anzahl Spalten
nrow(x)                                # Anzahl Zeilen
row.names(x)                           # Zeilennamen
head(x)                                # Anfang
tail(x)                                # Ende
summary(x)                             # Datenüberblick
str(x)                                 # Daten Struktur
\end{lstlisting}

\subsection{Factor}

Ein factor repräsentiert kategoriale Daten. Intern werden diese als Ganzzahlen mit zugehörigen Namen (Levels) gespeichert.

\begin{lstlisting}[language=R]
f <- factor(c("rot", "blau", "rot")) # Faktor erstellen
levels(f)        # "blau" "rot"
nlevels(f)       # 2
unclass(f)       # 2 1 2; interne Ganzzahl-Repräsentation

# Geordneter Faktor (ordinal)
f <- ordered(c("wenig", "mittel", "viel"),
             levels = c("wenig", "mittel", "viel"))

# Faktor mit systematisch generierten Levels
gl(3, 2)  # 1 1 2 2 3 3; erzeugt Faktor mit 3 Levels
\end{lstlisting}

\subsection{Datum und Zeit}

R kennt mehrere Klassen für Zeitangaben:
\lstinline|Date| für reine Datumsangaben sowie
\lstinline|POSIXct| und \lstinline|POSIXlt| für kombinierte Datums- und Zeitangaben.
Zeitdifferenzen werden mit \lstinline|difftime| dargestellt.

\begin{lstlisting}[language=R]
Sys.Date()                # "2025-10-24"; Aktuelles Datum
as.Date("2025-10-24")     # Standardformat: "%Y-%m-%d"
as.Date("24.10.2025", format = "%d.%m.%Y")
  
Sys.time()                # "2025-10-24 08:16:44 CEST"
Sys.timezone()            # "Europe/Vienna"; Lokale Zeitzone
ct <- as.POSIXct("2025-10-24 08:16:44")
# "2025-10-24 08:16:44 CEST"
as.POSIXct("2025-10-24 08:16:44", "UTC")
# "2025-10-24 08:16:44 UTC"
ISOdatetime(2025, 10, 24, 8, 16, 44)
# "2025-10-24 08:16:44 CEST"
ISOdate(2025, 10, 24)
# "2025-10-24 12:00:00 GMT"
unclass(ct)               # 1761286604; Sekunden seit 1970-01-01
lt <- as.POSIXlt("2025-10-24 08:16:44") #Liste mit Jahr, Monat..
lt$hour                   # 8

as.Date("2024-3-1") - as.Date("2024-2-1") # 29 days
a <- ISOdate(2025, 10, 1, 8, 0, 0)
e <- ISOdate(2025, 10, 1, 9, 10, 30)
e - a                                     # 1.175 hours
difftime(e, a, units = "mins")            # 70.5 mins

seq(as.Date("2025-10-01"), as.Date("2025-10-25"), "1 week")
# "2025-10-01" "2025-10-08" "2025-10-15" "2025-10-22"
seq(as.Date("1582-10-4"), as.Date("1582-10-15"), "1 day") # !
# "1582-10-04" "1582-10-05", ..., "1582-10-14" "1582-10-15"

.leap.seconds  # Zeigt Schaltsekunden
seq(ISOdate(2016,12,31,23,59,59), by="1 sec", length.out = 3)
# "2016-12-31 23:59:59 GMT" "2017-01-01 00:00:00 GMT"
# "2017-01-01 00:00:01 GMT"
ISOdate(2016, 12, 31, 23, 59, 60)   #  "2017-01-01 GMT"
as.POSIXlt("2016-12-31 23:59:60", tz = "UTC")
# "2016-12-31 23:59:60 UTC"
\end{lstlisting}

\subsection{NULL}

\lstinline|NULL| repräsentiert ein Objekt ohne Wert oder Inhalt. 
Es ist ein spezieller Typ, der häufig für leere Rückgaben, Platzhalter oder gelöschte Einträge verwendet wird.
Vektoren können \lstinline|NULL| nicht enthalten, da alle Elemente eines Vektors denselben Typ besitzen müssen.

\begin{lstlisting}[language=R]
x <- NULL
is.null(x)            # TRUE
length(x)             # 0

x <- c(1, NULL, 3, 4) # 1 3 4; NULL Verschwindet
#x[2] <- NULL         ## Fehler
x[2] <- list(NULL)    # Wandelt Vector a in Liste um

x <- list(1, NULL, 3) # [[1]] 1  [[2]] NULL  [[3]] 3
x[[3]] <- NULL        # Löscht drittes Element
x[2] <- NULL          # Löscht zweites Element
x[1] <- list(NULL)    # Fügt NULL ein

x <- data.frame(a=1:2, b=3:4)
x$c <- list(NULL, 2)  # Fügt neue Liste ein
x$b <- NULL           # Löscht Spalte b
\end{lstlisting}


\section{Subsetting (Teilmengen)}

In R werden Elemente von Datenstrukturen mit Hilfe von Subsetting ausgewählt. Die gebräuchlichsten Subsetting-Operatoren sind \lstinline|[ ]|, \lstinline|[[ ]]| und \lstinline|$|. Subsetting kann mit numerischen Indizes, logischen Vektoren oder Namen erfolgen.

\lstinline|[ ]| gibt immer ein Objekt des gleichen Typs zurück (z.\,B. Liste, data.frame), sofern \lstinline|drop=FALSE| gesetzt ist, \lstinline|[[ ]]| extrahiert ein einzelnes Element.

\begin{lstlisting}[language=R]
v <- c(a=10, b=20, c=30, d=40, e=50)
v[2]             # 20; Element an Position 2
v[[2]]           # 20
v[1:3]           # 10 20 30; Element 1 bis 3
v[3:1]           # 30 20 10; Element 3 bis 1
v[c(1,3,5)]      # 10 30 50; Mehrere Elemente
v[c(1,1)]        # 10 10; Mehrfach gleiches Element
v[-c(2,4)]       # 10 30 50; Alle außer Position 2 und 4: 
v["c"]           # 30; Über Namen
#v$c             ## Fehler
v[6]             # NA
#v[[6]]          ## Fehler, Indizierung außerhalb
v[c(TRUE,FALSE,TRUE,FALSE,TRUE)] # 10 30 50; Logisch
v[c(TRUE,FALSE)] # 10 30 50; Wird automatisch wiederholt
v[v>30]          # 40 50; Logisch
v[!v>30]         # 10 20 30; ! (not)
v[which(v>30)]   # 40 50; Über Position
v[-which(v>30)]  # 10 20 30
v[-which(v>50)]  # Nichts!
v                # Ganzer Vektor
v[]              # Ganzer Vektor
v[0]             # Nichts
v[-0]            # Nichts
v[NULL]          # Nichts
v[integer(0)]    # Nichts

m <- matrix(1:6, 2, dimnames=list(c("a","b")))
m[2, 3]         # 6; Zeile 2, Spalte 3
m[[2, 3]]       # 6
#m[[c(3, 2)]]   ## Fehler
#m[1, 4]        ## Fehler, Indizierung außerhalb
#m[[1, 4]]      ## Fehler, Indizierung außerhalb
m[1, ]          # 1 3 5; Vektor, Ganze 1. Zeile
#m[[1, ]]       ## Fehler,  missing subscript
m["a", ]        # 1 3 5; Vektor, Zeile a
m[1, , drop=FALSE]  # 1 3 5; Matrix
m[, 2]          # 3 4; Ganze Spalte 2
m[-1, -3]       # Ohne Zeile 1 und Spalte 3
m[2, 2:3]       # Zeile 2, Spalte 2 bis 3
m[4]            # 4; Kann wie Vektor verwendet werden
m[[4]]          # 4
m[7]            # NA
#m[[7]]         ## Fehler, Indizierung außerhalb
m[m>3]          # 4 5 6
a <- array(1:8, dim=c(2,2,2))
a[ , , 1]       # Erste Schicht

l <- list(a=1, b=c(a=2,b=3,c=4), c="Hallo")
l[2]            # 2 3 4; Liste mit zweitem Element
l[[2]]          # 2 3 4; Zweites Element
l[[2]][[1]]     # 2; Zweites Element, erster Eintrag
l[[c(2, 1)]]    # 2; Zweites Element, erster Eintrag
l[[c("b", "a")]]# 2; Element b, Eintrag a
#l[[1,2]]       ## Fehler, falsche Anzahl Subscripts
l$b             # 2 3 4; Element b
l["b"]          # 2 3 4; Liste mit Element b
l[["b"]]        # 2 3 4; Element b
l[1:2]          # Liste mit Element 1 und 2
l[c("a","c")]   # Liste mit Element a und c
l[-2]           # Liste ohne zweites Element
l[c(TRUE, FALSE)] # Liste jedes zweites Element
l[4]            # NULL
#l[[4]]         ## Fehler, Indizierung außerhalb
l <- list(x = 1, y = list(z = 2, w = 3))
l$y$z           # 2; verschachtelter Zugriff

Ich habe in R ein data.frame d und möchte dort vom Spalte 2 die Elemente 2 und 1 abfragen, was mit "d[[2]][2:1]" geht. Warum geht "d[[2:1, 2]]" nicht?

d <- data.frame(a=c("d","e"), b=2:1)
d[[2]][2:1]
d[[2:1, 2]]  # Fehler


d <- data.frame(a=c("d","e"), b=2:1)
d[1, ]          # d 2; data.frame, Erste Zeile
d[, 2]          # 2 1; Vektor, Zweite Spalte
d[[2]]          # 2 1; Vektor, Zweite Spalte
d[2]            # 2 1; data.frame, Zweite Spalte
d[, 2, drop=FALSE] # 2 1; data.frame, Zweite Spalte
d[, "b"]        # 2 1; Vektor
d$b             # 2 1; Vektor
d$b[1]          # 2; Erstes Element von Spalte b
d[1, "b"]       # 2; Variante
d[1, 2]         # 2; Variante
d[[2]][1]       # 2; Variante
d[[2]][[1]]     # 2; Variante
d[[1, 2]]       # 2; Variante
d[[c(2, 1)]]    # 2; Variante
d[[1, "b"]]     # 2; Variante
d$b[2:1]        # 1 2; Element 2, 1 von Spalte b
d[2:1, "b"]     # 1 2; Variante
d[2:1, 2]       # 1 2; Variante
d[[2]][2:1]     # 1 2; Variante
#d[[2]][[2:1]]  ## Error; [[ geht nur für ein Element
#d[[2:1, 2]]    ## Error; [[ geht nur für ein Element
d[2:1, 2:1]     # Reihenfolge von Zeilen und Spalten ändern
d[-1, ]         # data.frame ohne erste Zeile
d[, -1]         # Da nur eine Spalte => Vektor
d[, 1:2]        # Spalten 1 bis 2
d[c(TRUE, FALSE),] # Jede zweite Zeile
d[0]            # data.frame mit 0 Spalten
d[0,]           # data.frame mit 0 Zeilen
d[d$a == "d", ] # Zeilen, bei denen a == "d"
d[d$b > 1, "a"] # Spalte a, Zeilen mit b > 1
d[d$a == "d" & d$b > 1, ] # d 2
#d[3]           ## Fehler, nicht definierte Spalte
#d[[3]]         ## Fehler, Indizierung außerhalb
d$b[3]          # NA

e <- new.env()
e$a <- 1
assign("b", 2, envir = e)
e$a                  # 1
e$b                  # 2
e[["a"]]             # 1
#e[[1]]              ## Fehler
#e["a"]              ## Fehler
e[["c"]]             # NULL
get("a", envir = e)  # 1; Sucht auch in Parrent
rm(b, envir = e)     # Löscht Element b
ls(e)                # "a"; Listet Elemente von e
\end{lstlisting}

\section{Datenmanipulation}

\subsection{Operatoren}

Dieses Beispiel zeigt die wichtigsten arithmetischen, Vergleichs- und
logischen Operatoren.

\begin{lstlisting}
x <- 1:3
y <- c(2, 4, 6)
x + y     # 3 6 9; Elementweise Addition
x - y     # -1 -2 -3; Subtraktion
x * y     # 2 8 18; Multiplikation
y / x     # 2 2 2; Division
x^2       # 1 4 9; Potenzierung
x %% 2    # 1 0 1; Rest der Division (Modulo)
x %/% 2   # 0 1 1; Ganzzahldivision
1 + 2 * 3    # 7; Multiplikation vor Addition
(1 + 2) * 3  # 9; Klammern ändern Reihenfolge

x < 2           # TRUE  FALSE FALSE
x > 2           # FALSE FALSE TRUE
x <= 2          # TRUE  TRUE  FALSE
x >= 2          # FALSE TRUE  TRUE
x == 2          # FALSE TRUE  FALSE
x != 2          # TRUE  FALSE TRUE
x > 1 & x < 3   # FALSE TRUE  FALSE; UND (elementweise)
x > 1 | x < 3   # TRUE  TRUE  TRUE;  ODER (elementweise)
xor(x>1, x<3)   # TRUE  FALSE TRUE
!(x > 1)        # TRUE  FALSE FALSE; Negation

FALSE && TRUE          # FALSE
TRUE  || FALSE         # TRUE
l <- TRUE
FALSE && (l <- FALSE)  # Auswertung bis Ergebnis klar
l                      # TRUE
TRUE && (l <- FALSE)
l                      # FALSE
NA && TRUE             # NA
NA || TRUE             # TRUE

sum(x > 1)        # 2; Anzahl der Elemente > 1
any(x > 2)        # TRUE; Mindestens ein TRUE?
all(x > 0)        # TRUE; Alle TRUE?
which(x > 1)      # 2 3

1 == 1L           # TRUE
identical(1, 1L)  # FALSE; Typ unterschiedlich
\end{lstlisting}

\subsection{String}

Das folgende Beispiel zeigt typische Operationen zur Verarbeitung von
Zeichenketten in R, einschließlich Zählen, Suchen, Ersetzen, Aufteilen
und Vergleichen von Strings.

\begin{lstlisting}
s <- c("Mehr", "Licht")
nchar(s)                  # 4 5; Anzahl Zeichen
nchar(c("a", "ä"), "bytes") # 1 2
nzchar(s)                 # TRUE TRUE; Länge > 0
toupper(s)                # "MEHR" "LICHT"
tolower(s)                # "mehr" "licht"
chartr("hi", "Xy", s)     # "MeXr" "LycXt"; Zeichen austauschen

grepl("c.", s)            # FALSE TRUE ; enthält Regex "c."
grepl("c.", s, fixed=TRUE)# FALSE FALSE; enthält "c."
grep("ch", s)             # 2; Index des Treffers
grep("ch", s, value=TRUE) # "Licht"

agrep("Meer", s)          # 1; Ungefähre Treffer
adist("Meer", s)          # 1 5; String Abstände

i <- regexpr("[eih]", s)  # Erster Treffer von e, i, oder h
regmatches(s, i)          # "e" "i"; Treffer Ausgeben
i <- gregexpr("[eih]", s) # Alle Treffer von e, i, oder h
regmatches(s, i)          # "e" "h", "i" "h"
s1 <- lapply(regmatches(s, i), \(x) paste0("<", x, ">"))
regmatches(s, i) <- s1    # Treffer überschreiben
s                         # "M<e><h>r"  "L<i>c<h>t"

s <- c("abcd", "dcba")    # Mehrere ersetzen
r <- c(ef="a", gh="c")    # a=>ef, c=>gh
i <- gregexpr(paste(r, collapse="|"), s)
s1 <- lapply(regmatches(s, i), \(x) names(r)[match(x, r)])
regmatches(s, i) <- s1
s                         # "efbghd" "dghbef"

sub("a", "xz", "aba")     # "xzba"; erstes Vorkommen ersetzen
gsub("a", "xz", "aba")    # "xzbxz"; alle ersetzen
gsub("([ac])", "<\\1>", "abc") # "<a>b<c>"; Treffer verwenden
gsub("\\s+", " ", "a  b") # "a b"; Mehrfachleerzeichen=> " "
trimws("  Text  ")        # "Text"; Umgebende " " entfernen

s <- c("Mehr", "Licht")
toString(s)               # "Mehr, Licht";Fügt mit ", " zusammen
s <- paste(s[1], s[2])    # "Mehr Licht"; Fügt mit " " zusammen
strsplit(s, " ", TRUE)    # Liste: "Mehr" "Licht"; Trennt String
paste(c("A","B","C"), collapse=", ") # "A, B, C"
paste("A", 1:3, sep="-")  # "A-1" "A-2" "A-3"
paste0("A", 1:3)          # "A1" "A2" "A3"
sprintf("Pi: %0.2f", pi)  # "Pi: 3.14"; formatiertes Einfügen

substr(s, 1, 4)           # "Mehr"; Teilstring
substr(s, 1, 4) <- "Weniger"  # "Weni Licht"; Nur Teil ersetzt !
strtrim(s, 3)             # "Wen"; auf Länge 3 kürzen

startsWith(s, "Wen")      # TRUE; beginnt mit "Wen"
endsWith(s, "ht")         # TRUE; endet mit "ht"

charToRaw("ä")            # c3 a4; Bytes anzeigen
s <- "\u00e4"             # "ä"
iconv("Müller", "UTF-8", "latin1")  # Encoding ändern
utf8ToInt("ä")            # 228
intToUtf8(228)            # "ä"

s <- noquote(c("Ab", "C"))# Ausgabe ohne Anführungszeichen
s                         # Ab C

s <- c("Ab", NA, "C")
paste("x", s, sep="-")   # "x-Ab" "x-NA" "x-C"; NA wird String !

s <- c("ä", "a", "b")
Sys.setlocale("LC_COLLATE", "C")  # ASCII-Reihenfolge
sort(s)                  # "a" "b" "ä"
"ä" < "z"                # FALSE
Sys.setlocale("LC_COLLATE", "de_AT.UTF-8")
sort(s)                  # "a" "ä" "b"
"ä" < "z"                # TRUE
\end{lstlisting}

\subsection{Factor}

Faktoren werden zur Darstellung kategorialer Daten verwendet.
Im Folgenden einige kurze Beispiele zur Manipulation von Faktoren.

\begin{lstlisting}
f <- factor(c("rot", "blau", "rot"))
f <- relevel(f, "rot")  # "rot" wird erster Level

n <- c(3, 2, 2)
reorder(f, n)           # sortiert Levels

# Reihenfolge der Levels festlegen
f <- factor(c("rot", "blau", "rot"), c("rot", "blau"))
#f < "blau"             ## Warning: < nicht sinnvoll
f <- ordered(c("rot", "blau", "rot"), c("rot", "blau"))
f < "blau"              # TRUE FALSE  TRUE

levels(f)[levels(f) == "rot"] <- "grün" # "rot" wird "grün"

# Mehrere Levels umbenennen, zusammenfassen
f <- factor(c("j","n","ja","X","ja","nein","X"))
levels(f)                # "j" "ja" "n" "nein" "X"
levels(f)[match(c("j","n"), levels(f))] <- c("ja","nein")
levels(f)                # ja nein X
#
f <- factor(c("j","n","ja","X","ja","nein","X"))
levels(f) <- list(ja=c("ja","j"), nein=c("nein","n"), X="X")
#
f <- factor(c("j","n","ja","X","ja","nein","X"))
local({
  s <- c(ja="j", nein="n", m="u")
  i <- match(levels(f), s, 0)
  levels(f)[i != 0] <<- names(s)[i]
})

f <- factor(c("A","B"), levels = c("A","B","C"))
levels(f)                # "A" "B" "C"
f[2:1]                   # Behällt alle Levels
f[2:1, drop=TRUE]        # Nur die vorhandenen Levels
f <- droplevels(f)       # Entfernt unbenutzte Levels
levels(f)                # "A" "B"
#f[3] <- "C"             ## Warning => NA
levels(f) <- c(levels(f), "C") 
f[3] <- "C"

f <- factor(c(2,1,3,2,1), c(2,3,1))
unclass(f)               # 1 3 2 1 3; Interner Repräsentant
as.integer(f)            # 1 3 2 1 3
as.numeric(levels(f))[f] # 2 1 3 2 1
as.character(f)          # "2" "1" "3" "2" "1"

f <- factor(c("b","a","b","c","a"))
x <- table(f)            # a b c; Häufigkeiten pro Level
                         # 2 2 1
summary(f)               # 2 2 1
addmargins(x)            # 2 2 1 5
proportions(x)           # 0.4 0.4 0.2

f1 <- factor(c("A","A","B","B"))
f2 <- factor(c("X","Y","X","X"))
f12 <- interaction(f1, f2) # Kombinieren
f12                      # A.X A.Y B.X B.X
levels(f12)              # "A.X" "B.X" "A.Y" "B.Y"
f12 <- interaction(f1, f2, drop=TRUE) # Nur vorhandene Kombis
levels(f12)              # "A.X" "B.X" "A.Y"
f <- c(f1, f2)           # Faktoren zusammen hängen
f3 <- factor(c("1","1","2","2"))
table(f1, f2, f3)        # 3D Tabelle
ftable(f1, f2, f3)       # 2D Tabelle
x <- c(1.3, 2.4, 0.2, 1.1)
xtabs(x ~ f1 + f2, data.frame(x, f1, f2)) # Summiert x je Gruppe
\end{lstlisting}

\subsection{Vektor}

Das folgende Beispiel zeigt grundlegende Operationen mit Vektoren in
R, einschließlich Erstellen, Indexieren, Sortieren, Gruppieren und
Mengenoperationen.

\begin{lstlisting}
x <- 1:3          # 1 2 3; Integer
x[2] <- 4         # 1 4 3; zweites Element ändern, Int->Numeric
x[2:3] <- 5:6     # 1 5 6
x[x>1] <- 2       # 1 2 2; Alle >1 auf 2 ändern
x[5] <- 5         # 1 2 2 NA 5; Element hinterm Ende einfügen
x <- c(x, 6)      # 1 2 2 NA 5 6; Element anhängen
append(x, 7, 3)   # 1 2 2 7 NA 5 6; nach Position 3 einfügen
x <- tail(x, 4)   # 2 NA 5 6; Letzten 4 Elemente behalten
x <- head(x, 3)   # 2 NA 5; Ersten 3 Elemente behalten
x <- x[-2]        # 2 5; entfernt zweites Element
x <- rev(x)       # 5 2; Reihung umkehren
i <- order(x)     # 2 1; Index mit dem x sortiert ist
order(c(1,2,1))   # 1 3 2
rank(c(1,2,1))    # 1.5 3.0 1.5
x[i]              # 2 5
is.unsorted(x)    # TRUE
is.unsorted(x[i]) # FALSE
x <- sort(x)      # 2 5
x <- x + 1        # 3 6; Alle um 1 erhöhen
x[2] <- "a"       # "3" "a"; Umwandlung in Char
as.numeric(c("1", "2")) # 1 2; explizite Umwandlung

x <- c(2, 2, 1, 1, 3)
unique(x)         # 2 1 3
duplicated(x)     # FALSE TRUE FALSE TRUE FALSE
table(x)          # 1 2 3; Anzahlen
                  # 2 2 1
stem(x)           # stem-and-leaf plot
summary(x)        # Min. 1st Qu. Median Mean 3rd Qu. Max.
range(x)          # 1 3; kleinster und größter Wert
length(x)         # 5; Anzahl Elemente
which.max(x)      # 5; Index des ersten größten Wertes
which.min(x)      # 3; Index des ersten kleinsten Wertes
rle(x)            # lengths: int [1:3] 2 2 1;Run Length Encoding
                  # values : num [1:3] 2 1 3
g <- c("A", "A", "C", "B", "B")
ave(x, g)         # Gruppenmittel für jedes Element
tapply(x, g, mean) # Mittel je Gruppe
s <- split(x, g)  # Teil x in Liste grupiert mit g
lapply(s, mean)   # Mittel je Gruppe
match(x, c(3,1,3))# NA NA  2  2  1; Position erster Treffer
x %in% 1:2        # TRUE  TRUE  TRUE  TRUE FALSE
findInterval(x, c(0,2)) # 2 2 1 1 2;
pmin(x, 2)        # 2 2 1 1 2
pmin(x, 0:4)      # 0 1 1 1 3
pmax(x, 0:4)      # 2 2 2 3 4

x <- c(1,2,3,4)
y <- c(3,4,5,6)
union(x, y)       # 1 2 3 4 5 6; Vereinigung
intersect(x, y)   # 3 4;         Schnittmenge
setdiff(x, y)     # 1 2; Elemente in x, aber nicht in y
setdiff(y, x)     # 5 6; Elemente in y, aber nicht in x
setequal(x, y)    # FALSE; # Mengen gleich?
setequal(x, 4:1)  # TRUE
\end{lstlisting}

\subsection{Matrix und Array}

\begin{lstlisting}
m <- matrix(1:6, 2)  # 2x3 Matrix
as.vector(m)         # Matrix in Vektor
as.data.frame(m)     # Matrix in Data Frame
as.matrix(1:4)       # Vektor in Matrix
rownames(m) <- c("A","B")
colnames(m) <- c("x","y","z")
dimnames(m)          # Dimensionsnamen
t(m)                 # Transponieren
dim(m) <- c(3,2)     # Neue Dimensionen setzen
aperm(m, c(2,1))     # Dimensionen vertauschen

m <- matrix(1:4, 2)
v <- 1:2
m + 1                # Elementweise Rechenoperationen
m + m
m + v                # Spaltenweises Recycling von v
m + v[col(m)]        # Zeilenweise Addition
sweep(m, 1, v, `+`)  # Spaltenweise Addition
sweep(m, 2, v, `+`)  # Zeilenweise Addition
outer(v, 1:3)        # Kreuzweise Kombination zweier Vektoren
outer(v, 1:3, `+`)
outer(v, 1:3, \(x, y) x+y)
row(m)               # Zeilenindex
col(m)               # Spaltenindex
slice.index(m, 1)    # Zeilenindex
slice.index(m, 1:2)  # Vektorindex

m %*% m              # Matrixprodukt
matrix(c(sum(m[1,] * m[,1]), sum(m[2,] * m[,1]),
         sum(m[1,] * m[,2]), sum(m[2,] * m[,2])), 2)
m %*% v              # 7 10
crossprod(m, v)      # t(m) %*% v
tcrossprod(v, m)     # v %*% t(m)
kronecker(diag(1, 2), m) # Kronecker produkt
diag(2)              # Einheitsmatrix
diag(m)              # Diagonale extrahieren
diag(m) <- 0         # Diagonale ändern

m <- matrix(1:6, 2)
rowSums(m)           # 9 12
colSums(m)           # 3 7 11
addmargins(m)        # Zeilen und Spaltensummen
rowMeans(m)          # 3 4
colMeans(m)          # 1.5 3.5 5.5
apply(m, 1, mean)    # 3 4; Margin 1..Zeile
apply(m, 2, sum)     # 3 7 11; Margin 2..Spalte
apply(m, 1, sd)      # 2 2; Standard Deviation
max.col(m)           # 3 3; Splalte mit größtem Wert
apply(m, 1, which.max)# 3 3; Splalte mit größtem Wert

y <- scale(m)        # Zentriert und skaliert Spalten
x <- sweep(m, 2, colMeans(m))
x <- sweep(x, 2, apply(x, 2, sd), `/`)
all(x == y)          # TRUE

proportions(m)       # Gesamte Matrix Summe = 1
proportions(m, 1)    # Zeilenweise
proportions(m, 2)    # Spaltenweise

m <- matrix(1:12, 4)
g <- c("A","B","A","B")
rowsum(m, g)         # Gruppierte Zeilensummen

rbind(m, m)          # Zeilen anhängen
n <- m
colnames(m) <- 1:3
colnames(n) <- 3:1
rbind(m, n)          # Namen werden nicht berücksichtigt
cbind(m, m)          # Spalten anfügen
simplify2array(list(m, m)) # Array aus Matrix
replicate(2, m)      # Array aus Matrix
abind::abind(m, m, along=3) # Beliebig stapeln

split(m, col(m))     # Spaltenweise Aufteilung als Liste
split(m, row(m))     # Zeilenweise Aufteilung

a <- array(1:24, dim=c(2,3,4))
apply(a, 1, sum)     # 144 156; Summe je Zeile
apply(a, 3, sum)     # 21 57 93 129; Summe je Schicht
apply(a, c(1,3), sum)# Summe je Zeile und Schicht
aperm(a, c(2,1,3))   # Dimensionen vertauschen
ftable(a)            # macht 2D Tabelle daraus
b <- a[1,,,drop=FALSE]
drop(b)              # Entfernt 1 Element Dimensionen
i <- which(a > 20)   # Vektor index
which(a > 20, arr.ind=TRUE) # Indizes als Matrix
arrayInd(i, dim(a))  # Wandelt in Matrix Index
\end{lstlisting}

Lineare Algebra

\begin{lstlisting}
A <- matrix(c(2,1,1,3), 2)
b <- c(1,4)

solve(A, b)     # Löst A x = b
solve(A)        # Inverse Matrix
det(A)          # Determinante
eigen(A)        # Eigenwerte/-vektoren
svd(A)          # Singulärwertzerlegung
qr(A)           # QR-Zerlegung
chol(A)         # Cholesky-Zerlegung (symm. positiv)
\end{lstlisting}

\subsection{List und data.frame}

\begin{lstlisting}
l <- list(a = 1:3, b = c("x", "y"), c = TRUE)
lengths(l)      # 3 2 1; Länge der Elemente

l$d <- 99       # Neues Element
l$a <- list(10,20) # Bestehendes Element ersetzen
l$c <- NULL     # Element entfernen
l["c"] <- list(NULL) # NULL einfügen
unlist(l)       # "10" "20" "x" "y" "99"; List2Vektor ohne NULL
unlist(l, FALSE) # Nicht rekursiv, bleibt hier Liste

l2 <- list(a=1, b=2)
c(l, l2)        # Listen zusammenfügen

list(1:3)       # [[1]] 1 2 3
as.list(1:3)    # [[1]] 1 [[2]] 2 [[3]] 3
as.list(iris)   # data.frame => list, Eintrag je Spalte

l <- list(a=1:2, b=list(1, 1:2))
data.frame(l)   # Wandelt b in 2 Vektorspalten um
as.data.frame(l)# Wandelt b in 2 Vektorspalten um
d <- list2DF(l) # b bleibt Liste
d$c <- matrix(1:4, 2) # Matrix als Spalte
d$d <- array(1:8, c(2,2,2)) # Array als Spalte
d[1,]           # Funktioniert bei Array nicht wie erwartet
tibble::tibble(d)[1,] # Hier wie erwartet
#as.matrix(d)         ## Error
as.matrix(d[c(1,2)])  # Geht
as.matrix(d[c(1,3)])  # Geht
#as.matrix(d[c(2,3)]) ## Error

d <- data.frame(a=1:3, row.names = 3:1)
ti <- tibble::as_tibble(d) # Verliert row.names
as.data.frame(ti)

l <- list(a=2, b=3:5, c=5:9)
x <- lapply(l, mean) # [[1]] 2 [[2]] 4 [[3]] 7; Liste
simplify2array(x)    # 2 4 7; Vereinfacht Liste
sapply(l, mean)      # 2 4 7; In einem Schritt
vapply(x, mean, numeric(1)) # 2 4 7; Angabe der Rückgabe

l <- list(a=1:3, b=list(c=3:5, d=5:9))
rapply(l, mean,)     # 2 4 7; rekursiv in Liste anwenden

l1 <- list(1,c(2,3))
l2 <- list(10,c(20,30))
mapply(sum, l1, l2)  # 11 55; mehere Listen gemeinsam
Map(sum, l1, l2)     # Ausgabe als Liste
mapply(sum, l1, l2, SIMPLIFY = FALSE) # Ausgabe als Liste

replicate(2, 1:3, simplify=FALSE) # n mal wiederholen

l <- list(a=1, b=2:3)
do.call(paste, l)             # "1 2" "1 3"
  # Ruft Funktion mit Argumenten aus Liste auf
paste(1, 2:3)                 # "1 2" "1 3"
do.call(paste, c(l, sep="-")) # "1-2" "1-3"
l <- list(a=1, b=2:3, sep="-")
do.call(paste, l)             # "1-2" "1-3"
paste(1, 2:3, sep="-")        # "1-2" "1-3"

l <- list(a=2, b=3:5, c=5:9)
Reduce(\(x, y) x * sum(y), l) # 840; Kumulatives Anwenden
Reduce(\(x, y) x * sum(y), l, 2) # 1680; Mit Startwert
Reduce(\(x, y) x * sum(y), l, 2, accumulate = TRUE)
  # 2 4 48 1680; Jeden Zwischenschritt ausgeben

l <- list(c=1:3, b="x", a=4)
Filter(is.numeric, l)   # Nur numerische Elemente
l[order(names(l))]      # Nach Namen Sortieren
names(l) <- toupper(names(l)) # Namen ändern
\end{lstlisting}

\begin{lstlisting}
d <- data.frame(a=1:4, b=c("x","y"), c=TRUE)
  # b und c werden automatisch wiederholt
dim(d)        # 4 3; Zeilen Spalten
length(d)     # 3; Anzahl Spalten
ncol(d)       # 3; Anzahl Spalten
nrow(d)       # 4; Anzahl Zeilen
names(d)      # Spaltennamen
row.names(d)  # Zeilennamen

#d$d <- 1:3   ## Fehler der Länge
#d$d <- 1:5   ## Fehler der Länge
d$d <- 1:4
d$e <- 1:2    # Wird zu 1 2 1 2
d$f <- 1      # Wird zu 1 1 1 1

d <- data.frame(a=1:2, b=c("x","y"))
d2<- data.frame(b=c("a","b"), a=4:3)
d <- rbind(d, d2) # Zeilen anfügen über Spaltennamen
d3<- data.frame(d=5:6, e=c("f","g"))
#rbind(d, d3)     ## Error, Namen passen nicht
rbind(d, setNames(d3, names(d))) # Spalten umbenenne

d <- data.frame(a=1:2, b=c("x","y"))
d2<- data.frame(a=2:3, c=c(TRUE, FALSE))
cbind(d, d2)      # Spalten anhängen
merge(d, d2)      # Spalten über gemeinsame Spalte a anhängen
merge(d, d2, all=TRUE)   # Alle Daten erhalten
merge(d, d2, all.x=TRUE) # Alle Daten von d  erhalten
merge(d, d2, all.y=TRUE) # Alle Daten von d2 erhalten
d3<- data.frame(a=1, c=c(TRUE, FALSE))
merge(d, d3)      # Zeile 1 von d wird wiederholt
d4<- data.frame(a=1, b=c("x","y"))
merge(d4, d3)      # Alle Kombinationen werden generiert

d <- data.frame(a=1:4, b=c("x","y"))
d$a <- 4:1              # Inhalt von Spalte ändern
d[2,] <- list(5L, "z")  # Inhalt von Zeile ändern
d[2:3,] <- list(7:8, "X")  # Inhalt von Zeilen ändern
d$a <- NULL             # Löscht Spalte a
#d[2,] <- NULL          ## Error
d <- d[-2,,drop=FALSE]  # Löscht Zeile 2

d <- data.frame(a=1:4, b=4:1, g=c("x","y"),h=c("k","k","k","l"))
aggregate(a ~ g, d, mean) # x 2, y 3;Funktion je Gruppe anwenden
aggregate(a ~ g, d, sum)  # x 4, y 6
rowsum(d$a, d$g)          # x 4, y 6; Bei Summierung schneller
tapply(d$a, d$g, sum)     # x 4, y 6; Für einzelne Spalten
xtabs(a ~ g, d)           # x 4, y 6; Alternative
aggregate(a ~ g + h, d, sum) #   g h a; Mehrere Gruppen
                             # 1 x k 4; Als Tabelle
                             # 2 y k 2
                             # 3 y l 4
xtabs(a ~ g + h, d)          #   k l; Mehrere Gruppen
                             # x 4 0; Als Matrix
                             # y 2 4
aggregate(. ~ g, d, sum)  #   g a b; Mehrere Spalten
                          # 1 x 4 6
                          # 2 y 6 4
aggregate(d[1:2], d[3], sum) # Alternativer Aufruf
rowsum(d[1:2], d[,3])     # Schnelle Alternative für Summen
sapply(split(d[1:2], d[3]), colSums) # Alternative

d <- data.frame(a=1:2, b=2:1)
transform(d, a=b, b=a, x=a-b) # a b  x; Zuweisung erst danach
                              # 2 1 -1
                              # 1 2  1
#transform(d, x=a+b, y=x)     ##Error, x nicht gefunden
within(d, {a<-b; b<-a; x<-a-b}) # a b x; Zuordnung sofort
                                # 2 2 0
                                # 1 1 0
within(d, {x<-a+b; y<-x})       # Geht
with(d, a+b)                    # 3 3
attach(d)                       # Zum Suchpfad
a+b                             # 3 3
detach(d)                       # Aus dem Suchpfad

d <- data.frame(x=1:4, g=c("x","y"), t=c(1,1,2,2))
w <- reshape(d, idvar="g", timevar="t", direction="wide")
# g x.1 x.2
# x   1   3
# y   2   4
reshape(w, idvar="g", direction="long")
#     g t x.1
# x.1 x 1   1
# y.1 y 1   2
# x.2 x 2   3
# y.2 y 2   4
\end{lstlisting}


\section{Programmierung}

Es werden Kontrollstrukturen (wenn dann, if), Wiederholungen
bzw.\ Schleifen, Fehlerbehandlung und Funktionen kurz gezeigt.

\subsection{if, else und switch}

\lstinline|if|, \lstinline|else| und \lstinline|switch| zählen zu den
Kontrollstrukturen. \lstinline|if| und \lstinline|else| zählen zu den
Keywords, \lstinline|switch| ist eine Funktion.

\begin{lstlisting}
x <- 5
if (x > 0) {         print("+")
} else if (x == 0) { print("0")
} else               print("-")

if (x > 0) print("+")
if (x > 0) {print("+")}
#else print("!+")    ## Fehler, kein Bezug zu vorigem if
if (x > 0) print("+") else print("!+")
if (x > 0) {print("+")
} else print("!+")

x <- 1:2
#if (x > 0) print("+") ## Fehler, Länge muss 1 sein
x <- NA
#if (x > 0) print("+") ## Fehler, braucht TRUE oder FALSE
x <- NULL
#if (x > 0) print("+") ## Fehler, Länge ist 0
x <- numeric()
#if (x > 0) print("+") ## Fehler, Länge ist 0
\end{lstlisting}

\begin{lstlisting}
x <- c(9,0,2,1,3)
s <- "Mittel"
switch (s,
        Median = median(x),
        Mittel =,            # Geht zur nächsten Zeile
        avg    = mean(x))    # 3
switch (s, sum = sum(x))     # NULL; kein Treffer
switch (s, sum = sum(x), -1) # -1; Angabe für kein Treffer
#switch (1:2, a = 0)         ## Fehler, Länge muss 1 sein
\end{lstlisting}

Daneben gibt es noch \lstinline|ifelse(test, yes, no)|. Sie ist
besonders praktisch für einfache bedingte Ersetzungen, hat jedoch zwei
wesentliche Nachteile:
\begin{itemize}
\item Beide Alternativen \lstinline|yes| und \lstinline|no| werden
  vollständig ausgewertet (auch wenn nur eine benötigt wird).
\item Attribute (z.~B. \lstinline|class|, Datumseigenschaften) gehen
  häufig verloren.
\end{itemize}

\begin{lstlisting}
x <- c(-1:1)
sqrt(x)                      # NaN 0 1; Warung
sqrt(ifelse(x >= 0, x, NaN)) # NaN 0 1; Ohne Warnung
ifelse(x >= 0, sqrt(x), NaN) # NaN 0 1; Warung
sqrt(`[<-`(x, x<0, NaN))     # NaN 0 1; sqrt gibt bei NaN NaN

y <- rep(NaN, length(x))
i <- x >= 0
#i <- which(x >= 0)          # Variante bei wenig TRUE
y[i] <- sqrt(x[i])

x <- seq(as.Date("2000-02-29"), as.Date("2004-10-04"), by = "1 year")
y <- ifelse(as.POSIXlt(x)$mday == 29, x, NA)
y   # 11016    NA    NA    NA 12477; Verliert Attribute
class(y) <- class(x)
y   # "2000-02-29" NA NA NA "2004-02-29"
y2 <- x
y2[as.POSIXlt(x)$mday != 29] <- NA # Effizienter
\end{lstlisting}


\subsection{for, while und repeat}

Mit \lstinline|for|, \lstinline|while| oder \lstinline|repeat| kann man Wiederholungen bzw.\ Schleifen erzeugen.

\begin{lstlisting}
for (i in 1:5) cat(i)  # 12345
i                      # 5; For hat keine eigene Umgebung
for (i in 1:5) {cat(i); i<-i*2} # 12345
i                               # 10
for (i in 1:5) {if (i==3) next; cat(i)} # 1245; Überspringen
for (i in 1:5) {if (i>2) break; cat(i)} # 12; Abbruch

x <- c(3,5,1)
for (y in x) cat(y)               # 351; Direkt
for (i in seq_along(x)) cat(x[i]) # 351; Über Index
cat(x, sep="")                    # 351; Ohne Schleife

x <- 1:1e6
system.time(for (y in x) cat(y))               # 2.756 Sek.
system.time(for (i in seq_along(x)) cat(x[i])) # 3.026 Sek.
system.time(cat(x, sep=""))                    # 0.621 Sek.

i <- 1
while (i <= 5) {
  cat(i)
  i <- i + 1
}                      # 12345

i <- 1
repeat{
  cat(i)
  i <- i + 1
  if(i > 5) break
}                      # 12345
\end{lstlisting}

\subsection{Fehlerbehandlung: try, tryCatch, stop, warning, message}

Fehler können im Program mit \lstinline|try| oder \lstinline|tryCatch| behandelt werden.

\begin{lstlisting}
f1 <- \(x) {
  ret <- NA_real_
  ret <- log(x)
  ret
}
x <- f1("a")
#x                ## Fehler, x nicht gefunden
f1(-1)            # NaN

f2 <- \(x) {
  ret <- NA_real_
  try(ret <- log(x)) # Kein Abbruch
  ret
}
f2("a")           # NA
f2(-1)            # NaN

f3 <- \(x) {
  tryCatch(log(x),
    warning = \(s) {message("Warnung: ", s); NULL},
    error = \(s) {message("Fehler: ", s);  NA_real_},
    finally = {message("Ende")} )
}
x <- f3("a")      # Fehler, Ende
x                 # NA
x <- f3(-1)       # Warnung, Ende
x                 # NULL

f4 <- \(x) {
  tryCatch(log(x),
    error = \(s) {message("Fehler");  NA_real_} )
}
f4("a")           # NA, Fehler
f4(-1)            # NaN, Warnmeldung

f5 <- \(x) {
  tryCatch(withCallingHandlers(log(x),
    warning = \(s) {
      message("Warnung")
      invokeRestart("muffleWarning")} ),
    error = \(s) {message("Fehler");  NA_real_} )
}
f5("a")           # NA, Fehler
f5(-1)            # NaN, Warnung

f6 <- \() {
  stop("Abbruch") # erzeugt Fehler
  42
}
y <- f6()
#y                ## y nicht gefunden

f7 <- \() {
  warning("Achtung") # Warnung, Programm läuft weiter
  42
}
f7()              # 42, Warnmeldung

f8 <- \() {
  message("Info") # Informative Meldung
  42
}
f8()              # 42, Info

f9 <- \(x) { stopifnot(x >= 0); log(x) } # Beenden wenn nicht
f9(0)     # -Inf
f9(-1)    # Fehler in f9(-1) : x >= 0 ist nicht TRUE
\end{lstlisting}


\subsection{Fehlersuche und Debugging}

Mit \lstinline|traceback()| wird der Aufrufstack (die Kette von
Funktionen, die sich gegenseitig aufrufen) zum Zeitpunkt des Fehlers
angezeigt.

Mit \lstinline|debug(fun)| wird eine Funktion dauerhaft, mit
\lstinline|debugonce(fun)| nur beim nächsten Aufruf für interaktives
Debugging markiert.

Mit \lstinline|browser()| kann an beliebiger Stelle gezielt in den
Debugger gesprungen werden.

Im interaktiven Debugger stehen u.\,a. folgende Befehle zur Verfügung:

\begin{description}
  \item[\texttt{n\dots next}:] nächste Anweisung ausführen („step over“)
  \item[\texttt{s\dots step into}:] in den aufgerufenen Funktionsaufruf hineingehen
  \item[\texttt{f\dots finish}:] aktuelle Funktion bis zum Ende ausführen
  \item[\texttt{c\dots continue}:] weiterlaufen bis zum nächsten Breakpoint oder Ende
  \item[\texttt{Q\dots Quit}:] Debugger verlassen und Ausführung abbrechen
  \item[\texttt{where}:] aktuellen Call-Stack anzeigen (äquivalent zu \texttt{traceback()})
  \item[\texttt{beliebiger R-Ausdruck}:] wird direkt im aktuellen Environment ausgewertet, z.\,B. \lstinline|ls()|, \lstinline|x|, \lstinline|head(x)|
\end{description}

\begin{lstlisting}
f <- \(x) g(x)
g <- \(x) {
  h(x) }
h <- \(x) stop("Testfehler")
f(0)        # Fehler in h(x) : Testfehler
traceback() # 4: stop("Testfehler") at #1
            # 3: h(x) at #2; Callstack 3, h(x) in Zeile 2 von g
            # 2: g(x) at #1; Callstack 2, g(x) in Zeile 1 von f
            # 1: f(0)

trace("g", quote(browser()), at=2) # Fügt browser() in g ein
f(0)        # Geht jetzt in Debugging Modus => Interaktiv
body(g)     # Gibt funktion mit eingefügtem tracing code aus
untrace("g")

trace(sum)  # Zeigt an wenn Funktion sum aufgerufen wird
hist(rnorm(100)) # Wird 3-4 mal aufgerufen
untrace(sum)

debug(g)    # Debugging für Funktion g aktivieren
f(0)        # Interaktiv: Q, n, s, c, ... verwenden
undebug(g)  # Debugging wieder ausschalten

debugonce(g) # Debugging einmal aktivieren
f(0)

f <- \(x) {
  browser()   # Ausführung hier anhalten und in Debugger gehen
  x <- x + 1
  x * 2
}
f(0)        # Interaktiv: Q, n, s, c, ... verwenden
\end{lstlisting}



\subsection{Pipes}

Der native Pipe-Operator \lstinline!|>! ist reiner syntaktischer Zucker 
und \emph{keine} schrittweise Links-nach-Rechts-Ausführung. 

Ein Ausdruck wie \lstinline!x |> f() |> g() |> h()!
wird vor der Auswertung zu \lstinline|h(g(f(x)))| umgeschrieben 
und anschließend nach den üblichen R-Regeln ausgewertet
(insbesondere mit Lazy Evaluation der Funktionsargumente).

Jeder Pipe-Ausdruck lässt sich ersetzen durch:
\begin{itemize}
  \item verschachtelte Funktionsaufrufe: \lstinline!h(g(f(x)))! oder
  \item explizite Zwischenspeicherung:
\begin{lstlisting}
tmp <- f(x)
tmp <- g(tmp)
h(tmp)
\end{lstlisting}
\end{itemize}

Die Pipe ändert weder Semantik noch Auswertungsreihenfolge.
Sie bietet lediglich eine für manche
lesbarere Schreibweise verschachtelter Funktionsaufrufe.

\begin{lstlisting}
1:3 |> sum()           # 6
#1:3 |> sum            ## Error, braucht function call
sum(1:3)               # 6; Äquivalent
quote( 1:3 |> sum() )  # sum(1:3); Syntax transformation

. <- 1:3               # Zwischenwerte explizit speichern
sum(.)                 # 6

1:3 -> .               # Zwischenwerte explizit speichern
sum(.)                 # 6

1:3 ->.; sum(.)        # 6; Bizarro pipe

#1:3 |> `+`(4)         ## Error, nicht unterstützt
1:3 |> (`+`)(4)        # 5 6 7
1:3 |> base::`+`(4)    # 5 6 7
1:3 |>  `+`(4, e2 = _) # 5 6 7

1 |> seq(3)            # 1 2 3; Einfügen erster freier Platz
3 |> seq(from=1)       # 1 2 3
1 |> seq(to=3)         # 1 2 3

3 |> seq(1, to=_)      # 1 2 3; _ ... Platzhalter
#3 |> seq(1, _)        ## Error, _ braucht Namen
"b" |>  paste("a", . = _, "c") # "a b c"; Auch ... benötigt Name 
3 |> (\(.) seq(1, .))() # 1 2 3; Über Funktion
#3 |> rep(x=_, times=_)## Error, _ darf nur einmal vorkommen
3 |> (\(.) rep(., .))() # 3 3 3; Über Funktion

#1:3 |> sum(sqrt(x=_)) ## Error, _ nicht in nested calls
1:3 |> (\(.) sum(sqrt(x=.)))() # 4.146; Über Funktion
#1:3 |> sum(sqrt())    ## Error, kein Argument an sqrt
1:3  |> sum(sqrt(1))   # 7; sum(1:3, sqrt(1))

mtcars |> _$cyl        # 6 6 4 ...; Extraction call
mtcars |> _$cyl[3]     # 4

"x" |> assign(1)       # Kein zusätzliches Environment
x                      # 1
"x" |> (\(.) assign(., 2))() # Im Funktionsenvironment
x                      # 1

f1 <- \(x) { message("f1"); x }
f2 <- \(x) { message("f2"); x }
. <- 0
. <- f1(.)             # f1; Auswertung je Zeile
f2(.)                  # f2 0
0 |> f1() |> f2()      # f2 f1 0; Lazy evaluation
quote(0 |> f1() |> f2()) # f2(f1(0))
f2(f1(0))              # f2 f1 0
\end{lstlisting}



\iffalse

\begin{lstlisting}
q()                   # Beendet R (mit Rückfrage)
#                     # Kommentar bis Zeilenende
help()                # Hilfe starten
help(q)               # Hilfe zu Befehl q
?q                    # Hilfe zu Befehl q
#?for                 ## funktioniert nicht
?"for"                # Hilfe zur for-Schleife
#help(for)            ## erzeugt Fehler
help("for")           # Hilfe zur for-Schleife
??reg                 # Sucht nach "reg" in allen Hilfetexten
help.search("reg")    # Wie ??reg, aber als Funktion
help.start()          # Öffnet HTML-Hilfesystem
library(help = "stats")  # Hilfeübersicht zum Paket "stats"
args(lm)              # Argumente der Funktion lm
methods("plot")       # Methoden für generische Funktion plot
methods(class = "lm") # Methoden für Objekte der Klasse "lm"
getAnywhere("simpleLoess")#Zeigt auch nicht exportierte Funktion
example(lm)           # Führt Beispiele zu lm aus
demo()                # Zeigt verfügbare Demos
demo(lm)              # Demo zur linearen Regression

install.packages("lme4") # Installiert das Paket
update.packages()    # Aktualisiert Pakete
remove.packages()    # Entfernt Paket
installed.packages() # Zeigt alle installierten Pakete
library(lme4)        # Paket laden
require(lme4)        # Alternative, gibt bei Fehler FALSE zurück
search()             # Zeigt geladene Pakete und Umgebungen
vignette()           # Verfügbare Vignetten anzeigen
vignette("lmer")     # Einführung zu lmer öffnen

version              # R-Version anzeigen
sessionInfo()        # Infos zu Umgebung und geladenen Paketen
citation()           # Wie man R zitiert
x = 1                # Der Variablen x den Wert 1 zuweisen
x <- 1               # Der Variablen x den Wert 1 zuweisen
1 -> x               # Der Variablen x den Wert 1 zuweisen
assign("x", 1)       # Der Variablen x den Wert 1 zuweisen
x <<- 1              # Zuweisung in der Elternumgebung
str(x)               # Struktur von x
dput(x)              # Zeigt wie Objekt erzeugt werden kann
ls()                 # Liste Objekte im aktuellen Environment
rm(x)                # Objekt x entfernen
rm(list = ls())      # Alle Objekte entfernen (Workspace leeren)

getwd()              # Aktuelles Arbeitsverzeichnis anzeigen
setwd("D:/")         # Arbeitsverzeichnis setzen
source("file.R")     # R-Skript ausführen

x <- 1:3             # 1 2 3; Erzeugt eine Integer Sequenz
3:1                  # 3 2 1
seq(1, 3)            # 1 2 3; Erzeugt eine Integer Sequenz
seq(1, 6, 2)         # 1 3 5
seq(3, by=2, length.out=4) # 3 5 7 9
seq(0, by=3, along.with=x) # 0 3 6; so lange wie x
seq_along(x)         # 1 2 3
x <- integer(0)      # Vektor mit Länge 0
seq_along(x)         # integer(0)
n <- 3
seq_len(n)           # 1 2 3
n <- 0
seq_len(n)           # integer(0)
1:n                  # 1 0
rep(1:3, 2)          # 1 2 3 1 2 3; Objekt wiederholen
rep(1:3, each=2)     # 1 1 2 2 3 3
rep(1:3, 3:1)        # 1 1 1 2 2 3
1:4 + 1:2 + 1        # 3 5 5 7; Auto Wiederholung
1:4 + 1:3            # 2 4 6 5; Warnung Länge
1:3 + 1:4            # 2 4 6 5; Warnung Länge
\end{lstlisting}


\begin{lstlisting}
x <- c(2, 2, 1, 1, 3)
table(x)          # 1 2 3; Anzahlen
                  # 2 2 1
stem(x)           # stem-and-leaf plot
summary(x)        # Min. 1st Qu. Median Mean 3rd Qu. Max.
range(x)          # 1 3; kleinster und größter Wert
which.max(x)      # 5; Index des ersten größten Wertes
which.min(x)      # 3; Index des ersten kleinsten Wertes
rle(x)            # lengths: int [1:3] 2 2 1;Run Length Encoding
                  # values : num [1:3] 2 1 3
g <- c("A", "A", "C", "B", "B")
ave(x, g)         # Gruppenmittel für jedes Element
tapply(x, g, mean) # Mittel je Gruppe
s <- split(x, g)  # Teil x in Liste grupiert mit g
lapply(s, mean)   # Mittel je Gruppe
match(x, c(3,1,3))# NA NA  2  2  1; Position erster Treffer
x %in% 1:2        # TRUE  TRUE  TRUE  TRUE FALSE
findInterval(x, c(0,2)) # 2 2 1 1 2;
pmin(x, 2)        # 2 2 1 1 2
pmin(x, 0:4)      # 0 1 1 1 3
pmax(x, 0:4)      # 2 2 2 3 4

x <- c(1,2,3,4)
y <- c(3,4,5,6)
union(x, y)       # 1 2 3 4 5 6; Vereinigung
intersect(x, y)   # 3 4;         Schnittmenge
setdiff(x, y)     # 1 2; Elemente in x, aber nicht in y
setdiff(y, x)     # 5 6; Elemente in y, aber nicht in x
setequal(x, y)    # FALSE; # Mengen gleich?
setequal(x, 4:1)  # TRUE
\end{lstlisting}


%%% Einarbeiten %%%

\fi


\end{document}


