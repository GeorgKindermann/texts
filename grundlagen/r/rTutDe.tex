\documentclass[10pt,twocolumn]{scrartcl}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

\usepackage{textcomp}
\usepackage{newpxtext}
\usepackage{newpxmath}
\usepackage[scaled=0.75]{beramono}

\usepackage{xpatch}
\usepackage{xcolor}
\usepackage{realboxes}
\definecolor{mygray}{rgb}{0.9,0.9,0.9}

\usepackage{listings}
%\lstdefinelanguage{commentonly}{
%  morecomment=[l]{\#},
%  sensitive=true,
%}
\lstset{literate=%
{Ö}{{\"O}}1
{Ä}{{\"A}}1
{Ü}{{\"U}}1
{ß}{{\ss}}1
{ü}{{\"u}}1
{ä}{{\"a}}1
{ö}{{\"o}}1
{²}{{$^2$}}1
{├}{{|}}1
{─}{{-}}1
{└}{{L}}1
{│}{{|}}1
,basicstyle=\ttfamily%\small
,backgroundcolor=\color{mygray}
,commentstyle=\emph
%,language=commentonly
,language=R
,stringstyle=\emph %\color{red!50!black}
,upquote=true
,aboveskip=0pt
,belowskip=0pt
}
\makeatletter
\xpretocmd\lstinline
  {%
   \bgroup\fboxsep=1.5pt
   \Colorbox{mygray}\bgroup\kern-\fboxsep\vphantom{\ttfamily\char`\\y}%
   \appto\lst@DeInit{\kern-\fboxsep\egroup\egroup}%
  }{}{}
\makeatother

\usepackage{enumitem}
\setlist{nosep}

\usepackage{adjustbox}
\usepackage[a4paper, margin=1mm, includefoot, footskip=15pt]{geometry}

\usepackage[pdftitle={Grundlagen der Statistiksprache R}
, pdfauthor={Georg Kindermann}
, pdfsubject={R}
, pdfkeywords={R, Lang, Progammiersprache, Tutorial, Einführung, German,
               Deutsch}
, pdflang={de-AT-1996}
, colorlinks=true
, linkcolor=blue
, urlcolor=blue
, pdfpagemode=UseNone]{hyperref}

\nonfrenchspacing
\sloppy

\title{Grundlagen der Statistiksprache R}
\author{Georg Kindermann}
%\date{19. Juni 2023}

\begin{document}

\maketitle

%\begin{abstract}
%  Eine kurze Einführung in die Sprache Julia.
%\end{abstract}

\tableofcontents
\smallskip
%\hrule
\noindent
\href{https://www.r-project.org/}{R} kann vorkompiliert vom
\href{https://cran.r-project.org/}{CRAN} (The Comprehensive R Archive
Network) als \href{https://cran.r-project.org/bin/}{Binärdatei} für das
entsprechende Betriebssystem heruntergeladen werden. Alternativ kann
auch der \href{https://cran.r-project.org/src/base/R-4/}{Quellcode}
heruntergeladen werden und lokal kompiliert werden. Unter Linux
könnte dies so geschehen:

\begin{lstlisting}[language=sh]
wget https://cran.r-project.org/src/base/R-latest.tar.xz
mkdir R-latest
tar -xf R-latest.tar.xz -C R-latest --strip-components=1
cd R-latest
./configure --enable-memory-profiling
make
sudo make install
cd ..
#rm R-latest.tar.xz
#rm -r R-latest/
\end{lstlisting}

Nach dem Start kann R interaktiv verwendet werden. Alternativ lässt
sich R auch über verschiedene IDEs (integrierte Entwicklungsumgebung)
oder Texteditoren nutzen. Die gezeigten Codeabschnitte wurden mit R
Version 4.5.1 (2025-06-13) getestet.

Wenn man R startet, kommt man in den interaktiven Modus.
Deren wichtigste Tastenkombinationen sind:
\begin{description}[style=multiline,leftmargin=2cm,nolistsep]
  \item[CTRL+d] Beendet R (EOF) (Linux/Mac)
  \item[CTRL+z] Beendet R (EOF) (Windows)
  \item[CTRL+c] Bricht laufende Berechnungen oder Eingaben ab
  \item[CTRL+l] Löscht die Konsole (nur in manchen Umgebungen)
  \item[Pfeil ↑ / ↓] Navigiert im Befehlverlauf (History)
  \item[CTRL+r] Rückwärtssuche im Befehlverlauf
  \item[Tab] Auto-Vervollständigung
\end{description}

Beim Beenden von R besteht die Möglichkeit, den Arbeitsbereich (Workspace-Image) zu speichern. Dabei werden ausschließlich die Objekte im globalen Environment, also die im Arbeitsspeicher befindlichen R-Objekte, gesichert, nicht jedoch geladene Pakete. Die vorhandenen Objekte kann man mit \lstinline|ls()| oder \lstinline|objects()| auflisten. Wird R in einem Verzeichnis gestartet, in dem eine gespeicherte Arbeitsumgebung (Datei \lstinline|.RData|) vorhanden ist, wird diese beim Start automatisch geladen. So kann man die Arbeit, nach erneutem Laden der benötigten Pakete, an dem Punkt fortsetzen, an dem man aufgehört hat.

Den Arbeitsbereich kann man jederzeit mit \lstinline|save.image()| speichern. Dabei wird standardmäßig die Datei \lstinline|.RData| erstellt, die beim nächsten Start von R im selben Verzeichnis wieder geladen wird. Alternativ kann man auch einen Dateinamen angeben, z.\,B.\ \lstinline|save.image("WSI.RData")| bzw.\ \lstinline|save.image(file = "WSI.RData")|. Diese Datei kann später mit \lstinline|load("WSI.RData")| bzw.\ \lstinline|load(file = "WSI.RData")| geladen werden. Dabei werden existierende Objekte mit gleichem Namen im aktuellen Environment überschrieben.

Für reproduzierbare Analysen empfiehlt sich der Start von R mit der Option \lstinline|--vanilla| (\lstinline|R --vanilla|). In diesem Fall werden weder Konfigurationsdateien (\lstinline|.Rprofile|, \lstinline|.Renviron| etc.) noch ein gespeichertes Workspace-Image geladen, und beim Beenden wird kein neues gespeichert.

Befehle, die in einer Datei gespeichert sind, lassen sich mit \lstinline|R -f FILE| ausführen. Ein einzelner Ausdruck kann mit \lstinline|R -e EXPR| ausgeführt werden, wobei R danach sofort beendet wird, z.,B.\ \lstinline|R -e "summary(iris)"|. In beiden Fällen wird der Arbeitsbereich beim Beenden standardmäßig nicht gespeichert. Möchte man ihn speichern, muss dies mit der Option \lstinline|--save| explizit angegeben werden, z.,B.\ \lstinline|R --save -f FILE| oder \lstinline|R --save -e "x=5"|.

Bei Verwendung von \lstinline|R -f FILE| oder \lstinline|R -e EXPR| werden standardmäßig ebenfalls Konfigurationsdateien sowie ein eventuell vorhandenes Workspace-Image geladen. Wie bereits beschrieben, kann dies durch \lstinline|--vanilla| unterdrückt werden (\lstinline|R --vanilla -f FILE|, \lstinline|R --vanilla -e EXPR|).


Einige wichtige Funktionen:

\begin{lstlisting}
q()                   # Beendet R (mit Rückfrage)
#                     # Kommentar bis Zeilenende
help()                # Hilfe starten
help(q)               # Hilfe zu Befehl q
?q                    # Hilfe zu Befehl q
#?for                 ## funktioniert nicht
?"for"                # Hilfe zur for-Schleife
#help(for)            ## erzeugt Fehler
help("for")           # Hilfe zur for-Schleife
??reg                 # Sucht nach "reg" in allen Hilfetexten
help.search("reg")    # Wie ??reg, aber als Funktion
help.start()          # Öffnet HTML-Hilfesystem
library(help = "stats")  # Hilfeübersicht zum Paket "stats"
args(lm)              # Argumente der Funktion lm
methods("plot")       # Methoden für generische Funktion plot
methods(class = "lm") # Methoden für Objekte der Klasse "lm"
getAnywhere("simpleLoess")#Zeigt auch nicht exportierte Funktion
example(lm)           # Führt Beispiele zu lm aus
demo()                # Zeigt verfügbare Demos
demo(lm)              # Demo zur linearen Regression

install.packages("lme4") # Installiert das Paket
update.packages()    # Aktualisiert Pakete
remove.packages()    # Entfernt Paket
installed.packages() # Zeigt alle installierten Pakete
library(lme4)        # Paket laden
require(lme4)        # Alternative, gibt bei Fehler FALSE zurück
search()             # Zeigt geladene Pakete und Umgebungen
vignette()           # Verfügbare Vignetten anzeigen
vignette("lmer")     # Einführung zu lmer öffnen

version              # R-Version anzeigen
sessionInfo()        # Infos zu Umgebung und geladenen Paketen
x = 1                # Der Variablen x den Wert 1 zuweisen
x <- 1               # Der Variablen x den Wert 1 zuweisen
1 -> x               # Der Variablen x den Wert 1 zuweisen
x <<- 1              # Zuweisung in der Elternumgebung
str(x)               # Struktur von x
dput(x)              # Zeigt wie Objekt erzeugt werden kann
assign("x", 1)       # Der Variablen x den Wert 1 zuweisen
ls()                 # Liste Objekte im aktuellen Environment
rm(x)                # Objekt x entfernen
rm(list = ls())      # Alle Objekte entfernen (Workspace leeren)

getwd()              # Aktuelles Arbeitsverzeichnis anzeigen
setwd("D:/")         # Arbeitsverzeichnis setzen
source("file.R")     # R-Skript ausführen

x <- 1:3             # 1 2 3; Erzeugt eine Integer Sequenz
3:1                  # 3 2 1
seq(1, 3)            # 1 2 3; Erzeugt eine Integer Sequenz
seq(1, 6, 2)         # 1 3 5
seq(3, by=2, length.out=4) # 3 5 7 9
seq(0, by=3, along.with=x) # 0 3 6; so lange wie x
seq_along(x)         # 1 2 3
x <- integer(0)      # Vektor mit Länge 0
seq_along(x)         # integer(0)
n <- 3
seq_len(n)           # 1 2 3
n <- 0
seq_len(n)           # integer(0)
1:n                  # 1 0
rep(1:3, 2)          # 1 2 3 1 2 3
rep(1:3, each=2)     # 1 1 2 2 3 3
\end{lstlisting}


\section{Grundtypen}

Mit \lstinline|typeof(x)| kann der Typ von \lstinline|x| in R bestimmt werden.
R verwendet dynamische Typisierung, d.\,h. der Typ wird zur Laufzeit zugewiesen.
R kennt keinen eigenen Zeichentyp (char); einzelne Zeichen werden als Zeichenketten (Strings) der Länge 1 behandelt.

\begin{lstlisting}[language=R]
1              # Double
1L             # Integer (standardmäßig 32 Bit)
1.0            # Double
0x2a           # 42, Double (hexadezimal)
0x2aL          # 42, Integer (hexadezimal)
TRUE           # Boolean
FALSE          # Boolean
'abc'          # String
"abc"          # String
as.raw(97)     # Raw (Byte)
as.raw(0x61)   # Raw
charToRaw("a") # 61; Raw
\end{lstlisting}

Mit \lstinline|as.T(x)| wird ein Wert \lstinline|x| in den Typ \lstinline|T| konvertiert. R prüft dabei nicht streng auf Genauigkeit, sondern führt die Konvertierung stillschweigend durch.

\begin{lstlisting}[language=R]
as.integer(1)     # Wandelt Double in Integer
as.integer(1.0)   # Wandelt Double in Integer
as.integer(1.8)   # wird abgeschnitten => 1
floor(1.3)        # Abrunden  => 1 Double
ceiling(1.3)      # Aufrunden => 2 Double
round(1.3)        # Runden    => 1 Double
\end{lstlisting}

R kennt spezielle Werte für fehlende, ungültige oder unendliche Zahlen. Sie sind typabhängig und verhalten sich in Berechnungen wie reguläre Werte ihres jeweiligen Typs.

\begin{lstlisting}[language=R]
NA                        # Fehlender Wert vom Typ logical
NA_integer_               # Integer NA
NA_real_                  # Double NA
NA_character_             # Character NA
is.na(1)                  # FALSE
is.na(NA)                 # TRUE

typeof(1L + NA)           # integer
typeof(1L + NA_real_)     # double

NaN                       # Not a Number (z.B. 0/0)
Inf                       # Unendlich (z.B. 1/0)
-Inf                      # Negativ unendlich (z.B. -1/0)
\end{lstlisting}

R unterstützt auch komplexe Zahlen. Zur exakten Berechnung mit sehr großen Zahlen oder Brüchen lassen sich externe Pakete wie \texttt{gmp} (ganze und rationale Zahlen) oder \texttt{Rmpfr} (Gleitkommazahlen) verwenden.

\begin{lstlisting}
-4+0i                            # Komplexe Zahl
#sqrt(-4)                        ## NaN; Warnung
sqrt(-4+0i)                      # 0+2i

2147483647L                      # Größte Integerzahl
2147483647L + 1L                 # NA; Ganzzahlüberlauf
2147483648L                      # Warnung Umwandlung in Double
as.character(2^53)               # 9007199254740992
as.character(2^53 - 1)           # 9007199254740991
as.character(2^53 + 1)           # 9007199254740992 !
as.character(2^53 + 2)           # 9007199254740994

library(gmp)
as.bigz("2147483648")            #  2147483648 als Ganzzahl
#as.bigz(9007199254740993)       ## 9007199254740992
as.bigz("9007199254740993")      #  9007199254740993

as.bigq(1L, 3L)                  #  exakter Bruch 1/3
as.bigq(2L, 4L)   # 1 / 2
as.bigq(0.5, 1)   # 1 / 2

library(Rmpfr)
mpfr("9007199254740992.5", 55L)  # 9007199254740992.5
mpfr("9007199254740992.75", 55L) # 9007199254740993
mpfr("9007199254740992.75", 56L) # 9007199254740992.75

format(1/3, digits=20)           # 0.33333333333333331483
mpfr(as.bigq(1L, 3L), 64)        # 0.333333333333333333342
\end{lstlisting}

\subsection{Vector}

Ein Vektor ist eindimensional, enthält Elemente des gleichen Typs und kann beliebig lang sein. Mit \lstinline|c| werden mehrere Werte zu einem Vektor oder einer Liste zusammengefügt.

\begin{lstlisting}[language=R]
1                 # numerischer Vektor mit Länge 1
c(1, 2, 3)        # numerischer Vektor mit Länge 3
c("a", "b", "c")  # Zeichen-Vektor (String)
c(1, 2, "x")      # Zahlen werden in String umgewandelt

x = c(a=1, "b b"=2, a=3)   # Elemente bekommen einen Namen
names(x)                   # "a" "b b" "a"
x["a"]                     # 1; gibt ersten Treffer zurück
make.names(names(x), TRUE) # "a" "b.b" "a.1"
make.unique(names(x))      # "a" "b b" "a.1"
length(x)                  # 3
x[3]                       # 3; Inhalt drittes Element
x[4]                       # NA

vector("integer", 3)       # 0 0 0; Erzeugt int Vektor
integer(3)                 # 0 0 0; Erzeugt int Vektor

x <- Matrix::sparseVector(c(3,5,7), c(1,10,90), 100)
# Erzeugt wenig besetzten Vektor
x[1]                       # 3
x[2]                       # .
x[101]                     # NA
\end{lstlisting}

\subsection{Matrix, Array}

Array ist eine ein bis mehrdimensionale Strukturen die Elemente des gleichen Typs enthält. Eine Matrix ist ein zweidimensionales Array.

Operationen sind meist schneller, wenn sie der Anordnung der Elemente im Speicher folgen. In R werden Matrizen und mehrdimensionale Arrays spaltenweise (d.\,h.\ in der Reihenfolge der ersten Dimension) im Speicher abgelegt, weshalb spaltenorientierte Berechnungen meist effizienter sind als zeilenorientierte.

\begin{lstlisting}[language=R]
array(1:3, dim=3)                # 1D-Array
x <- matrix(1:6, nrow=2, ncol=3) # 2x3 Matrix
matrix(1:6, 2, 3, byrow=TRUE)    # Füllt zeilenweise
rownames(x)                      # Zeilennamen
colnames(x)                      # Spaltennamen
length(x)                        # 6
nrow(x)                          # 2
ncol(x)                          # 2
a <- array(1:8, dim=c(2,2,2))    # 3D-Array 2x2x2
dimnames(a)                      # Dimensionsnamen
dim(a)                           # 2 2 2
is.matrix(a)                     # FALSE
is.array(a)                      # TRUE

x <- Matrix::sparseMatrix(c(1,100), c(1,100), x=c(2,3),
                          dims=c(100,100))
# Erzeugt wenig besetzte Matrix
x[1,1]                           # 2
x[5,5]                           # 0
\end{lstlisting}

\subsection{List}

Eine Liste ist ein Vektor für Objekte beliebiger Typen und Längen.

\begin{lstlisting}[language=R]
list(1, "a", TRUE, c(1,2))  # Liste mit verschiedenen Typen
c("a", list(2, 3))          # c fügt Listen zusammen
vector("list", 3)           # Erzeugt Lite mit 3 Elementen
\end{lstlisting}

\subsection{Data.frame}

Ein data.frame ist eine tabellarische Datenstruktur in R, die als Liste gleich langer Spalten organisiert ist. Die Spalten sind in der Regel Vektoren, können aber auch komplexere Objekte enthalten, solange alle Spalten die gleiche Länge haben.

\begin{lstlisting}[language=R]
x = data.frame(Name=c("Anna", "Max"), Alter=c(25, 30))
x$l = list(3:2, "a")                   # list als Spalte
x$m = matrix(1:6, 2)                   # matrix als Spalte
x$d = data.frame(a=c("c", "d"), b=2:1) # data.frame als Spalte
names(x)                               # Spaltennamen
length(x)                              # Anzahl Spalten
ncol(x)                                # Anzahl Spalten
nrow(x)                                # Anzahl Zeilen
row.names(x)                           # Zeilennamen
head(x)                                # Anfang
tail(x)                                # Ende
summary(x)                             # Datenüberblick
str(x)                                 # Daten Struktur
\end{lstlisting}

\subsection{Factor}

Ein factor repräsentiert kategoriale Daten. Intern werden diese als Ganzzahlen mit zugehörigen Namen (Levels) gespeichert.

\begin{lstlisting}[language=R]
f <- factor(c("rot", "blau", "rot")) # Faktor erstellen
levels(f)        # "blau" "rot"
nlevels(f)       # 2
unclass(f)       # 2 1 2; interne Ganzzahl-Repräsentation

# Geordneter Faktor (ordinal)
f <- ordered(c("wenig", "mittel", "viel"),
             levels = c("wenig", "mittel", "viel"))

# Faktor mit systematisch generierten Levels
gl(3, 2)  # 1 1 2 2 3 3; erzeugt Faktor mit 3 Levels
\end{lstlisting}

\subsection{Datum und Zeit}

R kennt mehrere Klassen für Zeitangaben:
\lstinline|Date| für reine Datumsangaben sowie
\lstinline|POSIXct| und \lstinline|POSIXlt| für kombinierte Datums- und Zeitangaben.
Zeitdifferenzen werden mit \lstinline|difftime| dargestellt.

\begin{lstlisting}[language=R]
Sys.Date()                # "2025-10-24"; Aktuelles Datum
as.Date("2025-10-24")     # Standardformat: "%Y-%m-%d"
as.Date("24.10.2025", format = "%d.%m.%Y")
  
Sys.time()                # "2025-10-24 08:16:44 CEST"
Sys.timezone()            # "Europe/Vienna"; Lokale Zeitzone
ct <- as.POSIXct("2025-10-24 08:16:44")
# "2025-10-24 08:16:44 CEST"
as.POSIXct("2025-10-24 08:16:44", "UTC")
# "2025-10-24 08:16:44 UTC"
ISOdatetime(2025, 10, 24, 8, 16, 44)
# "2025-10-24 08:16:44 CEST"
ISOdate(2025, 10, 24)
# "2025-10-24 12:00:00 GMT"
unclass(ct)               # 1761286604; Sekunden seit 1970-01-01
lt <- as.POSIXlt("2025-10-24 08:16:44") #Liste mit Jahr, Monat..
lt$hour                   # 8

as.Date("2024-3-1") - as.Date("2024-2-1") # 29 days
a <- ISOdate(2025, 10, 1, 8, 0, 0)
e <- ISOdate(2025, 10, 1, 9, 10, 30)
e - a                                     # 1.175 hours
difftime(e, a, units = "mins")            # 70.5 mins

seq(as.Date("2025-10-01"), as.Date("2025-10-25"), "1 week")
# "2025-10-01" "2025-10-08" "2025-10-15" "2025-10-22"
seq(as.Date("1582-10-4"), as.Date("1582-10-15"), "1 day") # !
# "1582-10-04" "1582-10-05", ..., "1582-10-14" "1582-10-15"

.leap.seconds  # Zeigt Schaltsekunden
seq(ISOdate(2016,12,31,23,59,59), by="1 sec", length.out = 3)
# "2016-12-31 23:59:59 GMT" "2017-01-01 00:00:00 GMT"
# "2017-01-01 00:00:01 GMT"
ISOdate(2016, 12, 31, 23, 59, 60)   #  "2017-01-01 GMT"
as.POSIXlt("2016-12-31 23:59:60", tz = "UTC")
# "2016-12-31 23:59:60 UTC"
\end{lstlisting}

\subsection{NULL}

\lstinline|NULL| repräsentiert ein Objekt ohne Wert oder Inhalt. 
Es ist ein spezieller Typ, der häufig für leere Rückgaben, Platzhalter oder gelöschte Einträge verwendet wird.
Vektoren können \lstinline|NULL| nicht enthalten, da alle Elemente eines Vektors denselben Typ besitzen müssen.

\begin{lstlisting}[language=R]
x <- NULL
is.null(x)            # TRUE
length(x)             # 0

x <- c(1, NULL, 3, 4) # 1 3 4; NULL Verschwindet
#x[2] <- NULL         ## Fehler
x[2] <- list(NULL)    # Wandelt Vector a in Liste um

x <- list(1, NULL, 3) # [[1]] 1  [[2]] NULL  [[3]] 3
x[[3]] <- NULL        # Löscht drittes Element
x[2] <- NULL          # Löscht zweites Element
x[1] <- list(NULL)    # Fügt NULL ein

x <- data.frame(a=1:2, b=3:4)
x$c <- list(NULL, 2)  # Fügt neue Liste ein
x$b <- NULL           # Löscht Spalte b
\end{lstlisting}

\subsection{Funktionen und Closure}

In R sind Funktionen sogenannte Closures: Objekte, die aus einem Funktionskörper und einem enclosing environment bestehen.
Variablen, die nicht als Funktionsargumente übergeben werden, sucht R zuerst im enclosing environment der Funktion und dann in den übergeordneten Environments.
Im Environment können Variablen gespeichert werden.
Bei Funktionen wird der letzte Ausdruck zurückgegeben.
Zusätzlich gibt es noch \lstinline|return|.

\begin{lstlisting}[language=R]
f <- function(x) x+1
f(3)           # 4

f2 <- \() {x}
#f2()          ## Fehler, x nicht gefunden
x <- 1
f2()           # 1; greift jetzt auf globales x zu

f3 <- \() {x <- 2; x}
f3()           # 2; greift auf lokales x zu

f4 <- local(\() x)
f4()           # 1; greift auf globales x zu
environment(f4)$x <- 4
f4()           # 4; greift auf lokales x zu
x              # 1

f5 <- local({n=0L; \() {n <<- n+1L; n}})
f5()           # 1
f5()           # 2
environment(f5)$n <- 8
f5()           # 9

f6 <- (\(n){\() {n <<- n+1L; n}})(7L)
f6()           # 8
f6()           # 9
ls(environment(f6))      # n
as.list(environment(f6)) # n 9

f7 <- \() {x <<- 2; invisible()}
f7()           # Gibt nichts in der Konsole aus
\end{lstlisting}

\lstinline|local()| erzeugt ein Environment, in dem Objekte (z. B. Zähler oder Parameter) dauerhaft für die zurückgegebene Funktion gebunden bleiben.

\subsection{Environment (Umgebung)}

Eine Datenstruktur, die Namen (Variablen) mit Werten (Objekten) verknüpft.
Environments bilden eine hierarchische Kette, in der jedes Environment auf ein Eltern-Environment verweist, 
an deren Ende das leere Environment (\lstinline|emptyenv()|) steht.
Bei der Namenssuche geht R schrittweise entlang dieser Kette nach oben.
Innerhalb eines Environments kann die Namenssuche mittels Hash-Lookup erfolgen.
Mit Environments wird bestimmt, wo Variablen beim Auswerten von Funktionen gesucht werden.

Abweichend davon kann man auch im dynamischen Aufrufer-Environment suchen, z.B. mit \lstinline|dynGet|. Beim Einsatz von dynGet in verschachtelten Funktionsaufrufen können Konflikte mit der Lazy Evaluation (Promises) entstehen. Alternativ können Variablen als Funktionsargument übergeben werden, was ich empfehle, da dies explizit, robust und leicht nachvollziehbar ist.

\lstinline|<<-| sucht in den Eltern-Environments nach einer bestehenden Bindung und ändert deren Wert. Existiert keine Bindung, wird sie im nächsthöheren Environment erzeugt.

Im Gegensatz zu einer Liste ist ein Environment referenzbasiert (kein copy-on-modify), 
besitzt keine feste Ordnung seiner Elemente und verfügt stets über ein Eltern-Environment.

\begin{lstlisting}[language=R]
e1 <- new.env()
e1$a <- 1
e2 <- e1      # e2 zeigt auf e1
e2$a <- 2     #  ohne copy on modify
e1$a          # 2
e1[["a"]]     # 2

x <- list(a = 1)
y <- x        # y zeigt auf x
y$a <- 2      #  mit copy on modify
x$a           # 1

e1 <- new.env()
e1$x <- 1
e2 <- new.env(parent = e1)
e2$f1 <- \() x            # enclosing environment: GlobalEnv
environment(e2$f1)        # R_GlobalEnv
#e2$f1()                  ## Fehler, 'x' nicht gefunden
environment(e2$f1) <- e2  # setzt e2 als enclosing environment
e2$f1()                   # 1
e2$f2 <- with(e2, \() x)  # enclosing environment: e2
e2$f2()                   # 1
e2$x                      # NULL; keine Suche im Parent
get("x", envir = e2)      # 1; Suche im Parent
#get("x", envir = e2, inherits = FALSE) ## Fehler

x <- 1
f1 <- \() x <- 2
f1()          # f1 verändert sein lokales x
x             # 1
f2 <- \() x <<- 2
f2()          # f2 verändert Eltern x
x             # 2
#z            ## Fehler 'z' nicht gefunden
f3 <- \() z <<- 3
environment(f3) # R_GlobalEnv
f3()          # f3 legt z im Eltern-Environment an
z             # 3

x <- -1
f1 <- \() {x <- 1; f3(x)}
f2 <- \() {x <- 2; f3(x)}
f3 <- \(y=3) f4(y)
f4 <- \(y=4) list(y,
  x,                     # Suche im enclosing environment
  dynGet("x", 0),        # Suche im Aufruf-Stack
# Suche im Aufruf-Stack mit Vererbung
  dynGet("x", 0, inherits = TRUE),
  get0("x", envir = parent.frame()), # Suche im Aufrufer-Frame
# Suche nur im Parent-Frame
  get0("x", envir = parent.frame(), inherits = FALSE)
)
f1()                     #  1, -1, 1, -1, -1, NULL
f2()                     #  2, -1, 2, -1, -1, NULL
f3()                     #  3, -1, 0, -1, -1, NULL
f4(x)                    # -1, -1, 0, -1, -1, -1
f4()                     #  4, -1, 0, -1, -1, -1
with(list(x = 5), f4(x)) #  5, -1, 5, -1,  5,  5
#dput(f3()) ## Fehler rekursive Referenz
\end{lstlisting}


\section{Subsetting (Teilmengen)}

In R werden Elemente von Datenstrukturen mit Hilfe von Subsetting ausgewählt. Die gebräuchlichsten Subsetting-Operatoren sind \lstinline|[ ]|, \lstinline|[[ ]]| und \lstinline|$|. Subsetting kann mit numerischen Indizes, logischen Vektoren oder Namen erfolgen.

\lstinline|[ ]| gibt immer ein Objekt des gleichen Typs zurück (z.\,B. Liste, data.frame), sofern \lstinline|drop=FALSE| gesetzt ist, \lstinline|[[ ]]| extrahiert ein einzelnes Element.

\begin{lstlisting}[language=R]
v <- c(a=10, b=20, c=30, d=40, e=50)
v[2]             # 20; Element an Position 2
v[[2]]           # 20
v[1:3]           # 10 20 30; Element 1 bis 3
v[3:1]           # 30 20 10; Element 3 bis 1
v[c(1,3,5)]      # 10 30 50; Mehrere Elemente
v[-c(2,4)]       # 10 30 50; Alle außer Position 2 und 4: 
v["c"]           # 30; Über Namen
#v$c             ## Fehler
v[6]             # NA
#v[[6]]          ## Fehler, Indizierung außerhalb
v[c(TRUE,FALSE,TRUE,FALSE,TRUE)] # 10 30 50; Logisch
v[c(TRUE,FALSE)] # 10 30 50; Wird automatisch wiederholt
v[v>30]          # 40 50; Logisch
v[!v>30]         # 10 20 30; ! (not)
v[which(v>30)]   # 40 50; Über Position
v[-which(v>30)]  # 10 20 30
v[-which(v>50)]  # Nichts!
v                # Ganzer Vektor
v[]              # Ganzer Vektor
v[0]             # Nichts
v[-0]            # Nichts
v[NULL]          # Nichts
v[integer(0)]    # Nichts

m <- matrix(1:6, 2, dimnames=list(c("a","b")))
m[2, 3]         # 6; Zeile 2, Spalte 3
m[[2, 3]]       # 6
#m[[c(3, 2)]]   ## Fehler
#m[1, 4]        ## Fehler, Indizierung außerhalb
#m[[1, 4]]      ## Fehler, Indizierung außerhalb
m[1, ]          # 1 3 5; Vektor, Ganze 1. Zeile
#m[[1, ]]       ##Fehler,  missing subscript
m["a", ]        # 1 3 5; Vektor, Zeile a
m[1, , drop=FALSE]  # 1 3 5; Matrix
m[, 2]          # 3 4; Ganze Spalte 2
m[-1, -3]       # Ohne Zeile 1 und Spalte 3
m[2, 2:3]       # Zeile 2, Spalte 2 bis 3
m[4]            # 4; Kann wie Vektor verwendet werden
m[[4]]          # 4
m[7]            # NA
#m[[7]]         ## Fehler, Indizierung außerhalb
m[m>3]          # 4 5 6
a <- array(1:8, dim=c(2,2,2))
a[ , , 1]       # Erste Schicht

l <- list(a=1, b=c(a=2,b=3,c=4), c="Hallo")
l[2]            # 2 3 4; Liste mit zweitem Element
l[[2]]          # 2 3 4; Zweites Element
l[[2]][[1]]     # 2; Zweites Element, erster Eintrag
l[[c(2, 1)]]    # 2; Zweites Element, erster Eintrag
l[[c("b", "a")]]# 2; Element b, Eintrag a
#l[[1,2]]       ## Fehler, falsche Anzahl Subscripts
l$b             # 2 3 4; Element b
l["b"]          # 2 3 4; Liste mit Element b
l[["b"]]        # 2 3 4; Element b
l[1:2]          # Liste mit Element 1 und 2
l[c("a","c")]   # Liste mit Element a und c
l[-2]           # Liste ohne zweites Element
l[c(TRUE, FALSE)] # Liste jedes zweites Element
l[4]            # NULL
#l[[4]]         ## Fehler, Indizierung außerhalb
l <- list(x = 1, y = list(z = 2, w = 3))
l$y$z           # 2; verschachtelter Zugriff

d <- data.frame(a=c("d","e"), b=2:1)
d[1, ]          # d 2; data.frame, Erste Zeile
d[, 2]          # 2 1; Vektor, Zweite Spalte
d[[2]]          # 2 1; Vektor, Zweite Spalte
d[2]            # 2 1; data.frame, Zweite Spalte
d[, 2, drop=FALSE] # 2 1; data.frame, Zweite Spalte
d[, "b"]        # 2 1; Vektor
d$b             # 2 1; Vektor
d$b[1]          # 2; Erstes Element von Spalte b
d[1, "b"]       # 2; Erstes Element von Spalte b
d[1, 2]         # 2; Erstes Element von Spalte 2
d[[2]][1]       # 2; Erstes Element von Spalte 2
d[[2]][[1]]     # 2; Erstes Element von Spalte 2
d[[1, 2]]       # 2; Erstes Element von Spalte 2
d[[c(2, 1)]]    # 2; Erstes Element von Spalte 2
d[[1, "b"]]     # 2; Erstes Element von Spalte b
d[-1, ]         # data.frame ohne erste Zeile
d[, -1]         # Da nur eine Spalte => Vektor
d[, 1:2]        # Spalten 1 bis 2
d[c(TRUE, FALSE),] # Jede zweite Zeile
d[0]            # data.frame mit 0 Spalten
d[0,]           # data.frame mit 0 Zeilen
d[d$a == "d", ] # Zeilen, bei denen a == "d"
d[d$b > 1, "a"] # Spalte a, Zeilen mit b > 1
d[d$a == "d" & d$b > 1, ] # d 2
#d[3]           ## Fehler, nicht definierte Spalte
#d[[3]]         ## Fehler, Indizierung außerhalb
d$b[3]          # NA

e <- new.env()
e$a <- 1
assign("b", 2, envir = e)
e$a                  # 1
e$b                  # 2
e[["a"]]             # 1
#e[[1]]              ## Fehler
#e["a"]              ## Fehler
e[["c"]]             # NULL
get("a", envir = e)  # 1; Sucht auch in Parrent
rm(b, envir = e)     # Löscht Element b
ls(e)                # "a"; Listet Elemente von e
\end{lstlisting}

\section{Datenmanipulation}

\subsection{Operatoren}

Dieses Beispiel zeigt die wichtigsten arithmetischen, Vergleichs- und
logischen Operatoren.

\begin{lstlisting}
x <- 1:3
y <- c(2, 4, 6)
x + y     # 3 6 9; Elementweise Addition
x - y     # -1 -2 -3; Subtraktion
x * y     # 2 8 18; Multiplikation
y / x     # 2 2 2; Division
x^2       # 1 4 9; Potenzierung
x %% 2    # 1 0 1; Rest der Division (Modulo)
x %/% 2   # 0 1 1; Ganzzahldivision
1 + 2 * 3    # 7; Multiplikation vor Addition
(1 + 2) * 3  # 9; Klammern ändern Reihenfolge

x < 2           # TRUE  FALSE FALSE
x > 2           # FALSE FALSE TRUE
x <= 2          # TRUE  TRUE  FALSE
x >= 2          # FALSE TRUE  TRUE
x == 2          # FALSE TRUE  FALSE
x != 2          # TRUE  FALSE TRUE
x > 1 & x < 3   # FALSE TRUE  FALSE; UND (elementweise)
x > 1 | x < 3   # TRUE  TRUE  TRUE;  ODER (elementweise)
xor(x>1, x<3)   # TRUE  FALSE TRUE
!(x > 1)        # TRUE  FALSE FALSE; Negation

FALSE && TRUE          # FALSE
TRUE  || FALSE         # TRUE
l <- TRUE
FALSE && (l <- FALSE)  # Auswertung bis Ergebnis klar
l                      # TRUE
TRUE && (l <- FALSE)
l                      # FALSE
NA && TRUE             # NA
NA || TRUE             # TRUE

sum(x > 1)        # 2; Anzahl der Elemente > 1
any(x > 2)        # TRUE; Mindestens ein TRUE?
all(x > 0)        # TRUE; Alle TRUE?
which(x > 1)      # 2 3

1 == 1L           # TRUE
identical(1, 1L)  # FALSE; Typ unterschiedlich
\end{lstlisting}

\subsection{String}

Das folgende Beispiel zeigt typische Operationen zur Verarbeitung von
Zeichenketten in R, einschließlich Zählen, Suchen, Ersetzen, Aufteilen
und Vergleichen von Strings.

\begin{lstlisting}
s <- c("Mehr", "Licht")
nchar(s)                  # 4 5; Anzahl Zeichen
nchar(c("a", "ä"), "bytes") # 1 2
nzchar(s)                 # TRUE TRUE; Länge > 0
toupper(s)                # "MEHR" "LICHT"
tolower(s)                # "mehr" "licht"
chartr("hi", "Xy", s)     # "MeXr" "LycXt"; Zeichen austauschen

grepl("c.", s)            # FALSE TRUE ; enthält Regex "c."
grepl("c.", s, fixed=TRUE)# FALSE FALSE; enthält "c."
grep("ch", s)             # 2; Index des Treffers
grep("ch", s, value=TRUE) # "Licht"

agrep("Meer", s)          # 1; Ungefähre Treffer
adist("Meer", s)          # 1 5; String Abstände

i <- regexpr("[eih]", s)  # Erster Treffer von e, i, oder h
regmatches(s, i)          # "e" "i"; Treffer Ausgeben
i <- gregexpr("[eih]", s) # Alle Treffer von e, i, oder h
regmatches(s, i)          # "e" "h", "i" "h"
s1 <- lapply(regmatches(s, i), \(x) paste0("<", x, ">"))
regmatches(s, i) <- s1    # Treffer überschreiben
s                         # "M<e><h>r"  "L<i>c<h>t"

s <- c("abcd", "dcba")    # Mehrere ersetzen
r <- c(ef="a", gh="c")    # a=>ef, c=>gh
i <- gregexpr(paste(r, collapse="|"), s)
s1 <- lapply(regmatches(s, i), \(x) names(r)[match(x, r)])
regmatches(s, i) <- s1
s                         # "efbghd" "dghbef"

sub("a", "xz", "aba")     # "xzba"; erstes Vorkommen ersetzen
gsub("a", "xz", "aba")    # "xzbxz"; alle ersetzen
gsub("([ac])", "<\\1>", "abc") # "<a>b<c>"; Treffer verwenden
gsub("\\s+", " ", "a  b") # "a b"; Mehrfachleerzeichen=> " "
trimws("  Text  ")        # "Text"; Umgebende " " entfernen

s <- c("Mehr", "Licht")
toString(s)               # "Mehr, Licht";Fügt mit ", " zusammen
s <- paste(s[1], s[2])    # "Mehr Licht"; Fügt mit " " zusammen
strsplit(s, " ", TRUE)    # Liste: "Mehr" "Licht"; Trennt String
paste(c("A","B","C"), collapse=", ") # "A, B, C"
paste("A", 1:3, sep="-")  # "A-1" "A-2" "A-3"
paste0("A", 1:3)          # "A1" "A2" "A3"
sprintf("Pi: %0.2f", pi)  # "Pi: 3.14"; formatiertes Einfügen

substr(s, 1, 4)           # "Mehr"; Teilstring
substr(s, 1, 4) <- "Weniger"  # "Weni Licht"; Nur Teil ersetzt !
strtrim(s, 3)             # "Wen"; auf Länge 3 kürzen

startsWith(s, "Wen")      # TRUE; beginnt mit "Wen"
endsWith(s, "ht")         # TRUE; endet mit "ht"

charToRaw("ä")            # c3 a4; Bytes anzeigen
s <- "\u00e4"             # "ä"
iconv("Müller", "UTF-8", "latin1")  # Encoding ändern
utf8ToInt("ä")            # 228
intToUtf8(228)            # "ä"

s <- noquote(c("Ab", "C"))# Ausgabe ohne Anführungszeichen
s                         # Ab C

s <- c("Ab", NA, "C")
paste("x", s, sep="-")   # "x-Ab" "x-NA" "x-C"; NA wird String !

s <- c("ä", "a", "b")
Sys.setlocale("LC_COLLATE", "C")  # ASCII-Reihenfolge
sort(s)                  # "a" "b" "ä"
"ä" < "z"                # FALSE
Sys.setlocale("LC_COLLATE", "de_AT.UTF-8")
sort(s)                  # "a" "ä" "b"
"ä" < "z"                # TRUE
\end{lstlisting}

\subsection{Factor}

Faktoren werden zur Darstellung kategorialer Daten verwendet.
Im Folgenden einige kurze Beispiele zur Manipulation von Faktoren.

\begin{lstlisting}
f <- factor(c("rot", "blau", "rot"))
f <- relevel(f, "rot")  # "rot" wird erster Level

# Reihenfolge der Levels festlegen
f <- factor(c("rot", "blau", "rot"), c("rot", "blau"))
#f < "blau"             ##Warning: < nicht sinnvoll
f <- ordered(c("rot", "blau", "rot"), c("rot", "blau"))
f < "blau"              # TRUE FALSE  TRUE

levels(f)[levels(f) == "rot"] <- "grün" # "rot" wird "grün"

# Mehrere Levels umbenennen, zusammenfassen
f <- factor(c("j","n","ja","X","ja","nein","X"))
levels(f)                # "j" "ja" "n" "nein" "X"
levels(f)[match(c("j","n"), levels(f))] <- c("ja","nein")
levels(f)                # ja nein X
#
f <- factor(c("j","n","ja","X","ja","nein","X"))
levels(f) <- list(ja=c("ja","j"), nein=c("nein","n"), X="X")
#
f <- factor(c("j","n","ja","X","ja","nein","X"))
local({
  s <- c(ja="j", nein="n", m="u")
  i <- match(levels(f), s, 0)
  levels(f)[i != 0] <<- names(s)[i]
})

f <- factor(c("A","B"), levels = c("A","B","C"))
levels(f)                # "A" "B" "C"
f <- droplevels(f)       # Entfernt unbenutzte Levels
levels(f)                # "A" "B"
#f[3] <- "C"             ##Warning => NA
levels(f) <- c(levels(f), "C") 
f[3] <- "C"

f <- factor(c(2,1,3,2,1), c(2,3,1))
unclass(f)               # 1 3 2 1 3; Interner Repräsentant
as.integer(f)            # 1 3 2 1 3
as.numeric(levels(f))[f] # 2 1 3 2 1
as.character(f)          # "2" "1" "3" "2" "1"

f <- factor(c("b","a","b","c","a"))
x <- table(f)            # a b c; Häufigkeiten pro Level
                         # 2 2 1
summary(f)               # 2 2 1
addmargins(x)            # 2 2 1 5
proportions(x)           # 0.4 0.4 0.2

f1 <- factor(c("A","A","B","B"))
f2 <- factor(c("X","Y","X","X"))
f12 <- interaction(f1, f2) # Kombinieren
f12                      # A.X A.Y B.X B.X
levels(f12)              # "A.X" "B.X" "A.Y" "B.Y"
f12 <- interaction(f1, f2, drop=TRUE) # Nur vorhandene Kombis
levels(f12)              # "A.X" "B.X" "A.Y"
f <- c(f1, f2)           # Faktoren zusammen hängen
f3 <- factor(c("1","1","2","2"))
table(f1, f2, f3)        # 3D Tabelle
ftable(f1, f2, f3)       # 2D Tabelle
x <- c(1.3, 2.4, 0.2, 1.1)
xtabs(x ~ f1 + f2, data.frame(x, f1, f2)) # Summiert x je Gruppe
\end{lstlisting}

\subsection{Vektor}

Das folgende Beispiel zeigt grundlegende Operationen mit Vektoren in
R, einschließlich Erstellen, Indexieren, Sortieren, Gruppieren und
Mengenoperationen.

\begin{lstlisting}
x <- 1:3          # 1 2 3; Integer
x[2] <- 4         # 1 4 3; zweites Element ändern, Int->Numeric
x[2:3] <- 5:6     # 1 5 6
x[x>1] <- 2       # 1 2 2; Alle >1 auf 2 ändern
x[5] <- 5         # 1 2 2 NA 5; Element hinterm Ende einfügen
x <- c(x, 6)      # 1 2 2 NA 5 6; Element anhängen
append(x, 7, 3)   # 1 2 2 7 NA 5 6; nach Position 3 einfügen
x <- tail(x, 4)   # 2 NA 5 6; Letzten 4 Elemente behalten
x <- head(x, 3)   # 2 NA 5; Ersten 3 Elemente behalten
x <- x[-2]        # 2 5; entfernt zweites Element
x <- rev(x)       # 5 2; Reihung umkehren
i <- order(x)     # 2 1; Index mit dem x sortiert ist
order(c(1,2,1))   # 1 3 2
rank(c(1,2,1))    # 1.5 3.0 1.5
x[i]              # 2 5
is.unsorted(x)    # TRUE
is.unsorted(x[i]) # FALSE
x <- sort(x)      # 2 5
x <- x + 1        # 3 6; Alle um 1 erhöhen
x[2] <- "a"       # "3" "a"; Umwandlung in Char
as.numeric(c("1", "2")) # 1 2; explizite Umwandlung

x <- c(2, 2, 1, 1, 3)
unique(x)         # 2 1 3
duplicated(x)     # FALSE TRUE FALSE TRUE FALSE
table(x)          # 1 2 3; Anzahlen
                  # 2 2 1
stem(x)           # stem-and-leaf plot
summary(x)        # Min. 1st Qu. Median Mean 3rd Qu. Max.
range(x)          # 1 3; kleinster und größter Wert
length(x)         # 5; Anzahl Elemente
which.max(x)      # 5; Index des ersten größten Wertes
which.min(x)      # 3; Index des ersten kleinsten Wertes
rle(x)            # lengths: int [1:3] 2 2 1;Run Length Encoding
                  # values : num [1:3] 2 1 3
g <- c("A", "A", "C", "B", "B")
ave(x, g)         # Gruppenmittel für jedes Element
tapply(x, g, mean) # Mittel je Gruppe
s <- split(x, g)  # Teil x in Liste grupiert mit g
lapply(s, mean)   # Mittel je Gruppe
match(x, c(3,1,3))# NA NA  2  2  1; Position erster Treffer
x %in% 1:2        # TRUE  TRUE  TRUE  TRUE FALSE
findInterval(x, c(0,2)) # 2 2 1 1 2;
pmin(x, 2)        # 2 2 1 1 2
pmin(x, 0:4)      # 0 1 1 1 3
pmax(x, 0:4)      # 2 2 2 3 4

x <- c(1,2,3,4)
y <- c(3,4,5,6)
union(x, y)       # 1 2 3 4 5 6; Vereinigung
intersect(x, y)   # 3 4;         Schnittmenge
setdiff(x, y)     # 1 2; Elemente in x, aber nicht in y
setdiff(y, x)     # 5 6; Elemente in y, aber nicht in x
setequal(x, y)    # FALSE; # Mengen gleich?
setequal(x, 4:1)  # TRUE
\end{lstlisting}

\subsection{Matrix und Array}

\begin{lstlisting}
m <- matrix(1:6, 2)  # 2x3 Matrix
as.vector(m)         # Matrix in Vektor
as.data.frame(m)     # Matrix in Data Frame
as.matrix(1:4)       # Vektor in Matrix
rownames(m) <- c("A","B")
colnames(m) <- c("x","y","z")
dimnames(m)          # Dimensionsnamen
t(m)                 # Transponieren
dim(m) <- c(3,2)     # Neue Dimensionen setzen
aperm(m, c(2,1))     # Dimensionen vertauschen

m <- matrix(1:4, 2)
v <- 1:2
m + 1                # Elementweise Rechenoperationen
m + m
m + v                # Spaltenweises Recycling von v
m + v[col(m)]        # Zeilenweise Addition
sweep(m, 1, v, `+`)  # Spaltenweise Addition
sweep(m, 2, v, `+`)  # Zeilenweise Addition
outer(v, 1:3)        # Kreuzweise Kombination zweier Vektoren
outer(v, 1:3, `+`)
outer(v, 1:3, \(x, y) x+y)
row(m)               # Zeilenindex
col(m)               # Spaltenindex
slice.index(m, 1)    # Zeilenindex
slice.index(m, 1:2)  # Vektorindex

m %*% m              # Matrixprodukt
matrix(c(sum(m[1,] * m[,1]), sum(m[2,] * m[,1]),
         sum(m[1,] * m[,2]), sum(m[2,] * m[,2])), 2)
m %*% v              # 7 10
crossprod(m, v)      # t(m) %*% v
tcrossprod(v, m)     # v %*% t(m)
kronecker(diag(1, 2), m) # Kronecker produkt
diag(2)              # Einheitsmatrix
diag(m)              # Diagonale extrahieren
diag(m) <- 0         # Diagonale ändern

m <- matrix(1:6, 2)
rowSums(m)           # 9 12
colSums(m)           # 3 7 11
addmargins(m)        # Zeilen und Spaltensummen
rowMeans(m)          # 3 4
colMeans(m)          # 1.5 3.5 5.5
apply(m, 1, mean)    # 3 4; Margin 1..Zeile
apply(m, 2, sum)     # 3 7 11; Margin 2..Spalte
apply(m, 1, sd)      # 2 2; Standard Deviation
max.col(m)           # 3 3; Splalte mit größtem Wert
apply(m, 1, which.max)# 3 3; Splalte mit größtem Wert

y <- scale(m)        # Zentriert und skaliert Spalten
x <- sweep(m, 2, colMeans(m))
x <- sweep(x, 2, apply(x, 2, sd), `/`)
all(x == y)          # TRUE

proportions(m)       # Gesamte Matrix Summe = 1
proportions(m, 1)    # Zeilenweise
proportions(m, 2)    # Spaltenweise

m <- matrix(1:12, 4)
g <- c("A","B","A","B")
rowsum(m, g)         # Gruppierte Zeilensummen

rbind(m, m)          # Zeilen anhängen
n <- m
colnames(m) <- 1:3
colnames(n) <- 3:1
rbind(m, n)          # Namen werden nicht berücksichtigt
cbind(m, m)          # Spalten anfügen
simplify2array(list(m, m)) # Array aus Matrix
replicate(2, m)      # Array aus Matrix
abind::abind(m, m, along=3) # Beliebig stapeln

split(m, col(m))     # Spaltenweise Aufteilung als Liste
split(m, row(m))     # Zeilenweise Aufteilung

a <- array(1:24, dim=c(2,3,4))
apply(a, 1, sum)     # 144 156; Summe je Zeile
apply(a, 3, sum)     # 21 57 93 129; Summe je Schicht
apply(a, c(1,3), sum)# Summe je Zeile und Schicht
aperm(a, c(2,1,3))   # Dimensionen vertauschen
b <- a[1,,,drop=FALSE]
drop(b)              # Entfernt 1 Element Dimensionen
i <- which(a > 20)   # Vektor index
which(a > 20, arr.ind=TRUE) # Indizes als Matrix
arrayInd(i, dim(a))  # Wandelt in Matrix Index
\end{lstlisting}

Lineare Algebra

\begin{lstlisting}
A <- matrix(c(2,1,1,3), 2)
b <- c(1,4)

solve(A, b)     # Löst A x = b
solve(A)        # Inverse Matrix
det(A)          # Determinante
eigen(A)        # Eigenwerte/-vektoren
svd(A)          # Singulärwertzerlegung
qr(A)           # QR-Zerlegung
chol(A)         # Cholesky-Zerlegung (symm. positiv)
\end{lstlisting}

\subsection{List und data.frame}

\begin{lstlisting}
l <- list(a = 1:3, b = c("x", "y"), c = TRUE)
lengths(l)      # 3 2 1; Länge der Elemente

l$d <- 99       # Neues Element
l$a <- list(10,20) # Bestehendes Element ersetzen
l$c <- NULL     # Element entfernen
l["c"] <- list(NULL) # NULL einfügen
unlist(l)       # "10" "20" "x" "y" "99"; List in Vektor ohne NULL
unlist(l, FALSE) # Nicht rekursiv, bleibt hier Liste

l2 <- list(a=1, b=2)
c(l, l2)        # Listen zusammenfügen

list(1:3)       # [[1]] 1 2 3
as.list(1:3)    # [[1]] 1 [[2]] 2 [[3]] 3
as.list(iris)   # data.frame => list, Eintrag je Spalte

l <- list(a=1:2, b=list(1, 1:2))
data.frame(l)   # Wandelt b in 2 Vektorspalten um
as.data.frame(l)# Wandelt b in 2 Vektorspalten um
d <- list2DF(l) # b bleibt Liste
d$c <- matrix(1:4, 2) # Matrix als Spalte
d$d <- array(1:8, c(2,2,2)) # Array als Spalte
d[1,]           # Funktioniert bei Array nicht wie erwartet
tibble::tibble(d)[1,] # Hier wie erwartet
#as.matrix(d)         ##Error
as.matrix(d[c(1,2)])  # Geht
as.matrix(d[c(1,3)])  # Geht
#as.matrix(d[c(2,3)]) ##Error

l <- list(a=2, b=3:5, c=5:9)
x <- lapply(l, mean) # [[1]] 2 [[2]] 4 [[3]] 7; Liste
simplify2array(x)    # 2 4 7; Vereinfacht Liste
sapply(l, mean)      # 2 4 7; In einem Schritt
vapply(x, mean, numeric(1)) # 2 4 7; Angabe der Rückgabe

l <- list(a=1:3, b=list(c=3:5, d=5:9))
rapply(l, mean,)     # 2 4 7; rekursiv in Liste anwenden

l1 <- list(1,c(2,3))
l2 <- list(10,c(20,30))
mapply(sum, l1, l2)  # 11 55; mehere Listen gemeinsam
Map(sum, l1, l2)     # Ausgabe als Liste
mapply(sum, l1, l2, SIMPLIFY = FALSE) # Ausgabe als Liste

replicate(2, 1:3, simplify=FALSE) # n mal wiederholen

l <- list(a=1, b=2:3)
do.call(paste, l)             # "1 2" "1 3"
  # Ruft Funktion mit Argumenten aus Liste auf
paste(1, 2:3)                 # "1 2" "1 3"
do.call(paste, c(l, sep="-")) # "1-2" "1-3"
l <- list(a=1, b=2:3, sep="-")
do.call(paste, l)             # "1-2" "1-3"
paste(1, 2:3, sep="-")        # "1-2" "1-3"

l <- list(a=2, b=3:5, c=5:9)
Reduce(\(x, y) x * sum(y), l) # 840; Kumulatives Anwenden
Reduce(\(x, y) x * sum(y), l, 2) # 1680; Mit Startwert
Reduce(\(x, y) x * sum(y), l, 2, accumulate = TRUE)
  # 2 4 48 1680; Jeden Zwischenschritt ausgeben

l <- list(c=1:3, b="x", a=4)
Filter(is.numeric, l)   # Nur numerische Elemente
l[order(names(l))]      # Nach Namen Sortieren
names(l) <- toupper(names(l)) # Namen ändern
\end{lstlisting}

\begin{lstlisting}
d <- data.frame(a=1:4, b=c("x","y"), c=TRUE)
  # b und c werden automatisch wiederholt
dim(d)        # 4 3; Zeilen Spalten
length(d)     # 3; Anzahl Spalten
ncol(d)       # 3; Anzahl Spalten
nrow(d)       # 4; Anzahl Zeilen
names(d)      # Spaltennamen
row.names(d)  # Zeilennamen

#d$d <- 1:3   ## Fehler der Länge
#d$d <- 1:5   ## Fehler der Länge
d$d <- 1:4
d$e <- 1:2    # Wird zu 1 2 1 2
d$f <- 1      # Wird zu 1 1 1 1

d <- data.frame(a=1:2, b=c("x","y"))
d2<- data.frame(b=c("a","b"), a=4:3)
d <- rbind(d, d2) # Zeilen anfügen über Spaltennamen
d3<- data.frame(d=5:6, e=c("f","g"))
#rbind(d, d3)     ## Error, Namen passen nicht
rbind(d, setNames(d3, names(d))) # Spalten umbenenne

d <- data.frame(a=1:2, b=c("x","y"))
d2<- data.frame(a=2:3, c=c(TRUE, FALSE))
cbind(d, d2)      # Spalten anhängen
merge(d, d2)      # Spalten über gemeinsame Spalte a anhängen
merge(d, d2, all=TRUE)   # Alle Daten erhalten
merge(d, d2, all.x=TRUE) # Alle Daten von d  erhalten
merge(d, d2, all.y=TRUE) # Alle Daten von d2 erhalten
d3<- data.frame(a=1, c=c(TRUE, FALSE))
merge(d, d3)      # Zeile 1 von d wird wiederholt
d4<- data.frame(a=1, b=c("x","y"))
merge(d4, d3)      # Alle Kombinationen werden generiert

d <- data.frame(a=1:4, b=c("x","y"))
d$a <- 4:1              # Inhalt von Spalte ändern
d[2,] <- list(5L, "z")  # Inhalt von Zeile ändern
d[2:3,] <- list(7:8, "X")  # Inhalt von Zeilen ändern
d$a <- NULL             # Löscht Spalte a
#d[2,] <- NULL          ## Error
d <- d[-2,,drop=FALSE]  # Löscht Zeile 2
\end{lstlisting}

\end{document}


